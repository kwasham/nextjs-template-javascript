"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_0___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InternalAIProvider: () => (/* binding */ InternalAIProvider),\n/* harmony export */   readStreamableValue: () => (/* binding */ readStreamableValue),\n/* harmony export */   useAIState: () => (/* binding */ useAIState),\n/* harmony export */   useActions: () => (/* binding */ useActions),\n/* harmony export */   useStreamableValue: () => (/* binding */ useStreamableValue),\n/* harmony export */   useSyncUIState: () => (/* binding */ useSyncUIState),\n/* harmony export */   useUIState: () => (/* binding */ useUIState)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jsondiffpatch */ \"(ssr)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* __next_internal_client_entry_do_not_use__ InternalAIProvider,readStreamableValue,useAIState,useActions,useStreamableValue,useSyncUIState,useUIState auto */ // rsc/shared-client/streamable.tsx\n\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/shared-client/streamable.tsx\nfunction hasReadableValueSignature(value) {\n    return !!(value && typeof value === \"object\" && \"type\" in value && value.type === STREAMABLE_VALUE_TYPE);\n}\nfunction assertStreamableValue(value) {\n    if (!hasReadableValueSignature(value)) {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n}\nfunction isStreamableValue(value) {\n    const hasSignature = hasReadableValueSignature(value);\n    if (!hasSignature && typeof value !== \"undefined\") {\n        throw new Error(\"Invalid value: this hook only accepts values created via `createStreamableValue`.\");\n    }\n    return hasSignature;\n}\nfunction readStreamableValue(streamableValue) {\n    assertStreamableValue(streamableValue);\n    return {\n        [Symbol.asyncIterator] () {\n            let row = streamableValue;\n            let curr = row.curr;\n            let done = false;\n            let initial = true;\n            return {\n                async next () {\n                    if (done) return {\n                        value: curr,\n                        done: true\n                    };\n                    row = await row;\n                    if (typeof row.error !== \"undefined\") {\n                        throw row.error;\n                    }\n                    if (\"curr\" in row || row.diff) {\n                        if (row.diff) {\n                            switch(row.diff[0]){\n                                case 0:\n                                    if (typeof curr !== \"string\") {\n                                        throw new Error(\"Invalid patch: can only append to string types. This is a bug in the AI SDK.\");\n                                    } else {\n                                        curr = curr + row.diff[1];\n                                    }\n                                    break;\n                            }\n                        } else {\n                            curr = row.curr;\n                        }\n                        if (!row.next) {\n                            done = true;\n                            return {\n                                value: curr,\n                                done: false\n                            };\n                        }\n                    }\n                    if (!row.next) {\n                        return {\n                            value: curr,\n                            done: true\n                        };\n                    }\n                    row = row.next;\n                    if (initial) {\n                        initial = false;\n                        if (typeof curr === \"undefined\") {\n                            return this.next();\n                        }\n                    }\n                    return {\n                        value: curr,\n                        done: false\n                    };\n                }\n            };\n        }\n    };\n}\nfunction useStreamableValue(streamableValue) {\n    const [curr, setCurr] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.curr : void 0);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? streamableValue.error : void 0);\n    const [pending, setPending] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(isStreamableValue(streamableValue) ? !!streamableValue.next : false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(()=>{\n        if (!isStreamableValue(streamableValue)) return;\n        let cancelled = false;\n        const iterator = readStreamableValue(streamableValue);\n        if (streamableValue.next) {\n            (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                if (cancelled) return;\n                setPending(true);\n            });\n        }\n        (async ()=>{\n            try {\n                for await (const value of iterator){\n                    if (cancelled) return;\n                    (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                        if (cancelled) return;\n                        setCurr(value);\n                    });\n                }\n            } catch (e) {\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setError(e);\n                });\n            } finally{\n                if (cancelled) return;\n                (0,react__WEBPACK_IMPORTED_MODULE_0__.startTransition)(()=>{\n                    if (cancelled) return;\n                    setPending(false);\n                });\n            }\n        })();\n        return ()=>{\n            cancelled = true;\n        };\n    }, [\n        streamableValue\n    ]);\n    return [\n        curr,\n        error,\n        pending\n    ];\n}\n// rsc/shared-client/context.tsx\n\n\n// rsc/utils.tsx\n\n\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nvar isFunction = (x)=>typeof x === \"function\";\n// rsc/shared-client/context.tsx\n\nvar InternalUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalAIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(void 0);\nvar InternalActionProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nvar InternalSyncUIStateProvider = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nfunction InternalAIProvider({ children, initialUIState, initialAIState, initialAIStatePatch, wrappedActions, wrappedSyncUIState }) {\n    if (!(\"use\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_0___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_0__, 2))))) {\n        throw new Error(\"Unsupported React version.\");\n    }\n    const uiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialUIState);\n    const setUIState = uiState[1];\n    const resolvedInitialAIStatePatch = initialAIStatePatch ? react__WEBPACK_IMPORTED_MODULE_0__.use(initialAIStatePatch) : void 0;\n    initialAIState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (resolvedInitialAIStatePatch) {\n            return jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(initialAIState), resolvedInitialAIStatePatch);\n        }\n        return initialAIState;\n    }, [\n        initialAIState,\n        resolvedInitialAIStatePatch\n    ]);\n    const aiState = react__WEBPACK_IMPORTED_MODULE_0__.useState(initialAIState);\n    const setAIState = aiState[1];\n    const aiStateRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(aiState[0]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        aiStateRef.current = aiState[0];\n    }, [\n        aiState[0]\n    ]);\n    const clientWrappedActions = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.fromEntries(Object.entries(wrappedActions).map(([key, action])=>[\n                key,\n                async (...args)=>{\n                    const aiStateSnapshot = aiStateRef.current;\n                    const [aiStateDelta, result] = await action(aiStateSnapshot, ...args);\n                    (async ()=>{\n                        const delta = await aiStateDelta;\n                        if (delta !== void 0) {\n                            aiState[1](jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta));\n                        }\n                    })();\n                    return result;\n                }\n            ])), [\n        wrappedActions\n    ]);\n    const clientWrappedSyncUIStateAction = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        if (!wrappedSyncUIState) {\n            return ()=>{};\n        }\n        return async ()=>{\n            const aiStateSnapshot = aiStateRef.current;\n            const [aiStateDelta, uiState2] = await wrappedSyncUIState(aiStateSnapshot);\n            if (uiState2 !== void 0) {\n                setUIState(uiState2);\n            }\n            const delta = await aiStateDelta;\n            if (delta !== void 0) {\n                const patchedAiState = jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.patch(jsondiffpatch__WEBPACK_IMPORTED_MODULE_2__.clone(aiStateSnapshot), delta);\n                setAIState(patchedAiState);\n            }\n        };\n    }, [\n        wrappedSyncUIState\n    ]);\n    return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalAIStateProvider.Provider, {\n        value: aiState,\n        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalUIStateProvider.Provider, {\n            value: uiState,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalActionProvider.Provider, {\n                value: clientWrappedActions,\n                children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(InternalSyncUIStateProvider.Provider, {\n                    value: clientWrappedSyncUIStateAction,\n                    children\n                })\n            })\n        })\n    });\n}\nfunction useUIState() {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalUIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useUIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialUIState` must be provided to `createAI` or `<AI>`\");\n    }\n    return state;\n}\nfunction useAIState(...args) {\n    const state = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalAIStateProvider);\n    if (state === null) {\n        throw new Error(\"`useAIState` must be used inside an <AI> provider.\");\n    }\n    if (!Array.isArray(state)) {\n        throw new Error(\"Invalid state\");\n    }\n    if (state[0] === void 0) {\n        throw new Error(\"`initialAIState` must be provided to `createAI` or `<AI>`\");\n    }\n    if (args.length >= 1 && typeof state[0] !== \"object\") {\n        throw new Error(\"When using `useAIState` with a key, the AI state must be an object.\");\n    }\n    const key = args[0];\n    const setter = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(typeof key === \"undefined\" ? state[1] : (newState)=>{\n        if (isFunction(newState)) {\n            return state[1]((s)=>{\n                return {\n                    ...s,\n                    [key]: newState(s[key])\n                };\n            });\n        } else {\n            return state[1]({\n                ...state[0],\n                [key]: newState\n            });\n        }\n    }, [\n        key\n    ]);\n    if (args.length === 0) {\n        return state;\n    } else {\n        return [\n            state[0][args[0]],\n            setter\n        ];\n    }\n}\nfunction useActions() {\n    const actions = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalActionProvider);\n    return actions;\n}\nfunction useSyncUIState() {\n    const syncUIState = react__WEBPACK_IMPORTED_MODULE_0__.useContext(InternalSyncUIStateProvider);\n    if (syncUIState === null) {\n        throw new Error(\"`useSyncUIState` must be used inside an <AI> provider.\");\n    }\n    return syncUIState;\n}\n //# sourceMappingURL=rsc-shared.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7K0pBRUEsbUNBQW1DO0FBQ2dDO0FBRW5FLG1CQUFtQjtBQUNuQixJQUFJRyx3QkFBd0JDLE9BQU9DLEdBQUcsQ0FBQztBQUN2QyxJQUFJQyxzQ0FBc0MsS0FBSztBQUUvQyxtQ0FBbUM7QUFDbkMsU0FBU0MsMEJBQTBCQyxLQUFLO0lBQ3RDLE9BQU8sQ0FBQyxDQUFFQSxDQUFBQSxTQUFTLE9BQU9BLFVBQVUsWUFBWSxVQUFVQSxTQUFTQSxNQUFNQyxJQUFJLEtBQUtOLHFCQUFvQjtBQUN4RztBQUNBLFNBQVNPLHNCQUFzQkYsS0FBSztJQUNsQyxJQUFJLENBQUNELDBCQUEwQkMsUUFBUTtRQUNyQyxNQUFNLElBQUlHLE1BQ1I7SUFFSjtBQUNGO0FBQ0EsU0FBU0Msa0JBQWtCSixLQUFLO0lBQzlCLE1BQU1LLGVBQWVOLDBCQUEwQkM7SUFDL0MsSUFBSSxDQUFDSyxnQkFBZ0IsT0FBT0wsVUFBVSxhQUFhO1FBQ2pELE1BQU0sSUFBSUcsTUFDUjtJQUVKO0lBQ0EsT0FBT0U7QUFDVDtBQUNBLFNBQVNDLG9CQUFvQkMsZUFBZTtJQUMxQ0wsc0JBQXNCSztJQUN0QixPQUFPO1FBQ0wsQ0FBQ1gsT0FBT1ksYUFBYSxDQUFDO1lBQ3BCLElBQUlDLE1BQU1GO1lBQ1YsSUFBSUcsT0FBT0QsSUFBSUMsSUFBSTtZQUNuQixJQUFJQyxPQUFPO1lBQ1gsSUFBSUMsVUFBVTtZQUNkLE9BQU87Z0JBQ0wsTUFBTUM7b0JBQ0osSUFBSUYsTUFDRixPQUFPO3dCQUFFWCxPQUFPVTt3QkFBTUMsTUFBTTtvQkFBSztvQkFDbkNGLE1BQU0sTUFBTUE7b0JBQ1osSUFBSSxPQUFPQSxJQUFJSyxLQUFLLEtBQUssYUFBYTt3QkFDcEMsTUFBTUwsSUFBSUssS0FBSztvQkFDakI7b0JBQ0EsSUFBSSxVQUFVTCxPQUFPQSxJQUFJTSxJQUFJLEVBQUU7d0JBQzdC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LXByby9uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNoYXJlZC5tanM/ZmVlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuLy8gcnNjL3NoYXJlZC1jbGllbnQvc3RyZWFtYWJsZS50c3hcbmltcG9ydCB7IHN0YXJ0VHJhbnNpdGlvbiwgdXNlTGF5b3V0RWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuXG4vLyByc2MvY29uc3RhbnRzLnRzXG52YXIgU1RSRUFNQUJMRV9WQUxVRV9UWVBFID0gU3ltYm9sLmZvcihcInVpLnN0cmVhbWFibGUudmFsdWVcIik7XG52YXIgREVWX0RFRkFVTFRfU1RSRUFNQUJMRV9XQVJOSU5HX1RJTUUgPSAxNSAqIDFlMztcblxuLy8gcnNjL3NoYXJlZC1jbGllbnQvc3RyZWFtYWJsZS50c3hcbmZ1bmN0aW9uIGhhc1JlYWRhYmxlVmFsdWVTaWduYXR1cmUodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiB2YWx1ZSAmJiB2YWx1ZS50eXBlID09PSBTVFJFQU1BQkxFX1ZBTFVFX1RZUEUpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U3RyZWFtYWJsZVZhbHVlKHZhbHVlKSB7XG4gIGlmICghaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBcIkludmFsaWQgdmFsdWU6IHRoaXMgaG9vayBvbmx5IGFjY2VwdHMgdmFsdWVzIGNyZWF0ZWQgdmlhIGBjcmVhdGVTdHJlYW1hYmxlVmFsdWVgLlwiXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNTdHJlYW1hYmxlVmFsdWUodmFsdWUpIHtcbiAgY29uc3QgaGFzU2lnbmF0dXJlID0gaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSh2YWx1ZSk7XG4gIGlmICghaGFzU2lnbmF0dXJlICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZTogdGhpcyBob29rIG9ubHkgYWNjZXB0cyB2YWx1ZXMgY3JlYXRlZCB2aWEgYGNyZWF0ZVN0cmVhbWFibGVWYWx1ZWAuXCJcbiAgICApO1xuICB9XG4gIHJldHVybiBoYXNTaWduYXR1cmU7XG59XG5mdW5jdGlvbiByZWFkU3RyZWFtYWJsZVZhbHVlKHN0cmVhbWFibGVWYWx1ZSkge1xuICBhc3NlcnRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgbGV0IHJvdyA9IHN0cmVhbWFibGVWYWx1ZTtcbiAgICAgIGxldCBjdXJyID0gcm93LmN1cnI7XG4gICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgbGV0IGluaXRpYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYXN5bmMgbmV4dCgpIHtcbiAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBjdXJyLCBkb25lOiB0cnVlIH07XG4gICAgICAgICAgcm93ID0gYXdhaXQgcm93O1xuICAgICAgICAgIGlmICh0eXBlb2Ygcm93LmVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyByb3cuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChcImN1cnJcIiBpbiByb3cgfHwgcm93LmRpZmYpIHtcbiAgICAgICAgICAgIGlmIChyb3cuZGlmZikge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHJvdy5kaWZmWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgcGF0Y2g6IGNhbiBvbmx5IGFwcGVuZCB0byBzdHJpbmcgdHlwZXMuIFRoaXMgaXMgYSBidWcgaW4gdGhlIEFJIFNESy5cIlxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnIgKyByb3cuZGlmZlsxXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyID0gcm93LmN1cnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJvdy5uZXh0KSB7XG4gICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghcm93Lm5leHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICByb3cgPSByb3cubmV4dDtcbiAgICAgICAgICBpZiAoaW5pdGlhbCkge1xuICAgICAgICAgICAgaW5pdGlhbCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBjdXJyLFxuICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHVzZVN0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpIHtcbiAgY29uc3QgW2N1cnIsIHNldEN1cnJdID0gdXNlU3RhdGUoXG4gICAgaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5jdXJyIDogdm9pZCAwXG4gICk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUoXG4gICAgaXNTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKSA/IHN0cmVhbWFibGVWYWx1ZS5lcnJvciA6IHZvaWQgMFxuICApO1xuICBjb25zdCBbcGVuZGluZywgc2V0UGVuZGluZ10gPSB1c2VTdGF0ZShcbiAgICBpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpID8gISFzdHJlYW1hYmxlVmFsdWUubmV4dCA6IGZhbHNlXG4gICk7XG4gIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFpc1N0cmVhbWFibGVWYWx1ZShzdHJlYW1hYmxlVmFsdWUpKVxuICAgICAgcmV0dXJuO1xuICAgIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICBjb25zdCBpdGVyYXRvciA9IHJlYWRTdHJlYW1hYmxlVmFsdWUoc3RyZWFtYWJsZVZhbHVlKTtcbiAgICBpZiAoc3RyZWFtYWJsZVZhbHVlLm5leHQpIHtcbiAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzZXRQZW5kaW5nKHRydWUpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIChhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIGl0ZXJhdG9yKSB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzdGFydFRyYW5zaXRpb24oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZClcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0Q3Vycih2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZClcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIHN0YXJ0VHJhbnNpdGlvbigoKSA9PiB7XG4gICAgICAgICAgaWYgKGNhbmNlbGxlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICBzZXRFcnJvcihlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgc3RhcnRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICBpZiAoY2FuY2VsbGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIHNldFBlbmRpbmcoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KSgpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgIH07XG4gIH0sIFtzdHJlYW1hYmxlVmFsdWVdKTtcbiAgcmV0dXJuIFtjdXJyLCBlcnJvciwgcGVuZGluZ107XG59XG5cbi8vIHJzYy9zaGFyZWQtY2xpZW50L2NvbnRleHQudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgKiBhcyBqc29uZGlmZnBhdGNoIGZyb20gXCJqc29uZGlmZnBhdGNoXCI7XG5cbi8vIHJzYy91dGlscy50c3hcbmltcG9ydCB7IFN1c3BlbnNlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBGcmFnbWVudCwganN4LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUiA9IFtcbiAgYXN5bmMgKHtcbiAgICBjLFxuICAgIC8vIGN1cnJlbnRcbiAgICBuXG4gICAgLy8gbmV4dFxuICB9KSA9PiB7XG4gICAgY29uc3QgY2h1bmsgPSBhd2FpdCBuO1xuICAgIGlmIChjaHVuay5kb25lKSB7XG4gICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgfVxuICAgIGlmIChjaHVuay5hcHBlbmQpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICBjLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFN1c3BlbnNlLCB7IGZhbGxiYWNrOiBjaHVuay52YWx1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUiwgeyBjOiBjaHVuay52YWx1ZSwgbjogY2h1bmsubmV4dCB9KSB9KVxuICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU3VzcGVuc2UsIHsgZmFsbGJhY2s6IGNodW5rLnZhbHVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChSLCB7IGM6IGNodW5rLnZhbHVlLCBuOiBjaHVuay5uZXh0IH0pIH0pO1xuICB9XG5dWzBdO1xudmFyIGlzRnVuY3Rpb24gPSAoeCkgPT4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcblxuLy8gcnNjL3NoYXJlZC1jbGllbnQvY29udGV4dC50c3hcbmltcG9ydCB7IGpzeCBhcyBqc3gyIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgSW50ZXJuYWxVSVN0YXRlUHJvdmlkZXIgPSBSZWFjdDIuY3JlYXRlQ29udGV4dChudWxsKTtcbnZhciBJbnRlcm5hbEFJU3RhdGVQcm92aWRlciA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KHZvaWQgMCk7XG52YXIgSW50ZXJuYWxBY3Rpb25Qcm92aWRlciA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KG51bGwpO1xudmFyIEludGVybmFsU3luY1VJU3RhdGVQcm92aWRlciA9IFJlYWN0Mi5jcmVhdGVDb250ZXh0KG51bGwpO1xuZnVuY3Rpb24gSW50ZXJuYWxBSVByb3ZpZGVyKHtcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxVSVN0YXRlLFxuICBpbml0aWFsQUlTdGF0ZSxcbiAgaW5pdGlhbEFJU3RhdGVQYXRjaCxcbiAgd3JhcHBlZEFjdGlvbnMsXG4gIHdyYXBwZWRTeW5jVUlTdGF0ZVxufSkge1xuICBpZiAoIShcInVzZVwiIGluIFJlYWN0MikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBSZWFjdCB2ZXJzaW9uLlwiKTtcbiAgfVxuICBjb25zdCB1aVN0YXRlID0gUmVhY3QyLnVzZVN0YXRlKGluaXRpYWxVSVN0YXRlKTtcbiAgY29uc3Qgc2V0VUlTdGF0ZSA9IHVpU3RhdGVbMV07XG4gIGNvbnN0IHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCA9IGluaXRpYWxBSVN0YXRlUGF0Y2ggPyBSZWFjdDIudXNlKGluaXRpYWxBSVN0YXRlUGF0Y2gpIDogdm9pZCAwO1xuICBpbml0aWFsQUlTdGF0ZSA9IFJlYWN0Mi51c2VNZW1vKCgpID0+IHtcbiAgICBpZiAocmVzb2x2ZWRJbml0aWFsQUlTdGF0ZVBhdGNoKSB7XG4gICAgICByZXR1cm4ganNvbmRpZmZwYXRjaC5wYXRjaChcbiAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShpbml0aWFsQUlTdGF0ZSksXG4gICAgICAgIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaFxuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXRpYWxBSVN0YXRlO1xuICB9LCBbaW5pdGlhbEFJU3RhdGUsIHJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaF0pO1xuICBjb25zdCBhaVN0YXRlID0gUmVhY3QyLnVzZVN0YXRlKGluaXRpYWxBSVN0YXRlKTtcbiAgY29uc3Qgc2V0QUlTdGF0ZSA9IGFpU3RhdGVbMV07XG4gIGNvbnN0IGFpU3RhdGVSZWYgPSBSZWFjdDIudXNlUmVmKGFpU3RhdGVbMF0pO1xuICBSZWFjdDIudXNlRWZmZWN0KCgpID0+IHtcbiAgICBhaVN0YXRlUmVmLmN1cnJlbnQgPSBhaVN0YXRlWzBdO1xuICB9LCBbYWlTdGF0ZVswXV0pO1xuICBjb25zdCBjbGllbnRXcmFwcGVkQWN0aW9ucyA9IFJlYWN0Mi51c2VNZW1vKFxuICAgICgpID0+IE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIE9iamVjdC5lbnRyaWVzKHdyYXBwZWRBY3Rpb25zKS5tYXAoKFtrZXksIGFjdGlvbl0pID0+IFtcbiAgICAgICAga2V5LFxuICAgICAgICBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICAgIGNvbnN0IGFpU3RhdGVTbmFwc2hvdCA9IGFpU3RhdGVSZWYuY3VycmVudDtcbiAgICAgICAgICBjb25zdCBbYWlTdGF0ZURlbHRhLCByZXN1bHRdID0gYXdhaXQgYWN0aW9uKFxuICAgICAgICAgICAgYWlTdGF0ZVNuYXBzaG90LFxuICAgICAgICAgICAgLi4uYXJnc1xuICAgICAgICAgICk7XG4gICAgICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgICAgICAgaWYgKGRlbHRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgYWlTdGF0ZVsxXShcbiAgICAgICAgICAgICAgICBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgICAgICAgICAganNvbmRpZmZwYXRjaC5jbG9uZShhaVN0YXRlU25hcHNob3QpLFxuICAgICAgICAgICAgICAgICAgZGVsdGFcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICBdKVxuICAgICksXG4gICAgW3dyYXBwZWRBY3Rpb25zXVxuICApO1xuICBjb25zdCBjbGllbnRXcmFwcGVkU3luY1VJU3RhdGVBY3Rpb24gPSBSZWFjdDIudXNlTWVtbygoKSA9PiB7XG4gICAgaWYgKCF3cmFwcGVkU3luY1VJU3RhdGUpIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgYWlTdGF0ZVNuYXBzaG90ID0gYWlTdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgY29uc3QgW2FpU3RhdGVEZWx0YSwgdWlTdGF0ZTJdID0gYXdhaXQgd3JhcHBlZFN5bmNVSVN0YXRlKFxuICAgICAgICBhaVN0YXRlU25hcHNob3RcbiAgICAgICk7XG4gICAgICBpZiAodWlTdGF0ZTIgIT09IHZvaWQgMCkge1xuICAgICAgICBzZXRVSVN0YXRlKHVpU3RhdGUyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbHRhID0gYXdhaXQgYWlTdGF0ZURlbHRhO1xuICAgICAgaWYgKGRlbHRhICE9PSB2b2lkIDApIHtcbiAgICAgICAgY29uc3QgcGF0Y2hlZEFpU3RhdGUgPSBqc29uZGlmZnBhdGNoLnBhdGNoKFxuICAgICAgICAgIGpzb25kaWZmcGF0Y2guY2xvbmUoYWlTdGF0ZVNuYXBzaG90KSxcbiAgICAgICAgICBkZWx0YVxuICAgICAgICApO1xuICAgICAgICBzZXRBSVN0YXRlKHBhdGNoZWRBaVN0YXRlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LCBbd3JhcHBlZFN5bmNVSVN0YXRlXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4MihJbnRlcm5hbEFJU3RhdGVQcm92aWRlci5Qcm92aWRlciwgeyB2YWx1ZTogYWlTdGF0ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3gyKEludGVybmFsVUlTdGF0ZVByb3ZpZGVyLlByb3ZpZGVyLCB7IHZhbHVlOiB1aVN0YXRlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeDIoSW50ZXJuYWxBY3Rpb25Qcm92aWRlci5Qcm92aWRlciwgeyB2YWx1ZTogY2xpZW50V3JhcHBlZEFjdGlvbnMsIGNoaWxkcmVuOiAvKiBAX19QVVJFX18gKi8ganN4MihcbiAgICBJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXIuUHJvdmlkZXIsXG4gICAge1xuICAgICAgdmFsdWU6IGNsaWVudFdyYXBwZWRTeW5jVUlTdGF0ZUFjdGlvbixcbiAgICAgIGNoaWxkcmVuXG4gICAgfVxuICApIH0pIH0pIH0pO1xufVxuZnVuY3Rpb24gdXNlVUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3RhdGUgPSBSZWFjdDIudXNlQ29udGV4dChJbnRlcm5hbFVJU3RhdGVQcm92aWRlcik7XG4gIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImB1c2VVSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuXCIpO1xuICB9XG4gIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0YXRlXCIpO1xuICB9XG4gIGlmIChzdGF0ZVswXSA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgaW5pdGlhbFVJU3RhdGVgIG11c3QgYmUgcHJvdmlkZWQgdG8gYGNyZWF0ZUFJYCBvciBgPEFJPmBcIlxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gdXNlQUlTdGF0ZSguLi5hcmdzKSB7XG4gIGNvbnN0IHN0YXRlID0gUmVhY3QyLnVzZUNvbnRleHQoSW50ZXJuYWxBSVN0YXRlUHJvdmlkZXIpO1xuICBpZiAoc3RhdGUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdXNlQUlTdGF0ZWAgbXVzdCBiZSB1c2VkIGluc2lkZSBhbiA8QUk+IHByb3ZpZGVyLlwiKTtcbiAgfVxuICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBzdGF0ZVwiKTtcbiAgfVxuICBpZiAoc3RhdGVbMF0gPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYGluaXRpYWxBSVN0YXRlYCBtdXN0IGJlIHByb3ZpZGVkIHRvIGBjcmVhdGVBSWAgb3IgYDxBST5gXCJcbiAgICApO1xuICB9XG4gIGlmIChhcmdzLmxlbmd0aCA+PSAxICYmIHR5cGVvZiBzdGF0ZVswXSAhPT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiV2hlbiB1c2luZyBgdXNlQUlTdGF0ZWAgd2l0aCBhIGtleSwgdGhlIEFJIHN0YXRlIG11c3QgYmUgYW4gb2JqZWN0LlwiXG4gICAgKTtcbiAgfVxuICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICBjb25zdCBzZXR0ZXIgPSBSZWFjdDIudXNlQ2FsbGJhY2soXG4gICAgdHlwZW9mIGtleSA9PT0gXCJ1bmRlZmluZWRcIiA/IHN0YXRlWzFdIDogKG5ld1N0YXRlKSA9PiB7XG4gICAgICBpZiAoaXNGdW5jdGlvbihuZXdTdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlWzFdKChzKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHsgLi4ucywgW2tleV06IG5ld1N0YXRlKHNba2V5XSkgfTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3RhdGVbMV0oeyAuLi5zdGF0ZVswXSwgW2tleV06IG5ld1N0YXRlIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgW2tleV1cbiAgKTtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbc3RhdGVbMF1bYXJnc1swXV0sIHNldHRlcl07XG4gIH1cbn1cbmZ1bmN0aW9uIHVzZUFjdGlvbnMoKSB7XG4gIGNvbnN0IGFjdGlvbnMgPSBSZWFjdDIudXNlQ29udGV4dChJbnRlcm5hbEFjdGlvblByb3ZpZGVyKTtcbiAgcmV0dXJuIGFjdGlvbnM7XG59XG5mdW5jdGlvbiB1c2VTeW5jVUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3luY1VJU3RhdGUgPSBSZWFjdDIudXNlQ29udGV4dChcbiAgICBJbnRlcm5hbFN5bmNVSVN0YXRlUHJvdmlkZXJcbiAgKTtcbiAgaWYgKHN5bmNVSVN0YXRlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYHVzZVN5bmNVSVN0YXRlYCBtdXN0IGJlIHVzZWQgaW5zaWRlIGFuIDxBST4gcHJvdmlkZXIuXCIpO1xuICB9XG4gIHJldHVybiBzeW5jVUlTdGF0ZTtcbn1cbmV4cG9ydCB7XG4gIEludGVybmFsQUlQcm92aWRlcixcbiAgcmVhZFN0cmVhbWFibGVWYWx1ZSxcbiAgdXNlQUlTdGF0ZSxcbiAgdXNlQWN0aW9ucyxcbiAgdXNlU3RyZWFtYWJsZVZhbHVlLFxuICB1c2VTeW5jVUlTdGF0ZSxcbiAgdXNlVUlTdGF0ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJzYy1zaGFyZWQubWpzLm1hcCJdLCJuYW1lcyI6WyJzdGFydFRyYW5zaXRpb24iLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VTdGF0ZSIsIlNUUkVBTUFCTEVfVkFMVUVfVFlQRSIsIlN5bWJvbCIsImZvciIsIkRFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FIiwiaGFzUmVhZGFibGVWYWx1ZVNpZ25hdHVyZSIsInZhbHVlIiwidHlwZSIsImFzc2VydFN0cmVhbWFibGVWYWx1ZSIsIkVycm9yIiwiaXNTdHJlYW1hYmxlVmFsdWUiLCJoYXNTaWduYXR1cmUiLCJyZWFkU3RyZWFtYWJsZVZhbHVlIiwic3RyZWFtYWJsZVZhbHVlIiwiYXN5bmNJdGVyYXRvciIsInJvdyIsImN1cnIiLCJkb25lIiwiaW5pdGlhbCIsIm5leHQiLCJlcnJvciIsImRpZmYiLCJ1c2VTdHJlYW1hYmxlVmFsdWUiLCJzZXRDdXJyIiwic2V0RXJyb3IiLCJwZW5kaW5nIiwic2V0UGVuZGluZyIsImNhbmNlbGxlZCIsIml0ZXJhdG9yIiwiZSIsIlJlYWN0MiIsImpzb25kaWZmcGF0Y2giLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4IiwianN4cyIsIlIiLCJjIiwibiIsImNodW5rIiwiYXBwZW5kIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsImlzRnVuY3Rpb24iLCJ4IiwianN4MiIsIkludGVybmFsVUlTdGF0ZVByb3ZpZGVyIiwiY3JlYXRlQ29udGV4dCIsIkludGVybmFsQUlTdGF0ZVByb3ZpZGVyIiwiSW50ZXJuYWxBY3Rpb25Qcm92aWRlciIsIkludGVybmFsU3luY1VJU3RhdGVQcm92aWRlciIsIkludGVybmFsQUlQcm92aWRlciIsImluaXRpYWxVSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGUiLCJpbml0aWFsQUlTdGF0ZVBhdGNoIiwid3JhcHBlZEFjdGlvbnMiLCJ3cmFwcGVkU3luY1VJU3RhdGUiLCJ1aVN0YXRlIiwic2V0VUlTdGF0ZSIsInJlc29sdmVkSW5pdGlhbEFJU3RhdGVQYXRjaCIsInVzZSIsInVzZU1lbW8iLCJwYXRjaCIsImNsb25lIiwiYWlTdGF0ZSIsInNldEFJU3RhdGUiLCJhaVN0YXRlUmVmIiwidXNlUmVmIiwidXNlRWZmZWN0IiwiY3VycmVudCIsImNsaWVudFdyYXBwZWRBY3Rpb25zIiwiT2JqZWN0IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwibWFwIiwia2V5IiwiYWN0aW9uIiwiYXJncyIsImFpU3RhdGVTbmFwc2hvdCIsImFpU3RhdGVEZWx0YSIsInJlc3VsdCIsImRlbHRhIiwiY2xpZW50V3JhcHBlZFN5bmNVSVN0YXRlQWN0aW9uIiwidWlTdGF0ZTIiLCJwYXRjaGVkQWlTdGF0ZSIsIlByb3ZpZGVyIiwidXNlVUlTdGF0ZSIsInN0YXRlIiwidXNlQ29udGV4dCIsIkFycmF5IiwiaXNBcnJheSIsInVzZUFJU3RhdGUiLCJsZW5ndGgiLCJzZXR0ZXIiLCJ1c2VDYWxsYmFjayIsIm5ld1N0YXRlIiwicyIsInVzZUFjdGlvbnMiLCJhY3Rpb25zIiwidXNlU3luY1VJU3RhdGUiLCJzeW5jVUlTdGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/rsc/dist/rsc-shared.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError),\n/* harmony export */   GenerateObjectResult: () => (/* binding */ GenerateObjectResult),\n/* harmony export */   GenerateTextResult: () => (/* binding */ GenerateTextResult),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoObjectGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError),\n/* harmony export */   NoSuchToolError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData),\n/* harmony export */   StreamObjectResult: () => (/* binding */ StreamObjectResult),\n/* harmony export */   StreamTextResult: () => (/* binding */ StreamTextResult),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   ToolCallParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.ToolCallParseError),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedFunctionalityError),\n/* harmony export */   UnsupportedJSONSchemaError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.UnsupportedJSONSchemaError),\n/* harmony export */   convertDataContentToBase64String: () => (/* binding */ convertDataContentToBase64String),\n/* harmony export */   convertDataContentToUint8Array: () => (/* binding */ convertDataContentToUint8Array),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_StreamingReactResponse: () => (/* binding */ experimental_StreamingReactResponse),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   formatStreamPart: () => (/* binding */ formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   isStreamStringEqualToType: () => (/* binding */ isStreamStringEqualToType),\n/* harmony export */   nanoid: () => (/* binding */ generateId),\n/* harmony export */   parseStreamPart: () => (/* binding */ parseStreamPart),\n/* harmony export */   readDataStream: () => (/* binding */ readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n// core/generate-object/generate-object.ts\n\n\n\n// core/generate-text/token-usage.ts\nfunction calculateTokenUsage(usage) {\n  return {\n    promptTokens: usage.promptTokens,\n    completionTokens: usage.completionTokens,\n    totalTokens: usage.promptTokens + usage.completionTokens\n  };\n}\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n  { mimeType: \"image/gif\", bytes: [71, 73, 70] },\n  { mimeType: \"image/png\", bytes: [137, 80, 78, 71] },\n  { mimeType: \"image/jpeg\", bytes: [255, 216] },\n  { mimeType: \"image/webp\", bytes: [82, 73, 70, 70] }\n];\nfunction detectImageMimeType(image) {\n  for (const { bytes, mimeType } of mimeTypeSignatures) {\n    if (image.length >= bytes.length && bytes.every((byte, index) => image[index] === byte)) {\n      return mimeType;\n    }\n  }\n  return void 0;\n}\n\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToBase64String(content) {\n  if (typeof content === \"string\") {\n    return content;\n  }\n  if (content instanceof ArrayBuffer) {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(new Uint8Array(content));\n  }\n  return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n  if (typeof content === \"string\") {\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.convertBase64ToUint8Array)(content);\n  }\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n  throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidDataContentError({ content });\n}\n\n// core/prompt/convert-to-language-model-prompt.ts\nfunction convertToLanguageModelPrompt(prompt) {\n  const languageModelMessages = [];\n  if (prompt.system != null) {\n    languageModelMessages.push({ role: \"system\", content: prompt.system });\n  }\n  switch (prompt.type) {\n    case \"prompt\": {\n      languageModelMessages.push({\n        role: \"user\",\n        content: [{ type: \"text\", text: prompt.prompt }]\n      });\n      break;\n    }\n    case \"messages\": {\n      languageModelMessages.push(\n        ...prompt.messages.map((message) => {\n          switch (message.role) {\n            case \"user\": {\n              if (typeof message.content === \"string\") {\n                return {\n                  role: \"user\",\n                  content: [{ type: \"text\", text: message.content }]\n                };\n              }\n              return {\n                role: \"user\",\n                content: message.content.map(\n                  (part) => {\n                    var _a;\n                    switch (part.type) {\n                      case \"text\": {\n                        return part;\n                      }\n                      case \"image\": {\n                        if (part.image instanceof URL) {\n                          return {\n                            type: \"image\",\n                            image: part.image,\n                            mimeType: part.mimeType\n                          };\n                        }\n                        const imageUint8 = convertDataContentToUint8Array(\n                          part.image\n                        );\n                        return {\n                          type: \"image\",\n                          image: imageUint8,\n                          mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                        };\n                      }\n                    }\n                  }\n                )\n              };\n            }\n            case \"assistant\": {\n              if (typeof message.content === \"string\") {\n                return {\n                  role: \"assistant\",\n                  content: [{ type: \"text\", text: message.content }]\n                };\n              }\n              return { role: \"assistant\", content: message.content };\n            }\n            case \"tool\": {\n              return message;\n            }\n          }\n        })\n      );\n      break;\n    }\n    default: {\n      const _exhaustiveCheck = prompt;\n      throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n    }\n  }\n  return languageModelMessages;\n}\n\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt or messages must be defined\"\n    });\n  }\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidPromptError({\n      prompt,\n      message: \"prompt and messages cannot be defined at the same time\"\n    });\n  }\n  return prompt.prompt != null ? {\n    type: \"prompt\",\n    prompt: prompt.prompt,\n    messages: void 0,\n    system: prompt.system\n  } : {\n    type: \"messages\",\n    prompt: void 0,\n    messages: prompt.messages,\n    // only possible case bc of checks above\n    system: prompt.system\n  };\n}\n\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({\n  maxTokens,\n  temperature,\n  topP,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  maxRetries\n}) {\n  if (maxTokens != null) {\n    if (!Number.isInteger(maxTokens)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be an integer\"\n      });\n    }\n    if (maxTokens < 1) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxTokens\",\n        value: maxTokens,\n        message: \"maxTokens must be >= 1\"\n      });\n    }\n  }\n  if (temperature != null) {\n    if (typeof temperature !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"temperature\",\n        value: temperature,\n        message: \"temperature must be a number\"\n      });\n    }\n  }\n  if (topP != null) {\n    if (typeof topP !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"topP\",\n        value: topP,\n        message: \"topP must be a number\"\n      });\n    }\n  }\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"presencePenalty\",\n        value: presencePenalty,\n        message: \"presencePenalty must be a number\"\n      });\n    }\n  }\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== \"number\") {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"frequencyPenalty\",\n        value: frequencyPenalty,\n        message: \"frequencyPenalty must be a number\"\n      });\n    }\n  }\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"seed\",\n        value: seed,\n        message: \"seed must be an integer\"\n      });\n    }\n  }\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be an integer\"\n      });\n    }\n    if (maxRetries < 0) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n        parameter: \"maxRetries\",\n        value: maxRetries,\n        message: \"maxRetries must be >= 0\"\n      });\n    }\n  }\n  return {\n    maxTokens,\n    temperature: temperature != null ? temperature : 0,\n    topP,\n    presencePenalty,\n    frequencyPenalty,\n    seed,\n    maxRetries: maxRetries != null ? maxRetries : 2\n  };\n}\n\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n  return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(zodSchema);\n}\n\n// core/util/retry-with-exponential-backoff.ts\n\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n  return new Promise((resolve) => setTimeout(resolve, delayInMs));\n}\n\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({\n  maxRetries = 2,\n  initialDelayInMs = 2e3,\n  backoffFactor = 2\n} = {}) => async (f) => _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs: initialDelayInMs,\n  backoffFactor\n});\nasync function _retryWithExponentialBackoff(f, {\n  maxRetries,\n  delayInMs,\n  backoffFactor\n}, errors = []) {\n  try {\n    return await f();\n  } catch (error) {\n    if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.isAbortError)(error)) {\n      throw error;\n    }\n    if (maxRetries === 0) {\n      throw error;\n    }\n    const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n    if (tryNumber > maxRetries) {\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: \"maxRetriesExceeded\",\n        errors: newErrors\n      });\n    }\n    if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n      await delay(delayInMs);\n      return _retryWithExponentialBackoff(\n        f,\n        { maxRetries, delayInMs: backoffFactor * delayInMs, backoffFactor },\n        newErrors\n      );\n    }\n    if (tryNumber === 1) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: \"errorNotRetryable\",\n      errors: newErrors\n    });\n  }\n}\n\n// core/generate-object/inject-json-schema-into-system.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nfunction injectJsonSchemaIntoSystem({\n  system,\n  schema,\n  schemaPrefix = DEFAULT_SCHEMA_PREFIX,\n  schemaSuffix = DEFAULT_SCHEMA_SUFFIX\n}) {\n  return [\n    system,\n    system != null ? \"\" : null,\n    // add a newline if system is not null\n    schemaPrefix,\n    JSON.stringify(schema),\n    schemaSuffix\n  ].filter((line) => line != null).join(\"\\n\");\n}\n\n// core/generate-object/generate-object.ts\nasync function generateObject({\n  model,\n  schema,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  var _a, _b;\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const jsonSchema = convertZodToJSONSchema(schema);\n  if (mode === \"auto\" || mode == null) {\n    mode = model.defaultObjectGenerationMode;\n  }\n  let result;\n  let finishReason;\n  let usage;\n  let warnings;\n  let rawResponse;\n  let logprobs;\n  switch (mode) {\n    case \"json\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      const generateResult = await retry(() => {\n        return model.doGenerate({\n          mode: { type: \"object-json\" },\n          ...prepareCallSettings(settings),\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        });\n      });\n      if (generateResult.text === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = generateResult.text;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case \"grammar\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      const generateResult = await retry(\n        () => model.doGenerate({\n          mode: { type: \"object-grammar\", schema: jsonSchema },\n          ...settings,\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        })\n      );\n      if (generateResult.text === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = generateResult.text;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case \"tool\": {\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      const generateResult = await retry(\n        () => model.doGenerate({\n          mode: {\n            type: \"object-tool\",\n            tool: {\n              type: \"function\",\n              name: \"json\",\n              description: \"Respond with a JSON object.\",\n              parameters: jsonSchema\n            }\n          },\n          ...settings,\n          inputFormat: validatedPrompt.type,\n          prompt: convertToLanguageModelPrompt(validatedPrompt),\n          abortSignal\n        })\n      );\n      const functionArgs = (_b = (_a = generateResult.toolCalls) == null ? void 0 : _a[0]) == null ? void 0 : _b.args;\n      if (functionArgs === void 0) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoObjectGeneratedError();\n      }\n      result = functionArgs;\n      finishReason = generateResult.finishReason;\n      usage = generateResult.usage;\n      warnings = generateResult.warnings;\n      rawResponse = generateResult.rawResponse;\n      logprobs = generateResult.logprobs;\n      break;\n    }\n    case void 0: {\n      throw new Error(\"Model does not have a default object generation mode.\");\n    }\n    default: {\n      const _exhaustiveCheck = mode;\n      throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n    }\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({ text: result, schema });\n  if (!parseResult.success) {\n    throw parseResult.error;\n  }\n  return new GenerateObjectResult({\n    object: parseResult.value,\n    finishReason,\n    usage: calculateTokenUsage(usage),\n    warnings,\n    rawResponse,\n    logprobs\n  });\n}\nvar GenerateObjectResult = class {\n  constructor(options) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n  }\n};\nvar experimental_generateObject = generateObject;\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n  const transformedStream = source.pipeThrough(\n    new TransformStream(transformer)\n  );\n  transformedStream[Symbol.asyncIterator] = () => {\n    const reader = transformedStream.getReader();\n    return {\n      async next() {\n        const { done, value } = await reader.read();\n        return done ? { done: true, value: void 0 } : { done: false, value };\n      }\n    };\n  };\n  return transformedStream;\n}\n\n// core/util/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// core/util/parse-partial-json.ts\n\n\n// core/util/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// core/util/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText == null) {\n    return void 0;\n  }\n  try {\n    return secure_json_parse__WEBPACK_IMPORTED_MODULE_3__.parse(jsonText);\n  } catch (ignored) {\n    try {\n      const fixedJsonText = fixJson(jsonText);\n      return secure_json_parse__WEBPACK_IMPORTED_MODULE_3__.parse(fixedJsonText);\n    } catch (ignored2) {\n    }\n  }\n  return void 0;\n}\n\n// core/generate-object/stream-object.ts\nasync function streamObject({\n  model,\n  schema,\n  mode,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const jsonSchema = convertZodToJSONSchema(schema);\n  if (mode === \"auto\" || mode == null) {\n    mode = model.defaultObjectGenerationMode;\n  }\n  let callOptions;\n  let transformer;\n  switch (mode) {\n    case \"json\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: { type: \"object-json\" },\n        ...prepareCallSettings(settings),\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform: (chunk, controller) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case \"grammar\": {\n      const validatedPrompt = getValidatedPrompt({\n        system: injectJsonSchemaIntoSystem({ system, schema: jsonSchema }),\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: { type: \"object-grammar\", schema: jsonSchema },\n        ...settings,\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform: (chunk, controller) => {\n          switch (chunk.type) {\n            case \"text-delta\":\n              controller.enqueue(chunk.textDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case \"tool\": {\n      const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n      });\n      callOptions = {\n        mode: {\n          type: \"object-tool\",\n          tool: {\n            type: \"function\",\n            name: \"json\",\n            description: \"Respond with a JSON object.\",\n            parameters: jsonSchema\n          }\n        },\n        ...settings,\n        inputFormat: validatedPrompt.type,\n        prompt: convertToLanguageModelPrompt(validatedPrompt),\n        abortSignal\n      };\n      transformer = {\n        transform(chunk, controller) {\n          switch (chunk.type) {\n            case \"tool-call-delta\":\n              controller.enqueue(chunk.argsTextDelta);\n              break;\n            case \"finish\":\n            case \"error\":\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      };\n      break;\n    }\n    case void 0: {\n      throw new Error(\"Model does not have a default object generation mode.\");\n    }\n    default: {\n      const _exhaustiveCheck = mode;\n      throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n    }\n  }\n  const result = await retry(() => model.doStream(callOptions));\n  return new StreamObjectResult({\n    stream: result.stream.pipeThrough(new TransformStream(transformer)),\n    warnings: result.warnings,\n    rawResponse: result.rawResponse\n  });\n}\nvar StreamObjectResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse\n  }) {\n    this.originalStream = stream;\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n  }\n  get partialObjectStream() {\n    let accumulatedText = \"\";\n    let latestObject = void 0;\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (typeof chunk === \"string\") {\n          accumulatedText += chunk;\n          const currentObject = parsePartialJson(\n            accumulatedText\n          );\n          if (!isDeepEqualData(latestObject, currentObject)) {\n            latestObject = currentObject;\n            controller.enqueue(currentObject);\n          }\n        } else if (chunk.type === \"error\") {\n          throw chunk.error;\n        }\n      }\n    });\n  }\n  get fullStream() {\n    let accumulatedText = \"\";\n    let latestObject = void 0;\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (typeof chunk === \"string\") {\n          accumulatedText += chunk;\n          const currentObject = parsePartialJson(\n            accumulatedText\n          );\n          if (!isDeepEqualData(latestObject, currentObject)) {\n            latestObject = currentObject;\n            controller.enqueue({ type: \"object\", object: currentObject });\n          }\n        } else {\n          switch (chunk.type) {\n            case \"finish\":\n              controller.enqueue({\n                ...chunk,\n                usage: calculateTokenUsage(chunk.usage)\n              });\n              break;\n            default:\n              controller.enqueue(chunk);\n              break;\n          }\n        }\n      }\n    });\n  }\n};\nvar experimental_streamObject = streamObject;\n\n// core/generate-text/tool-call.ts\n\n\nfunction parseToolCall({\n  toolCall,\n  tools\n}) {\n  const toolName = toolCall.toolName;\n  if (tools == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({ toolName: toolCall.toolName });\n  }\n  const tool2 = tools[toolName];\n  if (tool2 == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools)\n    });\n  }\n  const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_0__.safeParseJSON)({\n    text: toolCall.args,\n    schema: tool2.parameters\n  });\n  if (parseResult.success === false) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidToolArgumentsError({\n      toolName,\n      toolArgs: toolCall.args,\n      cause: parseResult.error\n    });\n  }\n  return {\n    type: \"tool-call\",\n    toolCallId: toolCall.toolCallId,\n    toolName,\n    args: parseResult.value\n  };\n}\n\n// core/generate-text/generate-text.ts\nasync function generateText({\n  model,\n  tools,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  var _a, _b;\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n  const modelResponse = await retry(() => {\n    return model.doGenerate({\n      mode: {\n        type: \"regular\",\n        tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool2]) => ({\n          type: \"function\",\n          name,\n          description: tool2.description,\n          parameters: convertZodToJSONSchema(tool2.parameters)\n        }))\n      },\n      ...prepareCallSettings(settings),\n      inputFormat: validatedPrompt.type,\n      prompt: convertToLanguageModelPrompt(validatedPrompt),\n      abortSignal\n    });\n  });\n  const toolCalls = [];\n  for (const modelToolCall of (_a = modelResponse.toolCalls) != null ? _a : []) {\n    toolCalls.push(parseToolCall({ toolCall: modelToolCall, tools }));\n  }\n  const toolResults = tools == null ? [] : await executeTools({ toolCalls, tools });\n  return new GenerateTextResult({\n    // Always return a string so that the caller doesn't have to check for undefined.\n    // If they need to check if the model did not return any text,\n    // they can check the length of the string:\n    text: (_b = modelResponse.text) != null ? _b : \"\",\n    toolCalls,\n    toolResults,\n    finishReason: modelResponse.finishReason,\n    usage: calculateTokenUsage(modelResponse.usage),\n    warnings: modelResponse.warnings,\n    rawResponse: modelResponse.rawResponse,\n    logprobs: modelResponse.logprobs\n  });\n}\nasync function executeTools({\n  toolCalls,\n  tools\n}) {\n  const toolResults = await Promise.all(\n    toolCalls.map(async (toolCall) => {\n      const tool2 = tools[toolCall.toolName];\n      if ((tool2 == null ? void 0 : tool2.execute) == null) {\n        return void 0;\n      }\n      const result = await tool2.execute(toolCall.args);\n      return {\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        args: toolCall.args,\n        result\n      };\n    })\n  );\n  return toolResults.filter(\n    (result) => result != null\n  );\n}\nvar GenerateTextResult = class {\n  constructor(options) {\n    this.text = options.text;\n    this.toolCalls = options.toolCalls;\n    this.toolResults = options.toolResults;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.rawResponse = options.rawResponse;\n    this.logprobs = options.logprobs;\n  }\n};\nvar experimental_generateText = generateText;\n\n// core/generate-text/run-tools-transformation.ts\n\n\n// shared/generate-id.ts\n\nvar generateId = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_4__.customAlphabet)(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\n\n// core/generate-text/run-tools-transformation.ts\nfunction runToolsTransformation({\n  tools,\n  generatorStream\n}) {\n  let canClose = false;\n  const outstandingToolCalls = /* @__PURE__ */ new Set();\n  let toolResultsStreamController = null;\n  const toolResultsStream = new ReadableStream({\n    start(controller) {\n      toolResultsStreamController = controller;\n    }\n  });\n  const forwardStream = new TransformStream({\n    transform(chunk, controller) {\n      const chunkType = chunk.type;\n      switch (chunkType) {\n        case \"text-delta\":\n        case \"error\": {\n          controller.enqueue(chunk);\n          break;\n        }\n        case \"tool-call\": {\n          const toolName = chunk.toolName;\n          if (tools == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({ toolName: chunk.toolName })\n            });\n            break;\n          }\n          const tool2 = tools[toolName];\n          if (tool2 == null) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.NoSuchToolError({\n                toolName: chunk.toolName,\n                availableTools: Object.keys(tools)\n              })\n            });\n            break;\n          }\n          try {\n            const toolCall = parseToolCall({\n              toolCall: chunk,\n              tools\n            });\n            controller.enqueue(toolCall);\n            if (tool2.execute != null) {\n              const toolExecutionId = generateId();\n              outstandingToolCalls.add(toolExecutionId);\n              tool2.execute(toolCall.args).then(\n                (result) => {\n                  toolResultsStreamController.enqueue({\n                    ...toolCall,\n                    type: \"tool-result\",\n                    result\n                  });\n                  outstandingToolCalls.delete(toolExecutionId);\n                  if (canClose && outstandingToolCalls.size === 0) {\n                    toolResultsStreamController.close();\n                  }\n                },\n                (error) => {\n                  toolResultsStreamController.enqueue({\n                    type: \"error\",\n                    error\n                  });\n                  outstandingToolCalls.delete(toolExecutionId);\n                  if (canClose && outstandingToolCalls.size === 0) {\n                    toolResultsStreamController.close();\n                  }\n                }\n              );\n            }\n          } catch (error) {\n            toolResultsStreamController.enqueue({\n              type: \"error\",\n              error\n            });\n          }\n          break;\n        }\n        case \"finish\": {\n          controller.enqueue({\n            type: \"finish\",\n            finishReason: chunk.finishReason,\n            logprobs: chunk.logprobs,\n            usage: calculateTokenUsage(chunk.usage)\n          });\n          break;\n        }\n        case \"tool-call-delta\": {\n          break;\n        }\n        default: {\n          const _exhaustiveCheck = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n    flush() {\n      canClose = true;\n      if (outstandingToolCalls.size === 0) {\n        toolResultsStreamController.close();\n      }\n    }\n  });\n  return new ReadableStream({\n    async start(controller) {\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n            }\n          })\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            }\n          })\n        )\n      ]);\n    }\n  });\n}\n\n// core/generate-text/stream-text.ts\nasync function streamText({\n  model,\n  tools,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  ...settings\n}) {\n  const retry = retryWithExponentialBackoff({ maxRetries });\n  const validatedPrompt = getValidatedPrompt({ system, prompt, messages });\n  const { stream, warnings, rawResponse } = await retry(\n    () => model.doStream({\n      mode: {\n        type: \"regular\",\n        tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool2]) => ({\n          type: \"function\",\n          name,\n          description: tool2.description,\n          parameters: convertZodToJSONSchema(tool2.parameters)\n        }))\n      },\n      ...prepareCallSettings(settings),\n      inputFormat: validatedPrompt.type,\n      prompt: convertToLanguageModelPrompt(validatedPrompt),\n      abortSignal\n    })\n  );\n  return new StreamTextResult({\n    stream: runToolsTransformation({\n      tools,\n      generatorStream: stream\n    }),\n    warnings,\n    rawResponse\n  });\n}\nvar StreamTextResult = class {\n  constructor({\n    stream,\n    warnings,\n    rawResponse\n  }) {\n    this.originalStream = stream;\n    this.warnings = warnings;\n    this.rawResponse = rawResponse;\n  }\n  /**\n  A text stream that returns only the generated text deltas. You can use it\n  as either an AsyncIterable or a ReadableStream. When an error occurs, the\n  stream will throw the error.\n     */\n  get textStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk.textDelta);\n          }\n        } else if (chunk.type === \"error\") {\n          throw chunk.error;\n        }\n      }\n    });\n  }\n  /**\n  A stream with all events, including text deltas, tool calls, tool results, and\n  errors.\n  You can use it as either an AsyncIterable or a ReadableStream. When an error occurs, the\n  stream will throw the error.\n     */\n  get fullStream() {\n    return createAsyncIterableStream(this.originalStream, {\n      transform(chunk, controller) {\n        if (chunk.type === \"text-delta\") {\n          if (chunk.textDelta.length > 0) {\n            controller.enqueue(chunk);\n          }\n        } else {\n          controller.enqueue(chunk);\n        }\n      }\n    });\n  }\n  /**\n  Converts the result to an `AIStream` object that is compatible with `StreamingTextResponse`.\n  It can be used with the `useChat` and `useCompletion` hooks.\n  \n  @param callbacks \n  Stream callbacks that will be called when the stream emits events.\n  \n  @returns an `AIStream` object.\n     */\n  toAIStream(callbacks) {\n    return this.textStream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n  /**\n  Writes stream data output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each stream data part as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeAIStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.pipeThrough(createCallbacksTransformer(void 0)).pipeThrough(createStreamDataTransformer()).getReader();\n    const read = async () => {\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(value);\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Writes text delta output to a Node.js response-like object.\n  It sets a `Content-Type` header to `text/plain; charset=utf-8` and \n  writes each text delta as a separate chunk.\n  \n  @param response A Node.js response-like object (ServerResponse).\n  @param init Optional headers and status code.\n     */\n  pipeTextStreamToResponse(response, init) {\n    var _a;\n    response.writeHead((_a = init == null ? void 0 : init.status) != null ? _a : 200, {\n      \"Content-Type\": \"text/plain; charset=utf-8\",\n      ...init == null ? void 0 : init.headers\n    });\n    const reader = this.textStream.getReader();\n    const read = async () => {\n      const encoder = new TextEncoder();\n      try {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done)\n            break;\n          response.write(encoder.encode(value));\n        }\n      } catch (error) {\n        throw error;\n      } finally {\n        response.end();\n      }\n    };\n    read();\n  }\n  /**\n  Converts the result to a streamed response object with a stream data part stream.\n  It can be used with the `useChat` and `useCompletion` hooks.\n  \n  @param init Optional headers.\n  \n  @return A response object.\n     */\n  toAIStreamResponse(init) {\n    return new StreamingTextResponse(this.toAIStream(), init);\n  }\n  /**\n  Creates a simple text stream response.\n  Each text delta is encoded as UTF-8 and sent as a separate chunk.\n  Non-text-delta events are ignored.\n  \n  @param init Optional headers and status code.\n     */\n  toTextStreamResponse(init) {\n    var _a;\n    const encoder = new TextEncoder();\n    return new Response(\n      this.textStream.pipeThrough(\n        new TransformStream({\n          transform(chunk, controller) {\n            controller.enqueue(encoder.encode(chunk));\n          }\n        })\n      ),\n      {\n        status: (_a = init == null ? void 0 : init.status) != null ? _a : 200,\n        headers: {\n          \"Content-Type\": \"text/plain; charset=utf-8\",\n          ...init == null ? void 0 : init.headers\n        }\n      }\n    );\n  }\n};\nvar experimental_streamText = streamText;\n\n// core/tool/tool.ts\nfunction tool(tool2) {\n  return tool2;\n}\n\n// core/types/errors.ts\n\n\n// shared/stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar functionCallStreamPart = {\n  code: \"1\",\n  name: \"function_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n      throw new Error(\n        '\"function_call\" parts expect an object with a \"function_call\" property.'\n      );\n    }\n    return {\n      type: \"function_call\",\n      value\n    };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.'\n      );\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"7\",\n  name: \"tool_calls\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some(\n      (tc) => tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\"\n    )) {\n      throw new Error(\n        '\"tool_calls\" parts expect an object with a ToolCallPayload.'\n      );\n    }\n    return {\n      type: \"tool_calls\",\n      value\n    };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return { type: \"message_annotations\", value };\n  }\n};\nvar streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n  toolCallStreamPart,\n  messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n  [toolCallStreamPart.code]: toolCallStreamPart,\n  [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n  [toolCallStreamPart.name]: toolCallStreamPart.code,\n  [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part) => part.code);\nvar parseStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n  const streamPart = streamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// shared/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function* readDataStream(reader, {\n  isAborted\n} = {}) {\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts2 = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseStreamPart);\n    for (const streamPart of streamParts2) {\n      yield streamPart;\n    }\n    if (isAborted == null ? void 0 : isAborted()) {\n      reader.cancel();\n      break;\n    }\n  }\n}\n\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n  const decoder = new TextDecoder();\n  if (!complex) {\n    return function(chunk) {\n      if (!chunk)\n        return \"\";\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n  return function(chunk) {\n    const decoded = decoder.decode(chunk, { stream: true }).split(\"\\n\").filter((line) => line !== \"\");\n    return decoded.map(parseStreamPart).filter(Boolean);\n  };\n}\nvar isStreamStringEqualToType = (type, value) => value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\n\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_5__.createParser)(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data, {\n              event: event.event\n            }) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      const content = typeof message === \"string\" ? message : message.content;\n      controller.enqueue(textEncoder.encode(content));\n      aggregatedResponse += content;\n      if (callbacks.onToken)\n        await callbacks.onToken(content);\n      if (callbacks.onText && typeof message === \"string\") {\n        await callbacks.onText(message);\n      }\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a;\n      await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n    }\n  });\n}\n\n// streams/stream-data.ts\nvar StreamData = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    // closing the stream is synchronous, but we want to return a promise\n    // in case we're doing async work\n    this.isClosedPromise = null;\n    this.isClosedPromiseResolver = void 0;\n    this.isClosed = false;\n    // array to store appended data\n    this.data = [];\n    this.messageAnnotations = [];\n    this.isClosedPromise = new Promise((resolve) => {\n      this.isClosedPromiseResolver = resolve;\n    });\n    const self = this;\n    this.stream = new TransformStream({\n      start: async (controller) => {\n        self.controller = controller;\n      },\n      transform: async (chunk, controller) => {\n        if (self.data.length > 0) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"data\", self.data)\n          );\n          self.data = [];\n          controller.enqueue(encodedData);\n        }\n        if (self.messageAnnotations.length) {\n          const encodedMessageAnnotations = self.encoder.encode(\n            formatStreamPart(\"message_annotations\", self.messageAnnotations)\n          );\n          self.messageAnnotations = [];\n          controller.enqueue(encodedMessageAnnotations);\n        }\n        controller.enqueue(chunk);\n      },\n      async flush(controller) {\n        const warningTimeout =  true ? setTimeout(() => {\n          console.warn(\n            \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n          );\n        }, 3e3) : 0;\n        await self.isClosedPromise;\n        if (warningTimeout !== null) {\n          clearTimeout(warningTimeout);\n        }\n        if (self.data.length) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"data\", self.data)\n          );\n          controller.enqueue(encodedData);\n        }\n        if (self.messageAnnotations.length) {\n          const encodedData = self.encoder.encode(\n            formatStreamPart(\"message_annotations\", self.messageAnnotations)\n          );\n          controller.enqueue(encodedData);\n        }\n      }\n    });\n  }\n  async close() {\n    var _a;\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    (_a = this.isClosedPromiseResolver) == null ? void 0 : _a.call(this);\n    this.isClosed = true;\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    this.data.push(value);\n  }\n  appendMessageAnnotation(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    this.messageAnnotations.push(value);\n  }\n};\nfunction createStreamDataTransformer() {\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n    }\n  });\n}\nvar experimental_StreamData = class extends StreamData {\n};\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable(stream) {\n  for await (const chunk of stream) {\n    if (\"completion\" in chunk) {\n      const text = chunk.completion;\n      if (text)\n        yield text;\n    } else if (\"delta\" in chunk) {\n      const { delta } = chunk;\n      if (\"text\" in delta) {\n        const text = delta.text;\n        if (text)\n          yield text;\n      }\n    }\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer()\n    );\n  }\n}\n\n// streams/assistant-response.ts\nfunction AssistantResponse({ threadId, messageId }, process2) {\n  const stream = new ReadableStream({\n    async start(controller) {\n      var _a;\n      const textEncoder = new TextEncoder();\n      const sendMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"assistant_message\", message))\n        );\n      };\n      const sendDataMessage = (message) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"data_message\", message))\n        );\n      };\n      const sendError = (errorMessage) => {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"error\", errorMessage))\n        );\n      };\n      const forwardStream = async (stream2) => {\n        var _a2, _b;\n        let result = void 0;\n        for await (const value of stream2) {\n          switch (value.event) {\n            case \"thread.message.created\": {\n              controller.enqueue(\n                textEncoder.encode(\n                  formatStreamPart(\"assistant_message\", {\n                    id: value.data.id,\n                    role: \"assistant\",\n                    content: [{ type: \"text\", text: { value: \"\" } }]\n                  })\n                )\n              );\n              break;\n            }\n            case \"thread.message.delta\": {\n              const content = (_a2 = value.data.delta.content) == null ? void 0 : _a2[0];\n              if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                controller.enqueue(\n                  textEncoder.encode(\n                    formatStreamPart(\"text\", content.text.value)\n                  )\n                );\n              }\n              break;\n            }\n            case \"thread.run.completed\":\n            case \"thread.run.requires_action\": {\n              result = value.data;\n              break;\n            }\n          }\n        }\n        return result;\n      };\n      controller.enqueue(\n        textEncoder.encode(\n          formatStreamPart(\"assistant_control_data\", {\n            threadId,\n            messageId\n          })\n        )\n      );\n      try {\n        await process2({\n          threadId,\n          messageId,\n          sendMessage,\n          sendDataMessage,\n          forwardStream\n        });\n      } catch (error) {\n        sendError((_a = error.message) != null ? _a : `${error}`);\n      } finally {\n        controller.close();\n      }\n    },\n    pull(controller) {\n    },\n    cancel() {\n    }\n  });\n  return new Response(stream, {\n    status: 200,\n    headers: {\n      \"Content-Type\": \"text/plain; charset=utf-8\"\n    }\n  });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n  var _a, _b;\n  const decoder = new TextDecoder();\n  for await (const chunk of (_a = response.body) != null ? _a : []) {\n    const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n    if (bytes != null) {\n      const chunkText = decoder.decode(bytes);\n      const chunkJSON = JSON.parse(chunkText);\n      const delta = extractTextDeltaFromChunk(chunkJSON);\n      if (delta != null) {\n        yield delta;\n      }\n    }\n  }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => {\n    var _a;\n    return (_a = chunk.delta) == null ? void 0 : _a.text;\n  });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n  return AWSBedrockStream(response, callbacks, (chunk) => chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n  return readableFromAsyncIterable(\n    asDeltaIterable(response, extractTextDeltaFromChunk)\n  ).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (!is_finished) {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser2(res) {\n  var _a;\n  const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    if (chunk.eventType === \"text-generation\") {\n      const text = chunk.text;\n      if (text)\n        yield text;\n    }\n  }\n}\nfunction CohereStream(reader, callbacks) {\n  if (Symbol.asyncIterator in reader) {\n    return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  } else {\n    return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n  }\n}\n\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n  var _a, _b, _c;\n  for await (const chunk of response.stream) {\n    const parts = (_c = (_b = (_a = chunk.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n    if (parts === void 0) {\n      continue;\n    }\n    const firstPart = parts[0];\n    if (typeof firstPart.text === \"string\") {\n      yield firstPart.text;\n    }\n  }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n  return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        return;\n      }\n      controller.enqueue(text);\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n  if (!res.body) {\n    throw new Error(\"Response body is null\");\n  }\n  let chat_session_id = \"\";\n  let records_cited;\n  const inkeepEventParser = (data, options) => {\n    var _a, _b;\n    const { event } = options;\n    if (event === \"records_cited\") {\n      records_cited = JSON.parse(data);\n      (_a = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a.call(callbacks, records_cited);\n    }\n    if (event === \"message_chunk\") {\n      const inkeepMessageChunk = JSON.parse(data);\n      chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n      return inkeepMessageChunk.content_chunk;\n    }\n    return;\n  };\n  let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n  passThroughCallbacks = {\n    ...passThroughCallbacks,\n    onFinal: (completion) => {\n      var _a;\n      const inkeepOnFinalMetadata = {\n        chat_session_id,\n        records_cited\n      };\n      (_a = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a.call(callbacks, completion, inkeepOnFinalMetadata);\n    }\n  };\n  return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n  var _a, _b;\n  for await (const chunk of stream) {\n    const content = (_b = (_a = chunk.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.content;\n    if (content === void 0 || content === \"\") {\n      continue;\n    }\n    yield content;\n  }\n}\nfunction MistralStream(response, callbacks) {\n  const stream = readableFromAsyncIterable(streamable4(response));\n  return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n  const extract = chunkToText();\n  for await (let chunk of stream) {\n    if (\"promptFilterResults\" in chunk) {\n      chunk = {\n        id: chunk.id,\n        created: chunk.created.getDate(),\n        object: chunk.object,\n        // not exposed by Azure API\n        model: chunk.model,\n        // not exposed by Azure API\n        choices: chunk.choices.map((choice) => {\n          var _a, _b, _c, _d, _e, _f, _g;\n          return {\n            delta: {\n              content: (_a = choice.delta) == null ? void 0 : _a.content,\n              function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n              role: (_c = choice.delta) == null ? void 0 : _c.role,\n              tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index) => ({\n                index,\n                id: toolCall.id,\n                function: toolCall.function,\n                type: toolCall.type\n              })) : void 0\n            },\n            finish_reason: choice.finishReason,\n            index: choice.index\n          };\n        })\n      };\n    }\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n    if (isChatCompletionChunk(json)) {\n      const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n      if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n        isFunctionStreamingIn = true;\n        return {\n          isText: false,\n          content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n        };\n      } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n        isFunctionStreamingIn = true;\n        const toolCall = delta.tool_calls[0];\n        if (toolCall.index === 0) {\n          return {\n            isText: false,\n            content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n          };\n        } else {\n          return {\n            isText: false,\n            content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n          };\n        }\n      } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n        };\n      } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n        return {\n          isText: false,\n          content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n        };\n      } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}'\n        };\n      } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n        isFunctionStreamingIn = false;\n        return {\n          isText: false,\n          content: '\"}}]}'\n        };\n      }\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n  function cleanupArguments(argumentChunk) {\n    let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n    return `${escapedPartialJson}`;\n  }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(createStreamDataTransformer());\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const decode = createChunkDecoder();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          textEncoder.encode(formatStreamPart(\"text\", message))\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          let functionResponse = void 0;\n          if (callbacks.experimental_onFunctionCall) {\n            if (payload.function_call === void 0) {\n              console.warn(\n                \"experimental_onFunctionCall should not be defined when using tools\"\n              );\n            }\n            const argumentsPayload = JSON.parse(\n              payload.function_call.arguments\n            );\n            functionResponse = await callbacks.experimental_onFunctionCall(\n              {\n                name: payload.function_call.name,\n                arguments: argumentsPayload\n              },\n              (result) => {\n                newFunctionCallMessages = [\n                  ...functionCallMessages,\n                  {\n                    role: \"assistant\",\n                    content: \"\",\n                    function_call: payload.function_call\n                  },\n                  {\n                    role: \"function\",\n                    name: payload.function_call.name,\n                    content: JSON.stringify(result)\n                  }\n                ];\n                return newFunctionCallMessages;\n              }\n            );\n          }\n          if (callbacks.experimental_onToolCall) {\n            const toolCalls = {\n              tools: []\n            };\n            for (const tool2 of payload.tool_calls) {\n              toolCalls.tools.push({\n                id: tool2.id,\n                type: \"function\",\n                func: {\n                  name: tool2.function.name,\n                  arguments: JSON.parse(tool2.function.arguments)\n                }\n              });\n            }\n            let responseIndex = 0;\n            try {\n              functionResponse = await callbacks.experimental_onToolCall(\n                toolCalls,\n                (result) => {\n                  if (result) {\n                    const { tool_call_id, function_name, tool_call_result } = result;\n                    newFunctionCallMessages = [\n                      ...newFunctionCallMessages,\n                      // Only append the assistant message if it's the first response\n                      ...responseIndex === 0 ? [\n                        {\n                          role: \"assistant\",\n                          content: \"\",\n                          tool_calls: payload.tool_calls.map(\n                            (tc) => ({\n                              id: tc.id,\n                              type: \"function\",\n                              function: {\n                                name: tc.function.name,\n                                // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                arguments: JSON.stringify(\n                                  tc.function.arguments\n                                )\n                              }\n                            })\n                          )\n                        }\n                      ] : [],\n                      // Append the function call result message\n                      {\n                        role: \"tool\",\n                        tool_call_id,\n                        name: function_name,\n                        content: JSON.stringify(tool_call_result)\n                      }\n                    ];\n                    responseIndex++;\n                  }\n                  return newFunctionCallMessages;\n                }\n              );\n            } catch (e) {\n              console.error(\"Error calling experimental_onToolCall:\", e);\n            }\n          }\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                formatStreamPart(\n                  payload.function_call ? \"function_call\" : \"tool_calls\",\n                  // parse to prevent double-encoding:\n                  JSON.parse(aggregatedResponse)\n                )\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              textEncoder.encode(formatStreamPart(\"text\", functionResponse))\n            );\n            aggregatedFinalCompletionResponse = functionResponse;\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n  var _a;\n  const url = (_a = res.urls) == null ? void 0 : _a.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\",\n      ...options == null ? void 0 : options.headers\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer()\n  );\n}\n\n// shared/parse-complex-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n  if (!message || !annotations || !annotations.length)\n    return message;\n  return { ...message, annotations: [...annotations] };\n}\nasync function parseComplexResponse({\n  reader,\n  abortControllerRef,\n  update,\n  onFinish,\n  generateId: generateId2 = generateId,\n  getCurrentDate = () => /* @__PURE__ */ new Date()\n}) {\n  const createdAt = getCurrentDate();\n  const prefixMap = {\n    data: []\n  };\n  let message_annotations = void 0;\n  for await (const { type, value } of readDataStream(reader, {\n    isAborted: () => (abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n  })) {\n    if (type === \"text\") {\n      if (prefixMap[\"text\"]) {\n        prefixMap[\"text\"] = {\n          ...prefixMap[\"text\"],\n          content: (prefixMap[\"text\"].content || \"\") + value\n        };\n      } else {\n        prefixMap[\"text\"] = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: value,\n          createdAt\n        };\n      }\n    }\n    let functionCallMessage = null;\n    if (type === \"function_call\") {\n      prefixMap[\"function_call\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        function_call: value.function_call,\n        name: value.function_call.name,\n        createdAt\n      };\n      functionCallMessage = prefixMap[\"function_call\"];\n    }\n    let toolCallMessage = null;\n    if (type === \"tool_calls\") {\n      prefixMap[\"tool_calls\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        tool_calls: value.tool_calls,\n        createdAt\n      };\n      toolCallMessage = prefixMap[\"tool_calls\"];\n    }\n    if (type === \"data\") {\n      prefixMap[\"data\"].push(...value);\n    }\n    let responseMessage = prefixMap[\"text\"];\n    if (type === \"message_annotations\") {\n      if (!message_annotations) {\n        message_annotations = [...value];\n      } else {\n        message_annotations.push(...value);\n      }\n      functionCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"function_call\"],\n        message_annotations\n      );\n      toolCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"tool_calls\"],\n        message_annotations\n      );\n      responseMessage = assignAnnotationsToMessage(\n        prefixMap[\"text\"],\n        message_annotations\n      );\n    }\n    if (message_annotations == null ? void 0 : message_annotations.length) {\n      const messagePrefixKeys = [\n        \"text\",\n        \"function_call\",\n        \"tool_calls\"\n      ];\n      messagePrefixKeys.forEach((key) => {\n        if (prefixMap[key]) {\n          prefixMap[key].annotations = [...message_annotations];\n        }\n      });\n    }\n    const merged = [functionCallMessage, toolCallMessage, responseMessage].filter(Boolean).map((message) => ({\n      ...assignAnnotationsToMessage(message, message_annotations)\n    }));\n    update(merged, [...prefixMap[\"data\"]]);\n  }\n  onFinish == null ? void 0 : onFinish(prefixMap);\n  return {\n    messages: [\n      prefixMap.text,\n      prefixMap.function_call,\n      prefixMap.tool_calls\n    ].filter(Boolean),\n    data: prefixMap.data\n  };\n}\n\n// streams/streaming-react-response.ts\nvar experimental_StreamingReactResponse = class {\n  constructor(res, options) {\n    var _a, _b;\n    let resolveFunc = () => {\n    };\n    let next = new Promise((resolve) => {\n      resolveFunc = resolve;\n    });\n    const processedStream = (options == null ? void 0 : options.data) != null ? res.pipeThrough((_a = options == null ? void 0 : options.data) == null ? void 0 : _a.stream) : res;\n    let lastPayload = void 0;\n    parseComplexResponse({\n      reader: processedStream.getReader(),\n      update: (merged, data) => {\n        var _a2, _b2, _c;\n        const content = (_b2 = (_a2 = merged[0]) == null ? void 0 : _a2.content) != null ? _b2 : \"\";\n        const ui = ((_c = options == null ? void 0 : options.ui) == null ? void 0 : _c.call(options, { content, data })) || content;\n        const payload = { ui, content };\n        const resolvePrevious = resolveFunc;\n        const nextRow = new Promise((resolve) => {\n          resolveFunc = resolve;\n        });\n        resolvePrevious({\n          next: nextRow,\n          ...payload\n        });\n        lastPayload = payload;\n      },\n      generateId: (_b = options == null ? void 0 : options.generateId) != null ? _b : generateId,\n      onFinish: () => {\n        if (lastPayload !== void 0) {\n          resolveFunc({\n            next: null,\n            ...lastPayload\n          });\n        }\n      }\n    });\n    return next;\n  }\n};\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = res.pipeThrough(data.stream);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n      }\n    });\n  }\n};\nfunction streamToResponse(res, response, init) {\n  response.writeHead((init == null ? void 0 : init.status) || 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  const reader = res.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUMwRDtBQUNIOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJLDRDQUE0QztBQUNoRCxJQUFJLGlEQUFpRDtBQUNyRCxJQUFJLDJDQUEyQztBQUMvQyxJQUFJO0FBQ0o7QUFDQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyRDtBQUkzQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpRkFBeUI7QUFDcEM7QUFDQSxTQUFTLGlGQUF5QjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlGQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscUVBQXVCLEdBQUcsU0FBUztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx3Q0FBd0M7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQ0FBbUM7QUFDdkQsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHFDQUFxQztBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixxQ0FBcUM7QUFDbkU7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QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUMyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQWtCMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxPQUFPO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REO0FBQ0EsWUFBWSxnQkFBZ0IsR0FBRztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLElBQUk7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsY0FBYztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsY0FBYztBQUNu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O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBMEM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsZUFBZTtBQUN0SCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBbUVFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AZGV2aWFzLWtpdC1wcm8vbmV4dGpzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzPzk4YmUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvZ2VuZXJhdGUtb2JqZWN0LnRzXG5pbXBvcnQgeyBOb09iamVjdEdlbmVyYXRlZEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVQYXJzZUpTT04gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvdG9rZW4tdXNhZ2UudHNcbmZ1bmN0aW9uIGNhbGN1bGF0ZVRva2VuVXNhZ2UodXNhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyB1c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9kZXRlY3QtaW1hZ2UtbWltZXR5cGUudHNcbnZhciBtaW1lVHlwZVNpZ25hdHVyZXMgPSBbXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvZ2lmXCIsIGJ5dGVzOiBbNzEsIDczLCA3MF0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9wbmdcIiwgYnl0ZXM6IFsxMzcsIDgwLCA3OCwgNzFdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2UvanBlZ1wiLCBieXRlczogWzI1NSwgMjE2XSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3dlYnBcIiwgYnl0ZXM6IFs4MiwgNzMsIDcwLCA3MF0gfVxuXTtcbmZ1bmN0aW9uIGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2UpIHtcbiAgZm9yIChjb25zdCB7IGJ5dGVzLCBtaW1lVHlwZSB9IG9mIG1pbWVUeXBlU2lnbmF0dXJlcykge1xuICAgIGlmIChpbWFnZS5sZW5ndGggPj0gYnl0ZXMubGVuZ3RoICYmIGJ5dGVzLmV2ZXJ5KChieXRlLCBpbmRleCkgPT4gaW1hZ2VbaW5kZXhdID09PSBieXRlKSkge1xuICAgICAgcmV0dXJuIG1pbWVUeXBlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuXG4vLyBjb3JlL3Byb21wdC9kYXRhLWNvbnRlbnQudHNcbmltcG9ydCB7IEludmFsaWREYXRhQ29udGVudEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXksXG4gIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjRcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKGNvbnRlbnQpIHtcbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KG5ldyBVaW50OEFycmF5KGNvbnRlbnQpKTtcbiAgfVxuICByZXR1cm4gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnREYXRhQ29udGVudFRvVWludDhBcnJheShjb250ZW50KSB7XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIGlmIChjb250ZW50IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgdGhyb3cgbmV3IEludmFsaWREYXRhQ29udGVudEVycm9yKHsgY29udGVudCB9KTtcbn1cblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQocHJvbXB0KSB7XG4gIGNvbnN0IGxhbmd1YWdlTW9kZWxNZXNzYWdlcyA9IFtdO1xuICBpZiAocHJvbXB0LnN5c3RlbSAhPSBudWxsKSB7XG4gICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goeyByb2xlOiBcInN5c3RlbVwiLCBjb250ZW50OiBwcm9tcHQuc3lzdGVtIH0pO1xuICB9XG4gIHN3aXRjaCAocHJvbXB0LnR5cGUpIHtcbiAgICBjYXNlIFwicHJvbXB0XCI6IHtcbiAgICAgIGxhbmd1YWdlTW9kZWxNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBwcm9tcHQucHJvbXB0IH1dXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwibWVzc2FnZXNcIjoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goXG4gICAgICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2Uucm9sZSkge1xuICAgICAgICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50Lm1hcChcbiAgICAgICAgICAgICAgICAgIChwYXJ0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChwYXJ0LnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFydDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImltYWdlXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0LmltYWdlIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBwYXJ0LmltYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbWVUeXBlOiBwYXJ0Lm1pbWVUeXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZVVpbnQ4ID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0LmltYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJpbWFnZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VVaW50OCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IChfYSA9IHBhcnQubWltZVR5cGUpICE9IG51bGwgPyBfYSA6IGRldGVjdEltYWdlTWltZVR5cGUoaW1hZ2VVaW50OClcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImFzc2lzdGFudFwiOiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogbWVzc2FnZS5jb250ZW50IH1dXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4geyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29sXCI6IHtcbiAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcHJvbXB0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcm9tcHQgdHlwZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzO1xufVxuXG4vLyBjb3JlL3Byb21wdC9nZXQtdmFsaWRhdGVkLXByb21wdC50c1xuaW1wb3J0IHsgSW52YWxpZFByb21wdEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGdldFZhbGlkYXRlZFByb21wdChwcm9tcHQpIHtcbiAgaWYgKHByb21wdC5wcm9tcHQgPT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgb3IgbWVzc2FnZXMgbXVzdCBiZSBkZWZpbmVkXCJcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvbXB0LnByb21wdCAhPSBudWxsICYmIHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBhbmQgbWVzc2FnZXMgY2Fubm90IGJlIGRlZmluZWQgYXQgdGhlIHNhbWUgdGltZVwiXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHByb21wdC5wcm9tcHQgIT0gbnVsbCA/IHtcbiAgICB0eXBlOiBcInByb21wdFwiLFxuICAgIHByb21wdDogcHJvbXB0LnByb21wdCxcbiAgICBtZXNzYWdlczogdm9pZCAwLFxuICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbVxuICB9IDoge1xuICAgIHR5cGU6IFwibWVzc2FnZXNcIixcbiAgICBwcm9tcHQ6IHZvaWQgMCxcbiAgICBtZXNzYWdlczogcHJvbXB0Lm1lc3NhZ2VzLFxuICAgIC8vIG9ubHkgcG9zc2libGUgY2FzZSBiYyBvZiBjaGVja3MgYWJvdmVcbiAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgfTtcbn1cblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5pbXBvcnQgeyBJbnZhbGlkQXJndW1lbnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzZWVkLFxuICBtYXhSZXRyaWVzXG59KSB7XG4gIGlmIChtYXhUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAocHJlc2VuY2VQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByZXNlbmNlUGVuYWx0eSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInByZXNlbmNlUGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogcHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcInByZXNlbmNlUGVuYWx0eSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZnJlcXVlbmN5UGVuYWx0eSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBmcmVxdWVuY3lQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwiZnJlcXVlbmN5UGVuYWx0eVwiLFxuICAgICAgICB2YWx1ZTogZnJlcXVlbmN5UGVuYWx0eSxcbiAgICAgICAgbWVzc2FnZTogXCJmcmVxdWVuY3lQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChzZWVkICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc2VlZCkpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzZWVkXCIsXG4gICAgICAgIHZhbHVlOiBzZWVkLFxuICAgICAgICBtZXNzYWdlOiBcInNlZWQgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAobWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFJldHJpZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4UmV0cmllc1wiLFxuICAgICAgICB2YWx1ZTogbWF4UmV0cmllcyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhSZXRyaWVzIG11c3QgYmUgPj0gMFwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBtYXhUb2tlbnMsXG4gICAgdGVtcGVyYXR1cmU6IHRlbXBlcmF0dXJlICE9IG51bGwgPyB0ZW1wZXJhdHVyZSA6IDAsXG4gICAgdG9wUCxcbiAgICBwcmVzZW5jZVBlbmFsdHksXG4gICAgZnJlcXVlbmN5UGVuYWx0eSxcbiAgICBzZWVkLFxuICAgIG1heFJldHJpZXM6IG1heFJldHJpZXMgIT0gbnVsbCA/IG1heFJldHJpZXMgOiAyXG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9jb252ZXJ0LXpvZC10by1qc29uLXNjaGVtYS50c1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG5mdW5jdGlvbiBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHpvZFNjaGVtYSkge1xuICByZXR1cm4gem9kVG9Kc29uU2NoZW1hKHpvZFNjaGVtYSk7XG59XG5cbi8vIGNvcmUvdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciwgUmV0cnlFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBnZXRFcnJvck1lc3NhZ2UsIGlzQWJvcnRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9kZWxheS50c1xuYXN5bmMgZnVuY3Rpb24gZGVsYXkoZGVsYXlJbk1zKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheUluTXMpKTtcbn1cblxuLy8gY29yZS91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xudmFyIHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiA9ICh7XG4gIG1heFJldHJpZXMgPSAyLFxuICBpbml0aWFsRGVsYXlJbk1zID0gMmUzLFxuICBiYWNrb2ZmRmFjdG9yID0gMlxufSA9IHt9KSA9PiBhc3luYyAoZikgPT4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NczogaW5pdGlhbERlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSk7XG5hc3luYyBmdW5jdGlvbiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59LCBlcnJvcnMgPSBbXSkge1xuICB0cnkge1xuICAgIHJldHVybiBhd2FpdCBmKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA9PT0gMCkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGdldEVycm9yTWVzc2FnZShlcnJvcik7XG4gICAgY29uc3QgbmV3RXJyb3JzID0gWy4uLmVycm9ycywgZXJyb3JdO1xuICAgIGNvbnN0IHRyeU51bWJlciA9IG5ld0Vycm9ycy5sZW5ndGg7XG4gICAgaWYgKHRyeU51bWJlciA+IG1heFJldHJpZXMpIHtcbiAgICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMuIExhc3QgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlfWAsXG4gICAgICAgIHJlYXNvbjogXCJtYXhSZXRyaWVzRXhjZWVkZWRcIixcbiAgICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBBUElDYWxsRXJyb3IuaXNBUElDYWxsRXJyb3IoZXJyb3IpICYmIGVycm9yLmlzUmV0cnlhYmxlID09PSB0cnVlICYmIHRyeU51bWJlciA8PSBtYXhSZXRyaWVzKSB7XG4gICAgICBhd2FpdCBkZWxheShkZWxheUluTXMpO1xuICAgICAgcmV0dXJuIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoXG4gICAgICAgIGYsXG4gICAgICAgIHsgbWF4UmV0cmllcywgZGVsYXlJbk1zOiBiYWNrb2ZmRmFjdG9yICogZGVsYXlJbk1zLCBiYWNrb2ZmRmFjdG9yIH0sXG4gICAgICAgIG5ld0Vycm9yc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKHRyeU51bWJlciA9PT0gMSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBSZXRyeUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzIHdpdGggbm9uLXJldHJ5YWJsZSBlcnJvcjogJyR7ZXJyb3JNZXNzYWdlfSdgLFxuICAgICAgcmVhc29uOiBcImVycm9yTm90UmV0cnlhYmxlXCIsXG4gICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgIH0pO1xuICB9XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2luamVjdC1qc29uLXNjaGVtYS1pbnRvLXN5c3RlbS50c1xudmFyIERFRkFVTFRfU0NIRU1BX1BSRUZJWCA9IFwiSlNPTiBzY2hlbWE6XCI7XG52YXIgREVGQVVMVF9TQ0hFTUFfU1VGRklYID0gXCJZb3UgTVVTVCBhbnN3ZXIgd2l0aCBhIEpTT04gb2JqZWN0IHRoYXQgbWF0Y2hlcyB0aGUgSlNPTiBzY2hlbWEgYWJvdmUuXCI7XG5mdW5jdGlvbiBpbmplY3RKc29uU2NoZW1hSW50b1N5c3RlbSh7XG4gIHN5c3RlbSxcbiAgc2NoZW1hLFxuICBzY2hlbWFQcmVmaXggPSBERUZBVUxUX1NDSEVNQV9QUkVGSVgsXG4gIHNjaGVtYVN1ZmZpeCA9IERFRkFVTFRfU0NIRU1BX1NVRkZJWFxufSkge1xuICByZXR1cm4gW1xuICAgIHN5c3RlbSxcbiAgICBzeXN0ZW0gIT0gbnVsbCA/IFwiXCIgOiBudWxsLFxuICAgIC8vIGFkZCBhIG5ld2xpbmUgaWYgc3lzdGVtIGlzIG5vdCBudWxsXG4gICAgc2NoZW1hUHJlZml4LFxuICAgIEpTT04uc3RyaW5naWZ5KHNjaGVtYSksXG4gICAgc2NoZW1hU3VmZml4XG4gIF0uZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9IG51bGwpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qoe1xuICBtb2RlbCxcbiAgc2NoZW1hLFxuICBtb2RlLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gIGNvbnN0IGpzb25TY2hlbWEgPSBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHNjaGVtYSk7XG4gIGlmIChtb2RlID09PSBcImF1dG9cIiB8fCBtb2RlID09IG51bGwpIHtcbiAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICB9XG4gIGxldCByZXN1bHQ7XG4gIGxldCBmaW5pc2hSZWFzb247XG4gIGxldCB1c2FnZTtcbiAgbGV0IHdhcm5pbmdzO1xuICBsZXQgcmF3UmVzcG9uc2U7XG4gIGxldCBsb2dwcm9icztcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtOiBpbmplY3RKc29uU2NoZW1hSW50b1N5c3RlbSh7IHN5c3RlbSwgc2NoZW1hOiBqc29uU2NoZW1hIH0pLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgbW9kZTogeyB0eXBlOiBcIm9iamVjdC1qc29uXCIgfSxcbiAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChnZW5lcmF0ZVJlc3VsdC50ZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0LnRleHQ7XG4gICAgICBmaW5pc2hSZWFzb24gPSBnZW5lcmF0ZVJlc3VsdC5maW5pc2hSZWFzb247XG4gICAgICB1c2FnZSA9IGdlbmVyYXRlUmVzdWx0LnVzYWdlO1xuICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgIHJhd1Jlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICBsb2dwcm9icyA9IGdlbmVyYXRlUmVzdWx0LmxvZ3Byb2JzO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJncmFtbWFyXCI6IHtcbiAgICAgIGNvbnN0IHZhbGlkYXRlZFByb21wdCA9IGdldFZhbGlkYXRlZFByb21wdCh7XG4gICAgICAgIHN5c3RlbTogaW5qZWN0SnNvblNjaGVtYUludG9TeXN0ZW0oeyBzeXN0ZW0sIHNjaGVtYToganNvblNjaGVtYSB9KSxcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlc1xuICAgICAgfSk7XG4gICAgICBjb25zdCBnZW5lcmF0ZVJlc3VsdCA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHtcbiAgICAgICAgICBtb2RlOiB7IHR5cGU6IFwib2JqZWN0LWdyYW1tYXJcIiwgc2NoZW1hOiBqc29uU2NoZW1hIH0sXG4gICAgICAgICAgLi4uc2V0dGluZ3MsXG4gICAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgICAgIGFib3J0U2lnbmFsXG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgaWYgKGdlbmVyYXRlUmVzdWx0LnRleHQgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZ2VuZXJhdGVSZXN1bHQudGV4dDtcbiAgICAgIGZpbmlzaFJlYXNvbiA9IGdlbmVyYXRlUmVzdWx0LmZpbmlzaFJlYXNvbjtcbiAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICB3YXJuaW5ncyA9IGdlbmVyYXRlUmVzdWx0Lndhcm5pbmdzO1xuICAgICAgcmF3UmVzcG9uc2UgPSBnZW5lcmF0ZVJlc3VsdC5yYXdSZXNwb25zZTtcbiAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgICAgIG1vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICBuYW1lOiBcImpzb25cIixcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgIHBhcmFtZXRlcnM6IGpzb25TY2hlbWFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICAgIGlucHV0Rm9ybWF0OiB2YWxpZGF0ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZ1bmN0aW9uQXJncyA9IChfYiA9IChfYSA9IGdlbmVyYXRlUmVzdWx0LnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYXJncztcbiAgICAgIGlmIChmdW5jdGlvbkFyZ3MgPT09IHZvaWQgMCkge1xuICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gZnVuY3Rpb25BcmdzO1xuICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgdXNhZ2UgPSBnZW5lcmF0ZVJlc3VsdC51c2FnZTtcbiAgICAgIHdhcm5pbmdzID0gZ2VuZXJhdGVSZXN1bHQud2FybmluZ3M7XG4gICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgbG9ncHJvYnMgPSBnZW5lcmF0ZVJlc3VsdC5sb2dwcm9icztcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIHZvaWQgMDoge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZWwgZG9lcyBub3QgaGF2ZSBhIGRlZmF1bHQgb2JqZWN0IGdlbmVyYXRpb24gbW9kZS5cIik7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBtb2RlO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IHJlc3VsdCwgc2NoZW1hIH0pO1xuICBpZiAoIXBhcnNlUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBwYXJzZVJlc3VsdC5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV3IEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICBvYmplY3Q6IHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgIGZpbmlzaFJlYXNvbixcbiAgICB1c2FnZTogY2FsY3VsYXRlVG9rZW5Vc2FnZSh1c2FnZSksXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgbG9ncHJvYnNcbiAgfSk7XG59XG52YXIgR2VuZXJhdGVPYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IG9wdGlvbnMucmF3UmVzcG9uc2U7XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX2dlbmVyYXRlT2JqZWN0ID0gZ2VuZXJhdGVPYmplY3Q7XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlLCB0cmFuc2Zvcm1lcikge1xuICBjb25zdCB0cmFuc2Zvcm1lZFN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKVxuICApO1xuICB0cmFuc2Zvcm1lZFN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gdHJhbnNmb3JtZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH0gOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm1lZFN0cmVhbTtcbn1cblxuLy8gY29yZS91dGlsL2lzLWRlZXAtZXF1YWwtZGF0YS50c1xuZnVuY3Rpb24gaXNEZWVwRXF1YWxEYXRhKG9iajEsIG9iajIpIHtcbiAgaWYgKG9iajEgPT09IG9iajIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChvYmoxID09IG51bGwgfHwgb2JqMiA9PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBvYmoxICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoyICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xuICBpZiAob2JqMS5jb25zdHJ1Y3RvciAhPT0gb2JqMi5jb25zdHJ1Y3RvcilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxIGluc3RhbmNlb2YgRGF0ZSAmJiBvYmoyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqMSkpIHtcbiAgICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtpXSwgb2JqMltpXSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICBpZiAoIWtleXMyLmluY2x1ZGVzKGtleSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtrZXldLCBvYmoyW2tleV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBjb3JlL3V0aWwvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5pbXBvcnQgU2VjdXJlSlNPTiBmcm9tIFwic2VjdXJlLWpzb24tcGFyc2VcIjtcblxuLy8gY29yZS91dGlsL2ZpeC1qc29uLnRzXG5mdW5jdGlvbiBmaXhKc29uKGlucHV0KSB7XG4gIGNvbnN0IHN0YWNrID0gW1wiUk9PVFwiXTtcbiAgbGV0IGxhc3RWYWxpZEluZGV4ID0gLTE7XG4gIGxldCBsaXRlcmFsU3RhcnQgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBzd2FwU3RhdGUpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICBjYXNlIFwiblwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTElURVJBTFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgIGNhc2UgXCJST09UXCI6XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiRklOSVNIXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR19FU0NBUEVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9OVU1CRVJcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpICsgMSk7XG4gICAgICAgIGlmICghXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByZXN1bHQgPSBpbnB1dC5zbGljZSgwLCBsYXN0VmFsaWRJbmRleCArIDEpO1xuICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW2ldO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKFwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwidHJ1ZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiZmFsc2VcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gY29yZS91dGlsL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihqc29uVGV4dCkge1xuICBpZiAoanNvblRleHQgPT0gbnVsbCkge1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gU2VjdXJlSlNPTi5wYXJzZShqc29uVGV4dCk7XG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZml4ZWRKc29uVGV4dCA9IGZpeEpzb24oanNvblRleHQpO1xuICAgICAgcmV0dXJuIFNlY3VyZUpTT04ucGFyc2UoZml4ZWRKc29uVGV4dCk7XG4gICAgfSBjYXRjaCAoaWdub3JlZDIpIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuYXN5bmMgZnVuY3Rpb24gc3RyZWFtT2JqZWN0KHtcbiAgbW9kZWwsXG4gIHNjaGVtYSxcbiAgbW9kZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCBqc29uU2NoZW1hID0gY29udmVydFpvZFRvSlNPTlNjaGVtYShzY2hlbWEpO1xuICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PSBudWxsKSB7XG4gICAgbW9kZSA9IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZTtcbiAgfVxuICBsZXQgY2FsbE9wdGlvbnM7XG4gIGxldCB0cmFuc2Zvcm1lcjtcbiAgc3dpdGNoIChtb2RlKSB7XG4gICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtOiBpbmplY3RKc29uU2NoZW1hSW50b1N5c3RlbSh7IHN5c3RlbSwgc2NoZW1hOiBqc29uU2NoZW1hIH0pLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICBtb2RlOiB7IHR5cGU6IFwib2JqZWN0LWpzb25cIiB9LFxuICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgIH07XG4gICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSBcImdyYW1tYXJcIjoge1xuICAgICAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHtcbiAgICAgICAgc3lzdGVtOiBpbmplY3RKc29uU2NoZW1hSW50b1N5c3RlbSh7IHN5c3RlbSwgc2NoZW1hOiBqc29uU2NoZW1hIH0pLFxuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2VzXG4gICAgICB9KTtcbiAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICBtb2RlOiB7IHR5cGU6IFwib2JqZWN0LWdyYW1tYXJcIiwgc2NoZW1hOiBqc29uU2NoZW1hIH0sXG4gICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgfTtcbiAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoe1xuICAgICAgICBzeXN0ZW0sXG4gICAgICAgIHByb21wdCxcbiAgICAgICAgbWVzc2FnZXNcbiAgICAgIH0pO1xuICAgICAgY2FsbE9wdGlvbnMgPSB7XG4gICAgICAgIG1vZGU6IHtcbiAgICAgICAgICB0eXBlOiBcIm9iamVjdC10b29sXCIsXG4gICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgbmFtZTogXCJqc29uXCIsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJSZXNwb25kIHdpdGggYSBKU09OIG9iamVjdC5cIixcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IGpzb25TY2hlbWFcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC4uLnNldHRpbmdzLFxuICAgICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICAgIHByb21wdDogY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh2YWxpZGF0ZWRQcm9tcHQpLFxuICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgfTtcbiAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGwtZGVsdGFcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmFyZ3NUZXh0RGVsdGEpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY2FzZSB2b2lkIDA6IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1vZGVsIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IG9iamVjdCBnZW5lcmF0aW9uIG1vZGUuXCIpO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gbW9kZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgbW9kZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeSgoKSA9PiBtb2RlbC5kb1N0cmVhbShjYWxsT3B0aW9ucykpO1xuICByZXR1cm4gbmV3IFN0cmVhbU9iamVjdFJlc3VsdCh7XG4gICAgc3RyZWFtOiByZXN1bHQuc3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIpKSxcbiAgICB3YXJuaW5nczogcmVzdWx0Lndhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlOiByZXN1bHQucmF3UmVzcG9uc2VcbiAgfSk7XG59XG52YXIgU3RyZWFtT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc3RyZWFtLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlXG4gIH0pIHtcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gcmF3UmVzcG9uc2U7XG4gIH1cbiAgZ2V0IHBhcnRpYWxPYmplY3RTdHJlYW0oKSB7XG4gICAgbGV0IGFjY3VtdWxhdGVkVGV4dCA9IFwiXCI7XG4gICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICBjb25zdCBjdXJyZW50T2JqZWN0ID0gcGFyc2VQYXJ0aWFsSnNvbihcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCBjdXJyZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gY3VycmVudE9iamVjdDtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjdXJyZW50T2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoY2h1bmsudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgdGhyb3cgY2h1bmsuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICBsZXQgYWNjdW11bGF0ZWRUZXh0ID0gXCJcIjtcbiAgICBsZXQgbGF0ZXN0T2JqZWN0ID0gdm9pZCAwO1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMub3JpZ2luYWxTdHJlYW0sIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRUZXh0ICs9IGNodW5rO1xuICAgICAgICAgIGNvbnN0IGN1cnJlbnRPYmplY3QgPSBwYXJzZVBhcnRpYWxKc29uKFxuICAgICAgICAgICAgYWNjdW11bGF0ZWRUZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShsYXRlc3RPYmplY3QsIGN1cnJlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICBsYXRlc3RPYmplY3QgPSBjdXJyZW50T2JqZWN0O1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHsgdHlwZTogXCJvYmplY3RcIiwgb2JqZWN0OiBjdXJyZW50T2JqZWN0IH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAuLi5jaHVuayxcbiAgICAgICAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlVG9rZW5Vc2FnZShjaHVuay51c2FnZSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCA9IHN0cmVhbU9iamVjdDtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3Rvb2wtY2FsbC50c1xuaW1wb3J0IHtcbiAgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcixcbiAgTm9TdWNoVG9vbEVycm9yXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBzYWZlUGFyc2VKU09OIGFzIHNhZmVQYXJzZUpTT04yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmZ1bmN0aW9uIHBhcnNlVG9vbENhbGwoe1xuICB0b29sQ2FsbCxcbiAgdG9vbHNcbn0pIHtcbiAgY29uc3QgdG9vbE5hbWUgPSB0b29sQ2FsbC50b29sTmFtZTtcbiAgaWYgKHRvb2xzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lIH0pO1xuICB9XG4gIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3Ioe1xuICAgICAgdG9vbE5hbWU6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgIH0pO1xuICB9XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTjIoe1xuICAgIHRleHQ6IHRvb2xDYWxsLmFyZ3MsXG4gICAgc2NoZW1hOiB0b29sMi5wYXJhbWV0ZXJzXG4gIH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICB0b29sTmFtZSxcbiAgICAgIHRvb2xBcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWUsXG4gICAgYXJnczogcGFyc2VSZXN1bHQudmFsdWVcbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgLi4uc2V0dGluZ3Ncbn0pIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICBjb25zdCB2YWxpZGF0ZWRQcm9tcHQgPSBnZXRWYWxpZGF0ZWRQcm9tcHQoeyBzeXN0ZW0sIHByb21wdCwgbWVzc2FnZXMgfSk7XG4gIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgcmV0dXJuIG1vZGVsLmRvR2VuZXJhdGUoe1xuICAgICAgbW9kZToge1xuICAgICAgICB0eXBlOiBcInJlZ3VsYXJcIixcbiAgICAgICAgdG9vbHM6IHRvb2xzID09IG51bGwgPyB2b2lkIDAgOiBPYmplY3QuZW50cmllcyh0b29scykubWFwKChbbmFtZSwgdG9vbDJdKSA9PiAoe1xuICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiB0b29sMi5kZXNjcmlwdGlvbixcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHRvb2wyLnBhcmFtZXRlcnMpXG4gICAgICAgIH0pKVxuICAgICAgfSxcbiAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgaW5wdXRGb3JtYXQ6IHZhbGlkYXRlZFByb21wdC50eXBlLFxuICAgICAgcHJvbXB0OiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHZhbGlkYXRlZFByb21wdCksXG4gICAgICBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICB9KTtcbiAgY29uc3QgdG9vbENhbGxzID0gW107XG4gIGZvciAoY29uc3QgbW9kZWxUb29sQ2FsbCBvZiAoX2EgPSBtb2RlbFJlc3BvbnNlLnRvb2xDYWxscykgIT0gbnVsbCA/IF9hIDogW10pIHtcbiAgICB0b29sQ2FsbHMucHVzaChwYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IG1vZGVsVG9vbENhbGwsIHRvb2xzIH0pKTtcbiAgfVxuICBjb25zdCB0b29sUmVzdWx0cyA9IHRvb2xzID09IG51bGwgPyBbXSA6IGF3YWl0IGV4ZWN1dGVUb29scyh7IHRvb2xDYWxscywgdG9vbHMgfSk7XG4gIHJldHVybiBuZXcgR2VuZXJhdGVUZXh0UmVzdWx0KHtcbiAgICAvLyBBbHdheXMgcmV0dXJuIGEgc3RyaW5nIHNvIHRoYXQgdGhlIGNhbGxlciBkb2Vzbid0IGhhdmUgdG8gY2hlY2sgZm9yIHVuZGVmaW5lZC5cbiAgICAvLyBJZiB0aGV5IG5lZWQgdG8gY2hlY2sgaWYgdGhlIG1vZGVsIGRpZCBub3QgcmV0dXJuIGFueSB0ZXh0LFxuICAgIC8vIHRoZXkgY2FuIGNoZWNrIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZzpcbiAgICB0ZXh0OiAoX2IgPSBtb2RlbFJlc3BvbnNlLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIsXG4gICAgdG9vbENhbGxzLFxuICAgIHRvb2xSZXN1bHRzLFxuICAgIGZpbmlzaFJlYXNvbjogbW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgdXNhZ2U6IGNhbGN1bGF0ZVRva2VuVXNhZ2UobW9kZWxSZXNwb25zZS51c2FnZSksXG4gICAgd2FybmluZ3M6IG1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2UsXG4gICAgbG9ncHJvYnM6IG1vZGVsUmVzcG9uc2UubG9ncHJvYnNcbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBleGVjdXRlVG9vbHMoe1xuICB0b29sQ2FsbHMsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xSZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgdG9vbENhbGxzLm1hcChhc3luYyAodG9vbENhbGwpID0+IHtcbiAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbENhbGwudG9vbE5hbWVdO1xuICAgICAgaWYgKCh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhlY3V0ZSkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdG9vbDIuZXhlY3V0ZSh0b29sQ2FsbC5hcmdzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgcmVzdWx0XG4gICAgICB9O1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgKHJlc3VsdCkgPT4gcmVzdWx0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBHZW5lcmF0ZVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLnRleHQgPSBvcHRpb25zLnRleHQ7XG4gICAgdGhpcy50b29sQ2FsbHMgPSBvcHRpb25zLnRvb2xDYWxscztcbiAgICB0aGlzLnRvb2xSZXN1bHRzID0gb3B0aW9ucy50b29sUmVzdWx0cztcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IG9wdGlvbnMuZmluaXNoUmVhc29uO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICAgIHRoaXMud2FybmluZ3MgPSBvcHRpb25zLndhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSBvcHRpb25zLnJhd1Jlc3BvbnNlO1xuICAgIHRoaXMubG9ncHJvYnMgPSBvcHRpb25zLmxvZ3Byb2JzO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVRleHQgPSBnZW5lcmF0ZVRleHQ7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9ydW4tdG9vbHMtdHJhbnNmb3JtYXRpb24udHNcbmltcG9ydCB7IE5vU3VjaFRvb2xFcnJvciBhcyBOb1N1Y2hUb29sRXJyb3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc2hhcmVkL2dlbmVyYXRlLWlkLnRzXG5pbXBvcnQgeyBjdXN0b21BbHBoYWJldCB9IGZyb20gXCJuYW5vaWQvbm9uLXNlY3VyZVwiO1xudmFyIGdlbmVyYXRlSWQgPSBjdXN0b21BbHBoYWJldChcbiAgXCIwMTIzNDU2Nzg5QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiLFxuICA3XG4pO1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5mdW5jdGlvbiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgdG9vbHMsXG4gIGdlbmVyYXRvclN0cmVhbVxufSkge1xuICBsZXQgY2FuQ2xvc2UgPSBmYWxzZTtcbiAgY29uc3Qgb3V0c3RhbmRpbmdUb29sQ2FsbHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gbnVsbDtcbiAgY29uc3QgdG9vbFJlc3VsdHNTdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gICAgfVxuICB9KTtcbiAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJlcnJvclwiOiB7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IGNodW5rLnRvb2xOYW1lO1xuICAgICAgICAgIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgZXJyb3I6IG5ldyBOb1N1Y2hUb29sRXJyb3IyKHsgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yMih7XG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbCA9IHBhcnNlVG9vbENhbGwoe1xuICAgICAgICAgICAgICB0b29sQ2FsbDogY2h1bmssXG4gICAgICAgICAgICAgIHRvb2xzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0b29sQ2FsbCk7XG4gICAgICAgICAgICBpZiAodG9vbDIuZXhlY3V0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xFeGVjdXRpb25JZCA9IGdlbmVyYXRlSWQoKTtcbiAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sQ2FsbHMuYWRkKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgIHRvb2wyLmV4ZWN1dGUodG9vbENhbGwuYXJncykudGhlbihcbiAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLnRvb2xDYWxsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xDYWxscy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgIGlmIChjYW5DbG9zZSAmJiBvdXRzdGFuZGluZ1Rvb2xDYWxscy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sQ2FsbHMuZGVsZXRlKHRvb2xFeGVjdXRpb25JZCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sQ2FsbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlcnJvclwiLFxuICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBsb2dwcm9iczogY2h1bmsubG9ncHJvYnMsXG4gICAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlVG9rZW5Vc2FnZShjaHVuay51c2FnZSlcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgaWYgKG91dHN0YW5kaW5nVG9vbENhbGxzLnNpemUgPT09IDApIHtcbiAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVRleHQoe1xuICBtb2RlbCxcbiAgdG9vbHMsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pO1xuICBjb25zdCB7IHN0cmVhbSwgd2FybmluZ3MsIHJhd1Jlc3BvbnNlIH0gPSBhd2FpdCByZXRyeShcbiAgICAoKSA9PiBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICBtb2RlOiB7XG4gICAgICAgIHR5cGU6IFwicmVndWxhclwiLFxuICAgICAgICB0b29sczogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5tYXAoKFtuYW1lLCB0b29sMl0pID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246IHRvb2wyLmRlc2NyaXB0aW9uLFxuICAgICAgICAgIHBhcmFtZXRlcnM6IGNvbnZlcnRab2RUb0pTT05TY2hlbWEodG9vbDIucGFyYW1ldGVycylcbiAgICAgICAgfSkpXG4gICAgICB9LFxuICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgIGFib3J0U2lnbmFsXG4gICAgfSlcbiAgKTtcbiAgcmV0dXJuIG5ldyBTdHJlYW1UZXh0UmVzdWx0KHtcbiAgICBzdHJlYW06IHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICAgICAgdG9vbHMsXG4gICAgICBnZW5lcmF0b3JTdHJlYW06IHN0cmVhbVxuICAgIH0pLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlXG4gIH0pO1xufVxudmFyIFN0cmVhbVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2VcbiAgfSkge1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy53YXJuaW5ncyA9IHdhcm5pbmdzO1xuICAgIHRoaXMucmF3UmVzcG9uc2UgPSByYXdSZXNwb25zZTtcbiAgfVxuICAvKipcbiAgQSB0ZXh0IHN0cmVhbSB0aGF0IHJldHVybnMgb25seSB0aGUgZ2VuZXJhdGVkIHRleHQgZGVsdGFzLiBZb3UgY2FuIHVzZSBpdFxuICBhcyBlaXRoZXIgYW4gQXN5bmNJdGVyYWJsZSBvciBhIFJlYWRhYmxlU3RyZWFtLiBXaGVuIGFuIGVycm9yIG9jY3VycywgdGhlXG4gIHN0cmVhbSB3aWxsIHRocm93IHRoZSBlcnJvci5cbiAgICAgKi9cbiAgZ2V0IHRleHRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5vcmlnaW5hbFN0cmVhbSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIGlmIChjaHVuay50eXBlID09PSBcInRleHQtZGVsdGFcIikge1xuICAgICAgICAgIGlmIChjaHVuay50ZXh0RGVsdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLnRleHREZWx0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNodW5rLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgIHRocm93IGNodW5rLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gIEEgc3RyZWFtIHdpdGggYWxsIGV2ZW50cywgaW5jbHVkaW5nIHRleHQgZGVsdGFzLCB0b29sIGNhbGxzLCB0b29sIHJlc3VsdHMsIGFuZFxuICBlcnJvcnMuXG4gIFlvdSBjYW4gdXNlIGl0IGFzIGVpdGhlciBhbiBBc3luY0l0ZXJhYmxlIG9yIGEgUmVhZGFibGVTdHJlYW0uIFdoZW4gYW4gZXJyb3Igb2NjdXJzLCB0aGVcbiAgc3RyZWFtIHdpbGwgdGhyb3cgdGhlIGVycm9yLlxuICAgICAqL1xuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiKSB7XG4gICAgICAgICAgaWYgKGNodW5rLnRleHREZWx0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gIENvbnZlcnRzIHRoZSByZXN1bHQgdG8gYW4gYEFJU3RyZWFtYCBvYmplY3QgdGhhdCBpcyBjb21wYXRpYmxlIHdpdGggYFN0cmVhbWluZ1RleHRSZXNwb25zZWAuXG4gIEl0IGNhbiBiZSB1c2VkIHdpdGggdGhlIGB1c2VDaGF0YCBhbmQgYHVzZUNvbXBsZXRpb25gIGhvb2tzLlxuICBcbiAgQHBhcmFtIGNhbGxiYWNrcyBcbiAgU3RyZWFtIGNhbGxiYWNrcyB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIHN0cmVhbSBlbWl0cyBldmVudHMuXG4gIFxuICBAcmV0dXJucyBhbiBgQUlTdHJlYW1gIG9iamVjdC5cbiAgICAgKi9cbiAgdG9BSVN0cmVhbShjYWxsYmFja3MpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxuICAvKipcbiAgV3JpdGVzIHN0cmVhbSBkYXRhIG91dHB1dCB0byBhIE5vZGUuanMgcmVzcG9uc2UtbGlrZSBvYmplY3QuXG4gIEl0IHNldHMgYSBgQ29udGVudC1UeXBlYCBoZWFkZXIgdG8gYHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThgIGFuZCBcbiAgd3JpdGVzIGVhY2ggc3RyZWFtIGRhdGEgcGFydCBhcyBhIHNlcGFyYXRlIGNodW5rLlxuICBcbiAgQHBhcmFtIHJlc3BvbnNlIEEgTm9kZS5qcyByZXNwb25zZS1saWtlIG9iamVjdCAoU2VydmVyUmVzcG9uc2UpLlxuICBAcGFyYW0gaW5pdCBPcHRpb25hbCBoZWFkZXJzIGFuZCBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgcGlwZUFJU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHZhciBfYTtcbiAgICByZXNwb25zZS53cml0ZUhlYWQoKF9hID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYSA6IDIwMCwge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgICB9KTtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIodm9pZCAwKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpLmdldFJlYWRlcigpO1xuICAgIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzcG9uc2UuZW5kKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICByZWFkKCk7XG4gIH1cbiAgLyoqXG4gIFdyaXRlcyB0ZXh0IGRlbHRhIG91dHB1dCB0byBhIE5vZGUuanMgcmVzcG9uc2UtbGlrZSBvYmplY3QuXG4gIEl0IHNldHMgYSBgQ29udGVudC1UeXBlYCBoZWFkZXIgdG8gYHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThgIGFuZCBcbiAgd3JpdGVzIGVhY2ggdGV4dCBkZWx0YSBhcyBhIHNlcGFyYXRlIGNodW5rLlxuICBcbiAgQHBhcmFtIHJlc3BvbnNlIEEgTm9kZS5qcyByZXNwb25zZS1saWtlIG9iamVjdCAoU2VydmVyUmVzcG9uc2UpLlxuICBAcGFyYW0gaW5pdCBPcHRpb25hbCBoZWFkZXJzIGFuZCBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgdmFyIF9hO1xuICAgIHJlc3BvbnNlLndyaXRlSGVhZCgoX2EgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hIDogMjAwLCB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgIH0pO1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMudGV4dFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCByZWFkID0gYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgcmVzcG9uc2Uud3JpdGUoZW5jb2Rlci5lbmNvZGUodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJlYWQoKTtcbiAgfVxuICAvKipcbiAgQ29udmVydHMgdGhlIHJlc3VsdCB0byBhIHN0cmVhbWVkIHJlc3BvbnNlIG9iamVjdCB3aXRoIGEgc3RyZWFtIGRhdGEgcGFydCBzdHJlYW0uXG4gIEl0IGNhbiBiZSB1c2VkIHdpdGggdGhlIGB1c2VDaGF0YCBhbmQgYHVzZUNvbXBsZXRpb25gIGhvb2tzLlxuICBcbiAgQHBhcmFtIGluaXQgT3B0aW9uYWwgaGVhZGVycy5cbiAgXG4gIEByZXR1cm4gQSByZXNwb25zZSBvYmplY3QuXG4gICAgICovXG4gIHRvQUlTdHJlYW1SZXNwb25zZShpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1pbmdUZXh0UmVzcG9uc2UodGhpcy50b0FJU3RyZWFtKCksIGluaXQpO1xuICB9XG4gIC8qKlxuICBDcmVhdGVzIGEgc2ltcGxlIHRleHQgc3RyZWFtIHJlc3BvbnNlLlxuICBFYWNoIHRleHQgZGVsdGEgaXMgZW5jb2RlZCBhcyBVVEYtOCBhbmQgc2VudCBhcyBhIHNlcGFyYXRlIGNodW5rLlxuICBOb24tdGV4dC1kZWx0YSBldmVudHMgYXJlIGlnbm9yZWQuXG4gIFxuICBAcGFyYW0gaW5pdCBPcHRpb25hbCBoZWFkZXJzIGFuZCBzdGF0dXMgY29kZS5cbiAgICAgKi9cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgIHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChcbiAgICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoY2h1bmspKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApLFxuICAgICAge1xuICAgICAgICBzdGF0dXM6IChfYSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2EgOiAyMDAsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIixcbiAgICAgICAgICAuLi5pbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnNcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX3N0cmVhbVRleHQgPSBzdHJlYW1UZXh0O1xuXG4vLyBjb3JlL3Rvb2wvdG9vbC50c1xuZnVuY3Rpb24gdG9vbCh0b29sMikge1xuICByZXR1cm4gdG9vbDI7XG59XG5cbi8vIGNvcmUvdHlwZXMvZXJyb3JzLnRzXG5pbXBvcnQge1xuICBBUElDYWxsRXJyb3IgYXMgQVBJQ2FsbEVycm9yMixcbiAgRW1wdHlSZXNwb25zZUJvZHlFcnJvcixcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IgYXMgSW52YWxpZEFyZ3VtZW50RXJyb3IyLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciBhcyBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcjIsXG4gIEludmFsaWRQcm9tcHRFcnJvciBhcyBJbnZhbGlkUHJvbXB0RXJyb3IyLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgYXMgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcjIsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IgYXMgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcjIsXG4gIE5vU3VjaFRvb2xFcnJvciBhcyBOb1N1Y2hUb29sRXJyb3IzLFxuICBSZXRyeUVycm9yIGFzIFJldHJ5RXJyb3IyLFxuICBUb29sQ2FsbFBhcnNlRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IsXG4gIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBVbnN1cHBvcnRlZEpTT05TY2hlbWFFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzaGFyZWQvc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjFcIixcbiAgbmFtZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZ1bmN0aW9uX2NhbGxcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8ICEoXCJuYW1lXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgIShcImFyZ3VtZW50c1wiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNVwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidGhyZWFkSWRcIiBpbiB2YWx1ZSkgfHwgIShcIm1lc3NhZ2VJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI2XCIsXG4gIG5hbWU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJkYXRhXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI3XCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sX2NhbGxzXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sX2NhbGxzICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLnRvb2xfY2FsbHMgPT0gbnVsbCB8fCAhQXJyYXkuaXNBcnJheSh2YWx1ZS50b29sX2NhbGxzKSB8fCB2YWx1ZS50b29sX2NhbGxzLnNvbWUoXG4gICAgICAodGMpID0+IHRjID09IG51bGwgfHwgdHlwZW9mIHRjICE9PSBcIm9iamVjdFwiIHx8ICEoXCJpZFwiIGluIHRjKSB8fCB0eXBlb2YgdGMuaWQgIT09IFwic3RyaW5nXCIgfHwgIShcInR5cGVcIiBpbiB0YykgfHwgdHlwZW9mIHRjLnR5cGUgIT09IFwic3RyaW5nXCIgfHwgIShcImZ1bmN0aW9uXCIgaW4gdGMpIHx8IHRjLmZ1bmN0aW9uID09IG51bGwgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uICE9PSBcIm9iamVjdFwiIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB0Yy5mdW5jdGlvbikgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHRjLmZ1bmN0aW9uLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsc1wiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFRvb2xDYWxsUGF5bG9hZC4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxzXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI4XCIsXG4gIG5hbWU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiBwYXJ0cyBleHBlY3QgYW4gYXJyYXkgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiLCB2YWx1ZSB9O1xuICB9XG59O1xudmFyIHN0cmVhbVBhcnRzID0gW1xuICB0ZXh0U3RyZWFtUGFydCxcbiAgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgZGF0YVN0cmVhbVBhcnQsXG4gIGVycm9yU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnRcbl07XG52YXIgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG59O1xudmFyIFN0cmVhbVN0cmluZ1ByZWZpeGVzID0ge1xuICBbdGV4dFN0cmVhbVBhcnQubmFtZV06IHRleHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0Lm5hbWVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhU3RyZWFtUGFydC5uYW1lXTogZGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2Vycm9yU3RyZWFtUGFydC5uYW1lXTogZXJyb3JTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5uYW1lXTogYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZVxufTtcbnZhciB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlU3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0U3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNoYXJlZC9yZWFkLWRhdGEtc3RyZWFtLnRzXG52YXIgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbmZ1bmN0aW9uIGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuYXN5bmMgZnVuY3Rpb24qIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICBpc0Fib3J0ZWRcbn0gPSB7fSkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICB0b3RhbExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09IE5FV0xJTkUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzdHJlYW1QYXJ0czIgPSBkZWNvZGVyLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIikubWFwKHBhcnNlU3RyZWFtUGFydCk7XG4gICAgZm9yIChjb25zdCBzdHJlYW1QYXJ0IG9mIHN0cmVhbVBhcnRzMikge1xuICAgICAgeWllbGQgc3RyZWFtUGFydDtcbiAgICB9XG4gICAgaWYgKGlzQWJvcnRlZCA9PSBudWxsID8gdm9pZCAwIDogaXNBYm9ydGVkKCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzaGFyZWQvdXRpbHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICBpZiAoIWNodW5rKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIik7XG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxudmFyIGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUgPSAodHlwZSwgdmFsdWUpID0+IHZhbHVlLnN0YXJ0c1dpdGgoYCR7U3RyZWFtU3RyaW5nUHJlZml4ZXNbdHlwZV19OmApICYmIHZhbHVlLmVuZHNXaXRoKFwiXFxuXCIpO1xuXG4vLyBzdHJlYW1zL2FpLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJldmVudFwiICYmIGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCIgfHwgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgZXZlbnQuZXZlbnQgPT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXIgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSwge1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICAgIH0pIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlKVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlci5mZWVkKHRleHREZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgY29uc3QgY2FsbGJhY2tzID0gY2IgfHwge307XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydClcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICB9LFxuICAgIGFzeW5jIHRyYW5zZm9ybShtZXNzYWdlLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZS5jb250ZW50O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY29udGVudDtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4oY29udGVudCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICByZXR1cm4gXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGxcIiBpbiBjYWxsYmFja3M7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQpID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFJU3RyZWFtKHJlc3BvbnNlLCBjdXN0b21QYXJzZXIsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihcIlJlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGF3YWl0ICgoX2EgPSBpdC5yZXR1cm4pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGl0LCByZWFzb24pKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG52YXIgU3RyZWFtRGF0YSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgdGhpcy5jb250cm9sbGVyID0gbnVsbDtcbiAgICAvLyBjbG9zaW5nIHRoZSBzdHJlYW0gaXMgc3luY2hyb25vdXMsIGJ1dCB3ZSB3YW50IHRvIHJldHVybiBhIHByb21pc2VcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIGRvaW5nIGFzeW5jIHdvcmtcbiAgICB0aGlzLmlzQ2xvc2VkUHJvbWlzZSA9IG51bGw7XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgLy8gYXJyYXkgdG8gc3RvcmUgYXBwZW5kZWQgZGF0YVxuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMubWVzc2FnZUFubm90YXRpb25zID0gW107XG4gICAgdGhpcy5pc0Nsb3NlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlciA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5zdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHN0YXJ0OiBhc3luYyAoY29udHJvbGxlcikgPT4ge1xuICAgICAgICBzZWxmLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgfSxcbiAgICAgIHRyYW5zZm9ybTogYXN5bmMgKGNodW5rLCBjb250cm9sbGVyKSA9PiB7XG4gICAgICAgIGlmIChzZWxmLmRhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHNlbGYuZGF0YSA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWRNZXNzYWdlQW5ub3RhdGlvbnMgPSBzZWxmLmVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgc2VsZi5tZXNzYWdlQW5ub3RhdGlvbnMpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBzZWxmLm1lc3NhZ2VBbm5vdGF0aW9ucyA9IFtdO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkTWVzc2FnZUFubm90YXRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29uc3Qgd2FybmluZ1RpbWVvdXQgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiID8gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgXCJUaGUgZGF0YSBzdHJlYW0gaXMgaGFuZ2luZy4gRGlkIHlvdSBmb3JnZXQgdG8gY2xvc2UgaXQgd2l0aCBgZGF0YS5jbG9zZSgpYD9cIlxuICAgICAgICAgICk7XG4gICAgICAgIH0sIDNlMykgOiBudWxsO1xuICAgICAgICBhd2FpdCBzZWxmLmlzQ2xvc2VkUHJvbWlzZTtcbiAgICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5kYXRhLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJkYXRhXCIsIHNlbGYuZGF0YSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYubWVzc2FnZUFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IGVuY29kZWREYXRhID0gc2VsZi5lbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIHNlbGYubWVzc2FnZUFubm90YXRpb25zKVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWREYXRhKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIHZhciBfYTtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgKF9hID0gdGhpcy5pc0Nsb3NlZFByb21pc2VSZXNvbHZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gIH1cbiAgYXBwZW5kKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5kYXRhLnB1c2godmFsdWUpO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5tZXNzYWdlQW5ub3RhdGlvbnMucHVzaCh2YWx1ZSk7XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgbWVzc2FnZSkpKTtcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW1EYXRhIHtcbn07XG5cbi8vIHN0cmVhbXMvYW50aHJvcGljLXN0cmVhbS50c1xuZnVuY3Rpb24gcGFyc2VBbnRocm9waWNTdHJlYW0oKSB7XG4gIGxldCBwcmV2aW91cyA9IFwiXCI7XG4gIHJldHVybiAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIGlmIChcImVycm9yXCIgaW4ganNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2pzb24uZXJyb3IudHlwZX06ICR7anNvbi5lcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbiAgICBpZiAoIShcImNvbXBsZXRpb25cIiBpbiBqc29uKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0ganNvbi5jb21wbGV0aW9uO1xuICAgIGlmICghcHJldmlvdXMgfHwgdGV4dC5sZW5ndGggPiBwcmV2aW91cy5sZW5ndGggJiYgdGV4dC5zdGFydHNXaXRoKHByZXZpb3VzKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSB0ZXh0LnNsaWNlKHByZXZpb3VzLmxlbmd0aCk7XG4gICAgICBwcmV2aW91cyA9IHRleHQ7XG4gICAgICByZXR1cm4gZGVsdGE7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9O1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwiY29tcGxldGlvblwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB0ZXh0ID0gY2h1bmsuY29tcGxldGlvbjtcbiAgICAgIGlmICh0ZXh0KVxuICAgICAgICB5aWVsZCB0ZXh0O1xuICAgIH0gZWxzZSBpZiAoXCJkZWx0YVwiIGluIGNodW5rKSB7XG4gICAgICBjb25zdCB7IGRlbHRhIH0gPSBjaHVuaztcbiAgICAgIGlmIChcInRleHRcIiBpbiBkZWx0YSkge1xuICAgICAgICBjb25zdCB0ZXh0ID0gZGVsdGEudGV4dDtcbiAgICAgICAgaWYgKHRleHQpXG4gICAgICAgICAgeWllbGQgdGV4dDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEFudGhyb3BpY1N0cmVhbShyZXMsIGNiKSB7XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICByZXR1cm4gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlKHJlcykpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNiKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBBSVN0cmVhbShyZXMsIHBhcnNlQW50aHJvcGljU3RyZWFtKCksIGNiKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICAgKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2Fzc2lzdGFudC1yZXNwb25zZS50c1xuZnVuY3Rpb24gQXNzaXN0YW50UmVzcG9uc2UoeyB0aHJlYWRJZCwgbWVzc2FnZUlkIH0sIHByb2Nlc3MyKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwiYXNzaXN0YW50X21lc3NhZ2VcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZERhdGFNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwiZGF0YV9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmRFcnJvciA9IChlcnJvck1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwiZXJyb3JcIiwgZXJyb3JNZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmb3J3YXJkU3RyZWFtID0gYXN5bmMgKHN0cmVhbTIpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2I7XG4gICAgICAgIGxldCByZXN1bHQgPSB2b2lkIDA7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgdmFsdWUgb2Ygc3RyZWFtMikge1xuICAgICAgICAgIHN3aXRjaCAodmFsdWUuZXZlbnQpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5jcmVhdGVkXCI6IHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJhc3Npc3RhbnRfbWVzc2FnZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiB2YWx1ZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbeyB0eXBlOiBcInRleHRcIiwgdGV4dDogeyB2YWx1ZTogXCJcIiB9IH1dXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuZGVsdGFcIjoge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gKF9hMiA9IHZhbHVlLmRhdGEuZGVsdGEuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMlswXTtcbiAgICAgICAgICAgICAgaWYgKChjb250ZW50ID09IG51bGwgPyB2b2lkIDAgOiBjb250ZW50LnR5cGUpID09PSBcInRleHRcIiAmJiAoKF9iID0gY29udGVudC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2IudmFsdWUpICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIGNvbnRlbnQudGV4dC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRocmVhZC5ydW4uY29tcGxldGVkXCI6XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLnJ1bi5yZXF1aXJlc19hY3Rpb25cIjoge1xuICAgICAgICAgICAgICByZXN1bHQgPSB2YWx1ZS5kYXRhO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLCB7XG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9jZXNzMih7XG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICAgIHNlbmREYXRhTWVzc2FnZSxcbiAgICAgICAgICBmb3J3YXJkU3RyZWFtXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VuZEVycm9yKChfYSA9IGVycm9yLm1lc3NhZ2UpICE9IG51bGwgPyBfYSA6IGAke2Vycm9yfWApO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHVsbChjb250cm9sbGVyKSB7XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZXNwb25zZShzdHJlYW0sIHtcbiAgICBzdGF0dXM6IDIwMCxcbiAgICBoZWFkZXJzOiB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICAgIH1cbiAgfSk7XG59XG52YXIgZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlID0gQXNzaXN0YW50UmVzcG9uc2U7XG5cbi8vIHN0cmVhbXMvYXdzLWJlZHJvY2stc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogYXNEZWx0YUl0ZXJhYmxlKHJlc3BvbnNlLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiAoX2EgPSByZXNwb25zZS5ib2R5KSAhPSBudWxsID8gX2EgOiBbXSkge1xuICAgIGNvbnN0IGJ5dGVzID0gKF9iID0gY2h1bmsuY2h1bmspID09IG51bGwgPyB2b2lkIDAgOiBfYi5ieXRlcztcbiAgICBpZiAoYnl0ZXMgIT0gbnVsbCkge1xuICAgICAgY29uc3QgY2h1bmtUZXh0ID0gZGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgY29uc3QgY2h1bmtKU09OID0gSlNPTi5wYXJzZShjaHVua1RleHQpO1xuICAgICAgY29uc3QgZGVsdGEgPSBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKGNodW5rSlNPTik7XG4gICAgICBpZiAoZGVsdGEgIT0gbnVsbCkge1xuICAgICAgICB5aWVsZCBkZWx0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tBbnRocm9waWNNZXNzYWdlc1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gY2h1bmsuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS50ZXh0O1xuICB9KTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tBbnRocm9waWNTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmNvbXBsZXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0NvaGVyZVN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsgPT0gbnVsbCA/IHZvaWQgMCA6IGNodW5rLnRleHQpO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja0xsYW1hMlN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIChjaHVuaykgPT4gY2h1bmsuZ2VuZXJhdGlvbik7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MsIGV4dHJhY3RUZXh0RGVsdGFGcm9tQ2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoXG4gICAgYXNEZWx0YUl0ZXJhYmxlKHJlc3BvbnNlLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKVxuICApLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9jb2hlcmUtc3RyZWFtLnRzXG52YXIgdXRmOERlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoXCJ1dGYtOFwiKTtcbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NMaW5lcyhsaW5lcywgY29udHJvbGxlcikge1xuICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICBjb25zdCB7IHRleHQsIGlzX2ZpbmlzaGVkIH0gPSBKU09OLnBhcnNlKGxpbmUpO1xuICAgIGlmICghaXNfZmluaXNoZWQpIHtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKSB7XG4gIGxldCBzZWdtZW50ID0gXCJcIjtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCB7IHZhbHVlOiBjaHVuaywgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNlZ21lbnQgKz0gdXRmOERlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KTtcbiAgICBjb25zdCBsaW5lc0FycmF5ID0gc2VnbWVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvZyk7XG4gICAgc2VnbWVudCA9IGxpbmVzQXJyYXkucG9wKCkgfHwgXCJcIjtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgaWYgKHNlZ21lbnQpIHtcbiAgICBjb25zdCBsaW5lc0FycmF5ID0gW3NlZ21lbnRdO1xuICAgIGF3YWl0IHByb2Nlc3NMaW5lcyhsaW5lc0FycmF5LCBjb250cm9sbGVyKTtcbiAgfVxuICBjb250cm9sbGVyLmNsb3NlKCk7XG59XG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIyKHJlcykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHJlYWRlciA9IChfYSA9IHJlcy5ib2R5KSA9PSBudWxsID8gdm9pZCAwIDogX2EuZ2V0UmVhZGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGlmICghcmVhZGVyKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYXdhaXQgcmVhZEFuZFByb2Nlc3NMaW5lcyhyZWFkZXIsIGNvbnRyb2xsZXIpO1xuICAgIH1cbiAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTIoc3RyZWFtKSB7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKGNodW5rLmV2ZW50VHlwZSA9PT0gXCJ0ZXh0LWdlbmVyYXRpb25cIikge1xuICAgICAgY29uc3QgdGV4dCA9IGNodW5rLnRleHQ7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIENvaGVyZVN0cmVhbShyZWFkZXIsIGNhbGxiYWNrcykge1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVhZGVyKSB7XG4gICAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTIocmVhZGVyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVQYXJzZXIyKHJlYWRlcikucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5cbi8vIHN0cmVhbXMvZ29vZ2xlLWdlbmVyYXRpdmUtYWktc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTMocmVzcG9uc2UpIHtcbiAgdmFyIF9hLCBfYiwgX2M7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2Uuc3RyZWFtKSB7XG4gICAgY29uc3QgcGFydHMgPSAoX2MgPSAoX2IgPSAoX2EgPSBjaHVuay5jYW5kaWRhdGVzKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2MucGFydHM7XG4gICAgaWYgKHBhcnRzID09PSB2b2lkIDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFBhcnQgPSBwYXJ0c1swXTtcbiAgICBpZiAodHlwZW9mIGZpcnN0UGFydC50ZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICB5aWVsZCBmaXJzdFBhcnQudGV4dDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbShyZXNwb25zZSwgY2IpIHtcbiAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTMocmVzcG9uc2UpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbn1cblxuLy8gc3RyZWFtcy9odWdnaW5nZmFjZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVBhcnNlcjMocmVzKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVzLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKChfYiA9IChfYSA9IHZhbHVlLnRva2VuKSA9PSBudWxsID8gdm9pZCAwIDogX2EudGV4dCkgIT0gbnVsbCA/IF9iIDogXCJcIik7XG4gICAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIGlmICh2YWx1ZS5nZW5lcmF0ZWRfdGV4dCAhPSBudWxsICYmIHZhbHVlLmdlbmVyYXRlZF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRleHQgPT09IFwiPC9zPlwiIHx8IHRleHQgPT09IFwiPHxlbmRvZnRleHR8PlwiIHx8IHRleHQgPT09IFwiPHxlbmR8PlwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gSHVnZ2luZ0ZhY2VTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIGNyZWF0ZVBhcnNlcjMocmVzKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvaW5rZWVwLXN0cmVhbS50c1xuZnVuY3Rpb24gSW5rZWVwU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGlmICghcmVzLmJvZHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXNwb25zZSBib2R5IGlzIG51bGxcIik7XG4gIH1cbiAgbGV0IGNoYXRfc2Vzc2lvbl9pZCA9IFwiXCI7XG4gIGxldCByZWNvcmRzX2NpdGVkO1xuICBjb25zdCBpbmtlZXBFdmVudFBhcnNlciA9IChkYXRhLCBvcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGV2ZW50IH0gPSBvcHRpb25zO1xuICAgIGlmIChldmVudCA9PT0gXCJyZWNvcmRzX2NpdGVkXCIpIHtcbiAgICAgIHJlY29yZHNfY2l0ZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgKF9hID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25SZWNvcmRzQ2l0ZWQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcywgcmVjb3Jkc19jaXRlZCk7XG4gICAgfVxuICAgIGlmIChldmVudCA9PT0gXCJtZXNzYWdlX2NodW5rXCIpIHtcbiAgICAgIGNvbnN0IGlua2VlcE1lc3NhZ2VDaHVuayA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICBjaGF0X3Nlc3Npb25faWQgPSAoX2IgPSBpbmtlZXBNZXNzYWdlQ2h1bmsuY2hhdF9zZXNzaW9uX2lkKSAhPSBudWxsID8gX2IgOiBjaGF0X3Nlc3Npb25faWQ7XG4gICAgICByZXR1cm4gaW5rZWVwTWVzc2FnZUNodW5rLmNvbnRlbnRfY2h1bms7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfTtcbiAgbGV0IHsgb25SZWNvcmRzQ2l0ZWQsIC4uLnBhc3NUaHJvdWdoQ2FsbGJhY2tzIH0gPSBjYWxsYmFja3MgfHwge307XG4gIHBhc3NUaHJvdWdoQ2FsbGJhY2tzID0ge1xuICAgIC4uLnBhc3NUaHJvdWdoQ2FsbGJhY2tzLFxuICAgIG9uRmluYWw6IChjb21wbGV0aW9uKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEgPSB7XG4gICAgICAgIGNoYXRfc2Vzc2lvbl9pZCxcbiAgICAgICAgcmVjb3Jkc19jaXRlZFxuICAgICAgfTtcbiAgICAgIChfYSA9IGNhbGxiYWNrcyA9PSBudWxsID8gdm9pZCAwIDogY2FsbGJhY2tzLm9uRmluYWwpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGNhbGxiYWNrcywgY29tcGxldGlvbiwgaW5rZWVwT25GaW5hbE1ldGFkYXRhKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBBSVN0cmVhbShyZXMsIGlua2VlcEV2ZW50UGFyc2VyLCBwYXNzVGhyb3VnaENhbGxiYWNrcykucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgKTtcbn1cblxuLy8gc3RyZWFtcy9sYW5nY2hhaW4tc3RyZWFtLnRzXG5mdW5jdGlvbiBMYW5nQ2hhaW5TdHJlYW0oY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oKTtcbiAgY29uc3Qgd3JpdGVyID0gc3RyZWFtLndyaXRhYmxlLmdldFdyaXRlcigpO1xuICBjb25zdCBydW5zID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgaGFuZGxlRXJyb3IgPSBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICBydW5zLmRlbGV0ZShydW5JZCk7XG4gICAgYXdhaXQgd3JpdGVyLnJlYWR5O1xuICAgIGF3YWl0IHdyaXRlci5hYm9ydChlKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlU3RhcnQgPSBhc3luYyAocnVuSWQpID0+IHtcbiAgICBydW5zLmFkZChydW5JZCk7XG4gIH07XG4gIGNvbnN0IGhhbmRsZUVuZCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBpZiAocnVucy5zaXplID09PSAwKSB7XG4gICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICBhd2FpdCB3cml0ZXIuY2xvc2UoKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBzdHJlYW0ucmVhZGFibGUucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpLFxuICAgIHdyaXRlcixcbiAgICBoYW5kbGVyczoge1xuICAgICAgaGFuZGxlTExNTmV3VG9rZW46IGFzeW5jICh0b2tlbikgPT4ge1xuICAgICAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgICAgIGF3YWl0IHdyaXRlci53cml0ZSh0b2tlbik7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNU3RhcnQ6IGFzeW5jIChfbGxtLCBfcHJvbXB0cywgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUxMTUVuZDogYXN5bmMgKF9vdXRwdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5TdGFydDogYXN5bmMgKF9jaGFpbiwgX2lucHV0cywgcnVuSWQpID0+IHtcbiAgICAgICAgaGFuZGxlU3RhcnQocnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZUNoYWluRW5kOiBhc3luYyAoX291dHB1dHMsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5FcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sU3RhcnQ6IGFzeW5jIChfdG9vbCwgX2lucHV0LCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbEVuZDogYXN5bmMgKF9vdXRwdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVuZChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlVG9vbEVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gc3RyZWFtcy9taXN0cmFsLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU0KHN0cmVhbSkge1xuICB2YXIgX2EsIF9iO1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSAoX2IgPSAoX2EgPSBjaHVuay5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jb250ZW50O1xuICAgIGlmIChjb250ZW50ID09PSB2b2lkIDAgfHwgY29udGVudCA9PT0gXCJcIikge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHlpZWxkIGNvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIE1pc3RyYWxTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICBjb25zdCBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGU0KHJlc3BvbnNlKSk7XG4gIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL29wZW5haS1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlT3BlbkFJU3RyZWFtKCkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIChkYXRhKSA9PiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkpO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGU1KHN0cmVhbSkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgZm9yIGF3YWl0IChsZXQgY2h1bmsgb2Ygc3RyZWFtKSB7XG4gICAgaWYgKFwicHJvbXB0RmlsdGVyUmVzdWx0c1wiIGluIGNodW5rKSB7XG4gICAgICBjaHVuayA9IHtcbiAgICAgICAgaWQ6IGNodW5rLmlkLFxuICAgICAgICBjcmVhdGVkOiBjaHVuay5jcmVhdGVkLmdldERhdGUoKSxcbiAgICAgICAgb2JqZWN0OiBjaHVuay5vYmplY3QsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBtb2RlbDogY2h1bmsubW9kZWwsXG4gICAgICAgIC8vIG5vdCBleHBvc2VkIGJ5IEF6dXJlIEFQSVxuICAgICAgICBjaG9pY2VzOiBjaHVuay5jaG9pY2VzLm1hcCgoY2hvaWNlKSA9PiB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgICBjb250ZW50OiAoX2EgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jb250ZW50LFxuICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiAoX2IgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYi5mdW5jdGlvbkNhbGwsXG4gICAgICAgICAgICAgIHJvbGU6IChfYyA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnJvbGUsXG4gICAgICAgICAgICAgIHRvb2xfY2FsbHM6ICgoX2UgPSAoX2QgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZC50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5sZW5ndGgpID8gKF9nID0gKF9mID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2YudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2cubWFwKCh0b29sQ2FsbCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgaWQ6IHRvb2xDYWxsLmlkLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB0b29sQ2FsbC5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlOiB0b29sQ2FsbC50eXBlXG4gICAgICAgICAgICAgIH0pKSA6IHZvaWQgMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpbmlzaF9yZWFzb246IGNob2ljZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBpbmRleDogY2hvaWNlLmluZGV4XG4gICAgICAgICAgfTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSBleHRyYWN0KGNodW5rKTtcbiAgICBpZiAodGV4dClcbiAgICAgIHlpZWxkIHRleHQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGNodW5rVG9UZXh0KCkge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIGxldCBpc0Z1bmN0aW9uU3RyZWFtaW5nSW47XG4gIHJldHVybiAoanNvbikgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3EsIF9yO1xuICAgIGlmIChpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gKF9hID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EuZGVsdGE7XG4gICAgICBpZiAoKF9iID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGB7XCJmdW5jdGlvbl9jYWxsXCI6IHtcIm5hbWVcIjogXCIke2RlbHRhLmZ1bmN0aW9uX2NhbGwubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChfZSA9IChfZCA9IChfYyA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfY1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2UubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBjb25zdCB0b29sQ2FsbCA9IGRlbHRhLnRvb2xfY2FsbHNbMF07XG4gICAgICAgIGlmICh0b29sQ2FsbC5pbmRleCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYHtcInRvb2xfY2FsbHNcIjpbIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHsoX2YgPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBgXCJ9fSwge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZyA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2cubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgoX2ggPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2guYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKChfaSA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaS5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChfbCA9IChfayA9IChfaiA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfalswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9rLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2wuYXJndW1lbnRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBjbGVhbnVwQXJndW1lbnRzKChfbyA9IChfbiA9IChfbSA9IGRlbHRhLnRvb2xfY2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfbVswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9uLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX28uYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKCgoX3AgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcC5maW5pc2hfcmVhc29uKSA9PT0gXCJmdW5jdGlvbl9jYWxsXCIgfHwgKChfcSA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9xLmZpbmlzaF9yZWFzb24pID09PSBcInN0b3BcIikpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fSdcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoX3IgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfci5maW5pc2hfcmVhc29uKSA9PT0gXCJ0b29sX2NhbGxzXCIpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiAnXCJ9fV19J1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oXG4gICAgICBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikgJiYganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgPyBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA6IGlzQ29tcGxldGlvbihqc29uKSA/IGpzb24uY2hvaWNlc1swXS50ZXh0IDogXCJcIlxuICAgICk7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH07XG4gIGZ1bmN0aW9uIGNsZWFudXBBcmd1bWVudHMoYXJndW1lbnRDaHVuaykge1xuICAgIGxldCBlc2NhcGVkUGFydGlhbEpzb24gPSBhcmd1bWVudENodW5rLnJlcGxhY2UoL1xcXFwvZywgXCJcXFxcXFxcXFwiKS5yZXBsYWNlKC9cXC8vZywgXCJcXFxcL1wiKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJykucmVwbGFjZSgvXFxuL2csIFwiXFxcXG5cIikucmVwbGFjZSgvXFxyL2csIFwiXFxcXHJcIikucmVwbGFjZSgvXFx0L2csIFwiXFxcXHRcIikucmVwbGFjZSgvXFxmL2csIFwiXFxcXGZcIik7XG4gICAgcmV0dXJuIGAke2VzY2FwZWRQYXJ0aWFsSnNvbn1gO1xuICB9XG59XG52YXIgX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCA9IFN5bWJvbChcbiAgXCJpbnRlcm5hbF9vcGVuYWlfZm5fbWVzc2FnZXNcIlxuKTtcbmZ1bmN0aW9uIGlzQ2hhdENvbXBsZXRpb25DaHVuayhkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJkZWx0YVwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIGlzQ29tcGxldGlvbihkYXRhKSB7XG4gIHJldHVybiBcImNob2ljZXNcIiBpbiBkYXRhICYmIGRhdGEuY2hvaWNlcyAmJiBkYXRhLmNob2ljZXNbMF0gJiYgXCJ0ZXh0XCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gT3BlbkFJU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IGNiID0gY2FsbGJhY2tzO1xuICBsZXQgc3RyZWFtO1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgc3RyZWFtID0gcmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZShzdHJlYW1hYmxlNShyZXMpKS5waXBlVGhyb3VnaChcbiAgICAgIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKFxuICAgICAgICAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkgfHwgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkgPyB7XG4gICAgICAgICAgLi4uY2IsXG4gICAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICAgIH0gOiB7XG4gICAgICAgICAgLi4uY2JcbiAgICAgICAgfVxuICAgICAgKVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtID0gQUlTdHJlYW0oXG4gICAgICByZXMsXG4gICAgICBwYXJzZU9wZW5BSVN0cmVhbSgpLFxuICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAuLi5jYixcbiAgICAgICAgb25GaW5hbDogdm9pZCAwXG4gICAgICB9IDoge1xuICAgICAgICAuLi5jYlxuICAgICAgfVxuICAgICk7XG4gIH1cbiAgaWYgKGNiICYmIChjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgY29uc3QgZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIgPSBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYik7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChmdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyKGNhbGxiYWNrcykge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gIGxldCBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gIGxldCBmdW5jdGlvbkNhbGxNZXNzYWdlcyA9IGNhbGxiYWNrc1tfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXSB8fCBbXTtcbiAgY29uc3QgZGVjb2RlID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGUoY2h1bmspO1xuICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICBjb25zdCBzaG91bGRIYW5kbGVBc0Z1bmN0aW9uID0gaXNGaXJzdENodW5rICYmIChtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcImZ1bmN0aW9uX2NhbGxcIjonKSB8fCBtZXNzYWdlLnN0YXJ0c1dpdGgoJ3tcInRvb2xfY2FsbHNcIjonKSk7XG4gICAgICBpZiAoc2hvdWxkSGFuZGxlQXNGdW5jdGlvbikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNGdW5jdGlvblN0cmVhbWluZ0luKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFnZ3JlZ2F0ZWRSZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFpc0ZpcnN0Q2h1bmsgJiYgaXNGdW5jdGlvblN0cmVhbWluZ0luICYmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkpIHtcbiAgICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5wYXJzZShhZ2dyZWdhdGVkUmVzcG9uc2UpO1xuICAgICAgICAgIGxldCBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzXG4gICAgICAgICAgXTtcbiAgICAgICAgICBsZXQgZnVuY3Rpb25SZXNwb25zZSA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgICAgaWYgKHBheWxvYWQuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmd1bWVudHNQYXlsb2FkID0gSlNPTi5wYXJzZShcbiAgICAgICAgICAgICAgcGF5bG9hZC5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50c1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgYXJndW1lbnRzOiBhcmd1bWVudHNQYXlsb2FkXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgIC4uLmZ1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbl9jYWxsOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGxcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogcGF5bG9hZC5mdW5jdGlvbl9jYWxsLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdClcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vbENhbGxzID0ge1xuICAgICAgICAgICAgICB0b29sczogW11cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wyIG9mIHBheWxvYWQudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICB0b29sQ2FsbHMudG9vbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBmdW5jOiB7XG4gICAgICAgICAgICAgICAgICBuYW1lOiB0b29sMi5mdW5jdGlvbi5uYW1lLFxuICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKHRvb2wyLmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbChcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xfY2FsbF9pZCwgZnVuY3Rpb25fbmFtZSwgdG9vbF9jYWxsX3Jlc3VsdCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZUluZGV4ID09PSAwID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBwYXlsb2FkLnRvb2xfY2FsbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0Yy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyBhbiBvYmplY3QgdG8gdGhlIHVzZXIsIGJ1dCBhcyB0aGUgQVBJIGV4cGVjdHMgYSBzdHJpbmcsIHdlIG5lZWQgdG8gc3RyaW5naWZ5IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsbGluZyBleHBlcmltZW50YWxfb25Ub29sQ2FsbDpcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnVuY3Rpb25SZXNwb25zZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/IFwiZnVuY3Rpb25fY2FsbFwiIDogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0byBwcmV2ZW50IGRvdWJsZS1lbmNvZGluZzpcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBmdW5jdGlvblJlc3BvbnNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBmdW5jdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIC4uLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIG9uU3RhcnQ6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB2b2lkIDA7XG4gICAgICAgICAgY29uc3Qgb3BlbkFJU3RyZWFtID0gT3BlbkFJU3RyZWFtKGZ1bmN0aW9uUmVzcG9uc2UsIHtcbiAgICAgICAgICAgIC4uLmZpbHRlcmVkQ2FsbGJhY2tzLFxuICAgICAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdOiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3RyZWFtcy9yZXBsaWNhdGUtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBSZXBsaWNhdGVTdHJlYW0ocmVzLCBjYiwgb3B0aW9ucykge1xuICB2YXIgX2E7XG4gIGNvbnN0IHVybCA9IChfYSA9IHJlcy51cmxzKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RyZWFtO1xuICBpZiAoIXVybCkge1xuICAgIGlmIChyZXMuZXJyb3IpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVzLmVycm9yKTtcbiAgICBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHN0cmVhbSBVUkwgaW4gUmVwbGljYXRlIHJlc3BvbnNlXCIpO1xuICB9XG4gIGNvbnN0IGV2ZW50U3RyZWFtID0gYXdhaXQgZmV0Y2godXJsLCB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIEFjY2VwdDogXCJ0ZXh0L2V2ZW50LXN0cmVhbVwiLFxuICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIEFJU3RyZWFtKGV2ZW50U3RyZWFtLCB2b2lkIDAsIGNiKS5waXBlVGhyb3VnaChcbiAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICApO1xufVxuXG4vLyBzaGFyZWQvcGFyc2UtY29tcGxleC1yZXNwb25zZS50c1xuZnVuY3Rpb24gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UobWVzc2FnZSwgYW5ub3RhdGlvbnMpIHtcbiAgaWYgKCFtZXNzYWdlIHx8ICFhbm5vdGF0aW9ucyB8fCAhYW5ub3RhdGlvbnMubGVuZ3RoKVxuICAgIHJldHVybiBtZXNzYWdlO1xuICByZXR1cm4geyAuLi5tZXNzYWdlLCBhbm5vdGF0aW9uczogWy4uLmFubm90YXRpb25zXSB9O1xufVxuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICByZWFkZXIsXG4gIGFib3J0Q29udHJvbGxlclJlZixcbiAgdXBkYXRlLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkLFxuICBnZXRDdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG59KSB7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGNvbnN0IHByZWZpeE1hcCA9IHtcbiAgICBkYXRhOiBbXVxuICB9O1xuICBsZXQgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IHZvaWQgMDtcbiAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgaXNBYm9ydGVkOiAoKSA9PiAoYWJvcnRDb250cm9sbGVyUmVmID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkgPT09IG51bGxcbiAgfSkpIHtcbiAgICBpZiAodHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICAgIGlmIChwcmVmaXhNYXBbXCJ0ZXh0XCJdKSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgLi4ucHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgICBjb250ZW50OiAocHJlZml4TWFwW1widGV4dFwiXS5jb250ZW50IHx8IFwiXCIpICsgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0gPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uX2NhbGxcIikge1xuICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgfVxuICAgIGxldCB0b29sQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgcHJlZml4TWFwW1widG9vbF9jYWxsc1wiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgcHJlZml4TWFwW1wiZGF0YVwiXS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VfYW5ub3RhdGlvbnMpIHtcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdLFxuICAgICAgICBtZXNzYWdlX2Fubm90YXRpb25zXG4gICAgICApO1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl0sXG4gICAgICAgIG1lc3NhZ2VfYW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgbWVzc2FnZV9hbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VfYW5ub3RhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VfYW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBtZXNzYWdlUHJlZml4S2V5cyA9IFtcbiAgICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgIFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgICBcInRvb2xfY2FsbHNcIlxuICAgICAgXTtcbiAgICAgIG1lc3NhZ2VQcmVmaXhLZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAocHJlZml4TWFwW2tleV0pIHtcbiAgICAgICAgICBwcmVmaXhNYXBba2V5XS5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlX2Fubm90YXRpb25zXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCB0b29sQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VfYW5ub3RhdGlvbnMpXG4gICAgfSkpO1xuICAgIHVwZGF0ZShtZXJnZWQsIFsuLi5wcmVmaXhNYXBbXCJkYXRhXCJdXSk7XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHByZWZpeE1hcCk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxsc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgIGRhdGE6IHByZWZpeE1hcC5kYXRhXG4gIH07XG59XG5cbi8vIHN0cmVhbXMvc3RyZWFtaW5nLXJlYWN0LXJlc3BvbnNlLnRzXG52YXIgZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHJlcywgb3B0aW9ucykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgbGV0IHJlc29sdmVGdW5jID0gKCkgPT4ge1xuICAgIH07XG4gICAgbGV0IG5leHQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgcmVzb2x2ZUZ1bmMgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IHByb2Nlc3NlZFN0cmVhbSA9IChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpICE9IG51bGwgPyByZXMucGlwZVRocm91Z2goKF9hID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RyZWFtKSA6IHJlcztcbiAgICBsZXQgbGFzdFBheWxvYWQgPSB2b2lkIDA7XG4gICAgcGFyc2VDb21wbGV4UmVzcG9uc2Uoe1xuICAgICAgcmVhZGVyOiBwcm9jZXNzZWRTdHJlYW0uZ2V0UmVhZGVyKCksXG4gICAgICB1cGRhdGU6IChtZXJnZWQsIGRhdGEpID0+IHtcbiAgICAgICAgdmFyIF9hMiwgX2IyLCBfYztcbiAgICAgICAgY29uc3QgY29udGVudCA9IChfYjIgPSAoX2EyID0gbWVyZ2VkWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2EyLmNvbnRlbnQpICE9IG51bGwgPyBfYjIgOiBcIlwiO1xuICAgICAgICBjb25zdCB1aSA9ICgoX2MgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnVpKSA9PSBudWxsID8gdm9pZCAwIDogX2MuY2FsbChvcHRpb25zLCB7IGNvbnRlbnQsIGRhdGEgfSkpIHx8IGNvbnRlbnQ7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7IHVpLCBjb250ZW50IH07XG4gICAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmVGdW5jO1xuICAgICAgICBjb25zdCBuZXh0Um93ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICByZXNvbHZlRnVuYyA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgICAgICByZXNvbHZlUHJldmlvdXMoe1xuICAgICAgICAgIG5leHQ6IG5leHRSb3csXG4gICAgICAgICAgLi4ucGF5bG9hZFxuICAgICAgICB9KTtcbiAgICAgICAgbGFzdFBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgfSxcbiAgICAgIGdlbmVyYXRlSWQ6IChfYiA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZ2VuZXJhdGVJZCkgIT0gbnVsbCA/IF9iIDogZ2VuZXJhdGVJZCxcbiAgICAgIG9uRmluaXNoOiAoKSA9PiB7XG4gICAgICAgIGlmIChsYXN0UGF5bG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgcmVzb2x2ZUZ1bmMoe1xuICAgICAgICAgICAgbmV4dDogbnVsbCxcbiAgICAgICAgICAgIC4uLmxhc3RQYXlsb2FkXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufTtcblxuLy8gc3RyZWFtcy9zdHJlYW1pbmctdGV4dC1yZXNwb25zZS50c1xudmFyIFN0cmVhbWluZ1RleHRSZXNwb25zZSA9IGNsYXNzIGV4dGVuZHMgUmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvcihyZXMsIGluaXQsIGRhdGEpIHtcbiAgICBsZXQgcHJvY2Vzc2VkU3RyZWFtID0gcmVzO1xuICAgIGlmIChkYXRhKSB7XG4gICAgICBwcm9jZXNzZWRTdHJlYW0gPSByZXMucGlwZVRocm91Z2goZGF0YS5zdHJlYW0pO1xuICAgIH1cbiAgICBzdXBlcihwcm9jZXNzZWRTdHJlYW0sIHtcbiAgICAgIC4uLmluaXQsXG4gICAgICBzdGF0dXM6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gc3RyZWFtVG9SZXNwb25zZShyZXMsIHJlc3BvbnNlLCBpbml0KSB7XG4gIHJlc3BvbnNlLndyaXRlSGVhZCgoaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpIHx8IDIwMCwge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgIC4uLmluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVyc1xuICB9KTtcbiAgY29uc3QgcmVhZGVyID0gcmVzLmdldFJlYWRlcigpO1xuICBmdW5jdGlvbiByZWFkKCkge1xuICAgIHJlYWRlci5yZWFkKCkudGhlbigoeyBkb25lLCB2YWx1ZSB9KSA9PiB7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICByZXNwb25zZS5lbmQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmVzcG9uc2Uud3JpdGUodmFsdWUpO1xuICAgICAgcmVhZCgpO1xuICAgIH0pO1xuICB9XG4gIHJlYWQoKTtcbn1cbmV4cG9ydCB7XG4gIEFJU3RyZWFtLFxuICBBUElDYWxsRXJyb3IyIGFzIEFQSUNhbGxFcnJvcixcbiAgQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtLFxuICBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtLFxuICBBV1NCZWRyb2NrQ29oZXJlU3RyZWFtLFxuICBBV1NCZWRyb2NrTGxhbWEyU3RyZWFtLFxuICBBV1NCZWRyb2NrU3RyZWFtLFxuICBBbnRocm9waWNTdHJlYW0sXG4gIEFzc2lzdGFudFJlc3BvbnNlLFxuICBDb2hlcmVTdHJlYW0sXG4gIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IsXG4gIEdlbmVyYXRlT2JqZWN0UmVzdWx0LFxuICBHZW5lcmF0ZVRleHRSZXN1bHQsXG4gIEdvb2dsZUdlbmVyYXRpdmVBSVN0cmVhbSxcbiAgSHVnZ2luZ0ZhY2VTdHJlYW0sXG4gIElua2VlcFN0cmVhbSxcbiAgSW52YWxpZEFyZ3VtZW50RXJyb3IyIGFzIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcjIgYXMgSW52YWxpZERhdGFDb250ZW50RXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcjIgYXMgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IyIGFzIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMYW5nQ2hhaW5TdHJlYW0sXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTWlzdHJhbFN0cmVhbSxcbiAgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcjIgYXMgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoVG9vbEVycm9yMyBhcyBOb1N1Y2hUb29sRXJyb3IsXG4gIE9wZW5BSVN0cmVhbSxcbiAgUmVwbGljYXRlU3RyZWFtLFxuICBSZXRyeUVycm9yMiBhcyBSZXRyeUVycm9yLFxuICBTdHJlYW1EYXRhLFxuICBTdHJlYW1PYmplY3RSZXN1bHQsXG4gIFN0cmVhbVRleHRSZXN1bHQsXG4gIFN0cmVhbWluZ1RleHRSZXNwb25zZSxcbiAgVG9vbENhbGxQYXJzZUVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgVW5zdXBwb3J0ZWRKU09OU2NoZW1hRXJyb3IsXG4gIGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nLFxuICBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXksXG4gIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyLFxuICBjcmVhdGVDaHVua0RlY29kZXIsXG4gIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIsXG4gIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcixcbiAgZXhwZXJpbWVudGFsX0Fzc2lzdGFudFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfU3RyZWFtRGF0YSxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbWluZ1JlYWN0UmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZU9iamVjdCxcbiAgZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCxcbiAgZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCxcbiAgZXhwZXJpbWVudGFsX3N0cmVhbVRleHQsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGlzU3RyZWFtU3RyaW5nRXF1YWxUb1R5cGUsXG4gIGdlbmVyYXRlSWQgYXMgbmFub2lkLFxuICBwYXJzZVN0cmVhbVBhcnQsXG4gIHJlYWREYXRhU3RyZWFtLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBzdHJlYW1PYmplY3QsXG4gIHN0cmVhbVRleHQsXG4gIHN0cmVhbVRvUmVzcG9uc2UsXG4gIHRvb2wsXG4gIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ai/node_modules/nanoid/non-secure/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),\n/* harmony export */   nanoid: () => (/* binding */ nanoid)\n/* harmony export */ });\nlet urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL0BkZXZpYXMta2l0LXByby9uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvYWkvbm9kZV9tb2R1bGVzL25hbm9pZC9ub24tc2VjdXJlL2luZGV4LmpzPzQzN2YiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHVybEFscGhhYmV0ID1cbiAgJ3VzZWFuZG9tLTI2VDE5ODM0MFBYNzVweEpBQ0tWRVJZTUlOREJVU0hXT0xGX0dRWmJmZ2hqa2xxdnd5enJpY3QnXG5sZXQgY3VzdG9tQWxwaGFiZXQgPSAoYWxwaGFiZXQsIGRlZmF1bHRTaXplID0gMjEpID0+IHtcbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIGxldCBpID0gc2l6ZVxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGlkICs9IGFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogYWxwaGFiZXQubGVuZ3RoKSB8IDBdXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9XG59XG5sZXQgbmFub2lkID0gKHNpemUgPSAyMSkgPT4ge1xuICBsZXQgaWQgPSAnJ1xuICBsZXQgaSA9IHNpemVcbiAgd2hpbGUgKGktLSkge1xuICAgIGlkICs9IHVybEFscGhhYmV0WyhNYXRoLnJhbmRvbSgpICogNjQpIHwgMF1cbiAgfVxuICByZXR1cm4gaWRcbn1cbmV4cG9ydCB7IG5hbm9pZCwgY3VzdG9tQWxwaGFiZXQgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/node_modules/nanoid/non-secure/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-server.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("var react__WEBPACK_IMPORTED_MODULE_3___namespace_cache;\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $$ACTION_0: () => (/* binding */ $$ACTION_0),\n/* harmony export */   createAI: () => (/* binding */ createAI),\n/* harmony export */   createStreamableUI: () => (/* binding */ createStreamableUI),\n/* harmony export */   createStreamableValue: () => (/* binding */ createStreamableValue),\n/* harmony export */   getAIState: () => (/* binding */ getAIState),\n/* harmony export */   getMutableAIState: () => (/* binding */ getMutableAIState),\n/* harmony export */   render: () => (/* binding */ render),\n/* harmony export */   streamUI: () => (/* binding */ streamUI)\n/* harmony export */ });\n/* harmony import */ var private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! private-next-rsc-server-reference */ \"(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/server-reference.js\");\n/* harmony import */ var private_next_rsc_action_encryption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! private-next-rsc-action-encryption */ \"(rsc)/./node_modules/next/dist/server/app-render/action-encryption.js\");\n/* harmony import */ var async_hooks__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! async_hooks */ \"async_hooks\");\n/* harmony import */ var jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! jsondiffpatch */ \"(rsc)/./node_modules/jsondiffpatch/lib/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react-jsx-runtime.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\n/* harmony import */ var _rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./rsc-shared.mjs */ \"(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs\");\n// rsc/ai-state.tsx\n/* __next_internal_action_entry_do_not_use__ {\"89fe7f9da752fbd515cab5e54df6aeb086a1b130\":\"$$ACTION_0\"} */ \n\n\n\n// rsc/utils.tsx\n\n\nfunction createResolvablePromise() {\n    let resolve, reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\nvar R = [\n    async ({ c, // current\n    n })=>{\n        const chunk = await n;\n        if (chunk.done) {\n            return chunk.value;\n        }\n        if (chunk.append) {\n            return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.Fragment, {\n                children: [\n                    c,\n                    /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n                        fallback: chunk.value,\n                        children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                            c: chunk.value,\n                            n: chunk.next\n                        })\n                    })\n                ]\n            });\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: chunk.value,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: chunk.value,\n                n: chunk.next\n            })\n        });\n    }\n][0];\nfunction createSuspensedChunk(initialValue) {\n    const { promise, resolve, reject } = createResolvablePromise();\n    return {\n        row: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_3__.Suspense, {\n            fallback: initialValue,\n            children: /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(R, {\n                c: initialValue,\n                n: promise\n            })\n        }),\n        resolve,\n        reject\n    };\n}\nvar isFunction = (x)=>typeof x === \"function\";\nvar consumeStream = async (stream)=>{\n    const reader = stream.getReader();\n    while(true){\n        const { done } = await reader.read();\n        if (done) break;\n    }\n};\n// rsc/ai-state.tsx\nvar asyncAIStateStorage = new async_hooks__WEBPACK_IMPORTED_MODULE_2__.AsyncLocalStorage();\nfunction getAIStateStoreOrThrow(message) {\n    const store = asyncAIStateStorage.getStore();\n    if (!store) {\n        throw new Error(message);\n    }\n    return store;\n}\nfunction withAIState({ state: state1, options }, fn) {\n    return asyncAIStateStorage.run({\n        currentState: state1,\n        originalState: state1,\n        sealed: false,\n        options\n    }, fn);\n}\nfunction getAIStateDeltaPromise() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    return store.mutationDeltaPromise;\n}\nfunction sealMutableAIState() {\n    const store = getAIStateStoreOrThrow(\"Internal error occurred.\");\n    store.sealed = true;\n}\nfunction getAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getAIState` must be called within an AI Action.\");\n    if (args.length > 0) {\n        const key = args[0];\n        if (typeof store.currentState !== \"object\") {\n            throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n        }\n        return store.currentState[key];\n    }\n    return store.currentState;\n}\nfunction getMutableAIState(...args) {\n    const store = getAIStateStoreOrThrow(\"`getMutableAIState` must be called within an AI Action.\");\n    if (store.sealed) {\n        throw new Error(\"`getMutableAIState` must be called before returning from an AI Action. Please move it to the top level of the Action's function body.\");\n    }\n    if (!store.mutationDeltaPromise) {\n        const { promise, resolve } = createResolvablePromise();\n        store.mutationDeltaPromise = promise;\n        store.mutationDeltaResolve = resolve;\n    }\n    function doUpdate(newState, done) {\n        var _a, _b;\n        if (args.length > 0) {\n            if (typeof store.currentState !== \"object\") {\n                const key = args[0];\n                throw new Error(`You can't modify the \"${String(key)}\" field of the AI state because it's not an object.`);\n            }\n        }\n        if (isFunction(newState)) {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState(store.currentState[args[0]]);\n            } else {\n                store.currentState = newState(store.currentState);\n            }\n        } else {\n            if (args.length > 0) {\n                store.currentState[args[0]] = newState;\n            } else {\n                store.currentState = newState;\n            }\n        }\n        (_b = (_a = store.options).onSetAIState) == null ? void 0 : _b.call(_a, {\n            key: args.length > 0 ? args[0] : void 0,\n            state: store.currentState,\n            done\n        });\n    }\n    const mutableState = {\n        get: ()=>{\n            if (args.length > 0) {\n                const key = args[0];\n                if (typeof store.currentState !== \"object\") {\n                    throw new Error(`You can't get the \"${String(key)}\" field from the AI state because it's not an object.`);\n                }\n                return store.currentState[key];\n            }\n            return store.currentState;\n        },\n        update: function update(newAIState) {\n            doUpdate(newAIState, false);\n        },\n        done: function done(...doneArgs) {\n            if (doneArgs.length > 0) {\n                doUpdate(doneArgs[0], true);\n            }\n            const delta = jsondiffpatch__WEBPACK_IMPORTED_MODULE_5__.diff(store.originalState, store.currentState);\n            store.mutationDeltaResolve(delta);\n        }\n    };\n    return mutableState;\n}\n// rsc/streamable.tsx\n\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.convertBase64ToUint8Array)(content);\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidDataContentError({\n        content\n    });\n}\n// core/prompt/convert-to-language-model-prompt.ts\nfunction convertToLanguageModelPrompt(prompt) {\n    const languageModelMessages = [];\n    if (prompt.system != null) {\n        languageModelMessages.push({\n            role: \"system\",\n            content: prompt.system\n        });\n    }\n    switch(prompt.type){\n        case \"prompt\":\n            {\n                languageModelMessages.push({\n                    role: \"user\",\n                    content: [\n                        {\n                            type: \"text\",\n                            text: prompt.prompt\n                        }\n                    ]\n                });\n                break;\n            }\n        case \"messages\":\n            {\n                languageModelMessages.push(...prompt.messages.map((message)=>{\n                    switch(message.role){\n                        case \"user\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"user\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"user\",\n                                    content: message.content.map((part)=>{\n                                        var _a;\n                                        switch(part.type){\n                                            case \"text\":\n                                                {\n                                                    return part;\n                                                }\n                                            case \"image\":\n                                                {\n                                                    if (part.image instanceof URL) {\n                                                        return {\n                                                            type: \"image\",\n                                                            image: part.image,\n                                                            mimeType: part.mimeType\n                                                        };\n                                                    }\n                                                    const imageUint8 = convertDataContentToUint8Array(part.image);\n                                                    return {\n                                                        type: \"image\",\n                                                        image: imageUint8,\n                                                        mimeType: (_a = part.mimeType) != null ? _a : detectImageMimeType(imageUint8)\n                                                    };\n                                                }\n                                        }\n                                    })\n                                };\n                            }\n                        case \"assistant\":\n                            {\n                                if (typeof message.content === \"string\") {\n                                    return {\n                                        role: \"assistant\",\n                                        content: [\n                                            {\n                                                type: \"text\",\n                                                text: message.content\n                                            }\n                                        ]\n                                    };\n                                }\n                                return {\n                                    role: \"assistant\",\n                                    content: message.content\n                                };\n                            }\n                        case \"tool\":\n                            {\n                                return message;\n                            }\n                    }\n                }));\n                break;\n            }\n        default:\n            {\n                const _exhaustiveCheck = prompt;\n                throw new Error(`Unsupported prompt type: ${_exhaustiveCheck}`);\n            }\n    }\n    return languageModelMessages;\n}\n// core/prompt/get-validated-prompt.ts\n\nfunction getValidatedPrompt(prompt) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    return prompt.prompt != null ? {\n        type: \"prompt\",\n        prompt: prompt.prompt,\n        messages: void 0,\n        system: prompt.system\n    } : {\n        type: \"messages\",\n        prompt: void 0,\n        messages: prompt.messages,\n        // only possible case bc of checks above\n        system: prompt.system\n    };\n}\n// core/prompt/prepare-call-settings.ts\n\nfunction prepareCallSettings({ maxTokens, temperature, topP, presencePenalty, frequencyPenalty, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        presencePenalty,\n        frequencyPenalty,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/util/convert-zod-to-json-schema.ts\n\nfunction convertZodToJSONSchema(zodSchema) {\n    return (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(zodSchema);\n}\n// core/util/retry-with-exponential-backoff.ts\n\n\n// core/util/delay.ts\nasync function delay(delayInMs) {\n    return new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// core/util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// shared/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallStreamPart,\n    messageAnnotationsStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n    const streamPart = streamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// shared/utils.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_9__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a;\n            await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode(formatStreamPart(\"text\", message)));\n        }\n    });\n}\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a = choice.delta) == null ? void 0 : _a.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a = json.choices[0]) == null ? void 0 : _a.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = createChunkDecoder();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool.function.name,\n                                    arguments: JSON.parse(tool.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode(formatStreamPart(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// rsc/constants.ts\nvar STREAMABLE_VALUE_TYPE = Symbol.for(\"ui.streamable.value\");\nvar DEV_DEFAULT_STREAMABLE_WARNING_TIME = 15 * 1e3;\n// rsc/streamable.tsx\nfunction createStreamableUI(initialValue) {\n    let currentValue = initialValue;\n    let closed = false;\n    let { row, resolve, reject } = createSuspensedChunk(initialValue);\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": UI stream is already closed.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    return {\n        /**\n     * The value of the streamable UI. This can be returned from a Server Action and received by the client.\n     */ value: row,\n        /**\n     * This method updates the current UI node. It takes a new UI node and replaces the old one.\n     */ update (value) {\n            assertStream(\".update()\");\n            if (value === currentValue) {\n                warnUnclosedStream();\n                return;\n            }\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value: currentValue,\n                done: false,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to append a new UI node to the end of the old one.\n     * Once appended a new UI node, the previous UI node cannot be updated anymore.\n     *\n     * @example\n     * ```jsx\n     * const ui = createStreamableUI(<div>hello</div>)\n     * ui.append(<div>world</div>)\n     *\n     * // The UI node will be:\n     * // <>\n     * //   <div>hello</div>\n     * //   <div>world</div>\n     * // </>\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            const resolvable = createResolvablePromise();\n            currentValue = value;\n            resolve({\n                value,\n                done: false,\n                append: true,\n                next: resolvable.promise\n            });\n            resolve = resolvable.resolve;\n            reject = resolvable.reject;\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to signal that there is an error in the UI stream.\n     * It will be thrown on the client side and caught by the nearest error boundary component.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            reject(error);\n        },\n        /**\n     * This method marks the UI node as finalized. You can either call it without any parameters or with a new UI node as the final state.\n     * Once called, the UI node cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            if (args.length) {\n                resolve({\n                    value: args[0],\n                    done: true\n                });\n                return;\n            }\n            resolve({\n                value: currentValue,\n                done: true\n            });\n        }\n    };\n}\nvar STREAMABLE_VALUE_INTERNAL_LOCK = Symbol(\"streamable.value.lock\");\nfunction createStreamableValue(initialValue) {\n    const isReadableStream = initialValue instanceof ReadableStream || typeof initialValue === \"object\" && initialValue !== null && \"getReader\" in initialValue && typeof initialValue.getReader === \"function\" && \"locked\" in initialValue && typeof initialValue.locked === \"boolean\";\n    if (!isReadableStream) {\n        return createStreamableValueImpl(initialValue);\n    }\n    const streamableValue = createStreamableValueImpl();\n    streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n    (async ()=>{\n        try {\n            const reader = initialValue.getReader();\n            while(true){\n                const { value, done } = await reader.read();\n                if (done) {\n                    break;\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n                if (typeof value === \"string\") {\n                    streamableValue.append(value);\n                } else {\n                    streamableValue.update(value);\n                }\n                streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = true;\n            }\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.done();\n        } catch (e) {\n            streamableValue[STREAMABLE_VALUE_INTERNAL_LOCK] = false;\n            streamableValue.error(e);\n        }\n    })();\n    return streamableValue;\n}\nfunction createStreamableValueImpl(initialValue) {\n    let closed = false;\n    let locked = false;\n    let resolvable = createResolvablePromise();\n    let currentValue = initialValue;\n    let currentError;\n    let currentPromise = resolvable.promise;\n    let currentPatchValue;\n    function assertStream(method) {\n        if (closed) {\n            throw new Error(method + \": Value stream is already closed.\");\n        }\n        if (locked) {\n            throw new Error(method + \": Value stream is locked and cannot be updated.\");\n        }\n    }\n    let warningTimeout;\n    function warnUnclosedStream() {\n        if (true) {\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            warningTimeout = setTimeout(()=>{\n                console.warn(\"The streamable UI has been slow to update. This may be a bug or a performance issue or you forgot to call `.done()`.\");\n            }, DEV_DEFAULT_STREAMABLE_WARNING_TIME);\n        }\n    }\n    warnUnclosedStream();\n    function createWrapped(initialChunk) {\n        let init;\n        if (currentError !== void 0) {\n            init = {\n                error: currentError\n            };\n        } else {\n            if (currentPatchValue && !initialChunk) {\n                init = {\n                    diff: currentPatchValue\n                };\n            } else {\n                init = {\n                    curr: currentValue\n                };\n            }\n        }\n        if (currentPromise) {\n            init.next = currentPromise;\n        }\n        if (initialChunk) {\n            init.type = STREAMABLE_VALUE_TYPE;\n        }\n        return init;\n    }\n    function updateValueStates(value) {\n        currentPatchValue = void 0;\n        if (typeof value === \"string\") {\n            if (typeof currentValue === \"string\") {\n                if (value.startsWith(currentValue)) {\n                    currentPatchValue = [\n                        0,\n                        value.slice(currentValue.length)\n                    ];\n                }\n            }\n        }\n        currentValue = value;\n    }\n    return {\n        /**\n     * @internal This is an internal lock to prevent the value from being\n     * updated by the user.\n     */ set [STREAMABLE_VALUE_INTERNAL_LOCK] (state){\n            locked = state;\n        },\n        /**\n     * The value of the streamable. This can be returned from a Server Action and\n     * received by the client. To read the streamed values, use the\n     * `readStreamableValue` or `useStreamableValue` APIs.\n     */ get value () {\n            return createWrapped(true);\n        },\n        /**\n     * This method updates the current value with a new one.\n     */ update (value) {\n            assertStream(\".update()\");\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            updateValueStates(value);\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to append a delta string to the current value. It\n     * requires the current value of the streamable to be a string.\n     *\n     * @example\n     * ```jsx\n     * const streamable = createStreamableValue('hello');\n     * streamable.append(' world');\n     *\n     * // The value will be 'hello world'\n     * ```\n     */ append (value) {\n            assertStream(\".append()\");\n            if (typeof currentValue !== \"string\" && typeof currentValue !== \"undefined\") {\n                throw new Error(`.append(): The current value is not a string. Received: ${typeof currentValue}`);\n            }\n            if (typeof value !== \"string\") {\n                throw new Error(`.append(): The value is not a string. Received: ${typeof value}`);\n            }\n            const resolvePrevious = resolvable.resolve;\n            resolvable = createResolvablePromise();\n            if (typeof currentValue === \"string\") {\n                currentPatchValue = [\n                    0,\n                    value\n                ];\n                currentValue = currentValue + value;\n            } else {\n                currentPatchValue = void 0;\n                currentValue = value;\n            }\n            currentPromise = resolvable.promise;\n            resolvePrevious(createWrapped());\n            warnUnclosedStream();\n        },\n        /**\n     * This method is used to signal that there is an error in the value stream.\n     * It will be thrown on the client side when consumed via\n     * `readStreamableValue` or `useStreamableValue`.\n     */ error (error) {\n            assertStream(\".error()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentError = error;\n            currentPromise = void 0;\n            resolvable.resolve({\n                error\n            });\n        },\n        /**\n     * This method marks the value as finalized. You can either call it without\n     * any parameters or with a new value as the final state.\n     * Once called, the value cannot be updated or appended anymore.\n     *\n     * This method is always **required** to be called, otherwise the response\n     * will be stuck in a loading state.\n     */ done (...args) {\n            assertStream(\".done()\");\n            if (warningTimeout) {\n                clearTimeout(warningTimeout);\n            }\n            closed = true;\n            currentPromise = void 0;\n            if (args.length) {\n                updateValueStates(args[0]);\n                resolvable.resolve(createWrapped());\n                return;\n            }\n            resolvable.resolve({});\n        }\n    };\n}\nfunction render(options) {\n    const ui = createStreamableUI(options.initial);\n    const text = options.text ? options.text : ({ content })=>content;\n    const functions = options.functions ? Object.entries(options.functions).map(([name, { description, parameters }])=>{\n        return {\n            name,\n            description,\n            parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n        };\n    }) : void 0;\n    const tools = options.tools ? Object.entries(options.tools).map(([name, { description, parameters }])=>{\n        return {\n            type: \"function\",\n            function: {\n                name,\n                description,\n                parameters: (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(parameters)\n            }\n        };\n    }) : void 0;\n    if (functions && tools) {\n        throw new Error(\"You can't have both functions and tools defined. Please choose one or the other.\");\n    }\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    (async ()=>{\n        let hasFunction = false;\n        let content = \"\";\n        consumeStream(OpenAIStream(await options.provider.chat.completions.create({\n            model: options.model,\n            messages: options.messages,\n            temperature: options.temperature,\n            stream: true,\n            ...functions ? {\n                functions\n            } : {},\n            ...tools ? {\n                tools\n            } : {}\n        }), {\n            ...functions ? {\n                async experimental_onFunctionCall (functionCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    handleRender(functionCallPayload.arguments, (_b = (_a = options.functions) == null ? void 0 : _a[functionCallPayload.name]) == null ? void 0 : _b.render, ui);\n                }\n            } : {},\n            ...tools ? {\n                async experimental_onToolCall (toolCallPayload) {\n                    var _a, _b;\n                    hasFunction = true;\n                    for (const tool of toolCallPayload.tools){\n                        handleRender(tool.func.arguments, (_b = (_a = options.tools) == null ? void 0 : _a[tool.func.name]) == null ? void 0 : _b.render, ui);\n                    }\n                }\n            } : {},\n            onText (chunk) {\n                content += chunk;\n                handleRender({\n                    content,\n                    done: false,\n                    delta: chunk\n                }, text, ui);\n            },\n            async onFinal () {\n                if (hasFunction) {\n                    await finished;\n                    ui.done();\n                    return;\n                }\n                handleRender({\n                    content,\n                    done: true\n                }, text, ui);\n                await finished;\n                ui.done();\n            }\n        }));\n    })();\n    return ui.value;\n}\n// rsc/stream-ui/stream-ui.tsx\n\n\nvar defaultTextRenderer = ({ content })=>content;\nasync function streamUI({ model, tools, system, prompt, messages, maxRetries, abortSignal, initial, text, ...settings }) {\n    if (typeof model === \"string\") {\n        throw new Error(\"`model` cannot be a string in `streamUI`. Use the actual model instance instead.\");\n    }\n    if (\"functions\" in settings) {\n        throw new Error(\"`functions` is not supported in `streamUI`, use `tools` instead.\");\n    }\n    if (\"provider\" in settings) {\n        throw new Error(\"`provider` is no longer needed in `streamUI`. Use `model` instead.\");\n    }\n    if (tools) {\n        for (const [name, tool] of Object.entries(tools)){\n            if (\"render\" in tool) {\n                throw new Error(\"Tool definition in `streamUI` should not have `render` property. Use `generate` instead. Found in tool: \" + name);\n            }\n        }\n    }\n    const ui = createStreamableUI(initial);\n    const textRender = text || defaultTextRenderer;\n    let finished;\n    async function handleRender(args, renderer, res) {\n        if (!renderer) return;\n        const resolvable = createResolvablePromise();\n        if (finished) {\n            finished = finished.then(()=>resolvable.promise);\n        } else {\n            finished = resolvable.promise;\n        }\n        const value = renderer(...args);\n        if (value instanceof Promise || value && typeof value === \"object\" && \"then\" in value && typeof value.then === \"function\") {\n            const node = await value;\n            res.update(node);\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.asyncIterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = await it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else if (value && typeof value === \"object\" && Symbol.iterator in value) {\n            const it = value;\n            while(true){\n                const { done, value: value2 } = it.next();\n                res.update(value2);\n                if (done) break;\n            }\n            resolvable.resolve(void 0);\n        } else {\n            res.update(value);\n            resolvable.resolve(void 0);\n        }\n    }\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    const validatedPrompt = getValidatedPrompt({\n        system,\n        prompt,\n        messages\n    });\n    const result = await retry(()=>model.doStream({\n            mode: {\n                type: \"regular\",\n                tools: tools == null ? void 0 : Object.entries(tools).map(([name, tool])=>({\n                        type: \"function\",\n                        name,\n                        description: tool.description,\n                        parameters: convertZodToJSONSchema(tool.parameters)\n                    }))\n            },\n            ...prepareCallSettings(settings),\n            inputFormat: validatedPrompt.type,\n            prompt: convertToLanguageModelPrompt(validatedPrompt),\n            abortSignal\n        }));\n    const [stream, forkedStream] = result.stream.tee();\n    (async ()=>{\n        try {\n            let content = \"\";\n            let hasToolCall = false;\n            const reader = forkedStream.getReader();\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                switch(value.type){\n                    case \"text-delta\":\n                        {\n                            content += value.textDelta;\n                            handleRender([\n                                {\n                                    content,\n                                    done: false,\n                                    delta: value.textDelta\n                                }\n                            ], textRender, ui);\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            hasToolCall = true;\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            const toolName = value.toolName;\n                            if (!tools) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName\n                                });\n                            }\n                            const tool = tools[toolName];\n                            if (!tool) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.NoSuchToolError({\n                                    toolName,\n                                    availableTools: Object.keys(tools)\n                                });\n                            }\n                            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_7__.safeParseJSON)({\n                                text: value.args,\n                                schema: tool.parameters\n                            });\n                            if (parseResult.success === false) {\n                                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_8__.InvalidToolArgumentsError({\n                                    toolName,\n                                    toolArgs: value.args,\n                                    cause: parseResult.error\n                                });\n                            }\n                            handleRender([\n                                parseResult.value,\n                                {\n                                    toolName,\n                                    toolCallId: value.toolCallId\n                                }\n                            ], tool.generate, ui);\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            throw value.error;\n                        }\n                    case \"finish\":\n                        {}\n                }\n            }\n            if (hasToolCall) {\n                await finished;\n                ui.done();\n            } else {\n                handleRender([\n                    {\n                        content,\n                        done: true\n                    }\n                ], textRender, ui);\n                await finished;\n                ui.done();\n            }\n        } catch (error) {\n            ui.error(error);\n        }\n    })();\n    return {\n        ...result,\n        stream,\n        value: ui.value\n    };\n}\n// rsc/provider.tsx\n\n\n\nvar innerAction = (0,private_next_rsc_server_reference__WEBPACK_IMPORTED_MODULE_0__.registerServerReference)(\"89fe7f9da752fbd515cab5e54df6aeb086a1b130\", $$ACTION_0);\nasync function $$ACTION_0({ action, options }, state1, ...args) {\n    return await withAIState({\n        state: state1,\n        options\n    }, async ()=>{\n        const result = await action(...args);\n        sealMutableAIState();\n        return [\n            getAIStateDeltaPromise(),\n            result\n        ];\n    });\n}\nfunction wrapAction(action, options) {\n    return innerAction.bind(null, {\n        action,\n        options\n    });\n}\nfunction createAI({ actions, initialAIState, initialUIState, onSetAIState, onGetUIState }) {\n    const wrappedActions = {};\n    for(const name in actions){\n        wrappedActions[name] = wrapAction(actions[name], {\n            onSetAIState\n        });\n    }\n    const wrappedSyncUIState = onGetUIState ? wrapAction(onGetUIState, {}) : void 0;\n    const AI = async (props)=>{\n        var _a, _b;\n        if (\"useState\" in /*#__PURE__*/ (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache || (react__WEBPACK_IMPORTED_MODULE_3___namespace_cache = __webpack_require__.t(react__WEBPACK_IMPORTED_MODULE_3__, 2)))) {\n            throw new Error(\"This component can only be used inside Server Components.\");\n        }\n        let uiState = (_a = props.initialUIState) != null ? _a : initialUIState;\n        let aiState = (_b = props.initialAIState) != null ? _b : initialAIState;\n        let aiStateDelta = void 0;\n        if (wrappedSyncUIState) {\n            const [newAIStateDelta, newUIState] = await wrappedSyncUIState(aiState);\n            if (newUIState !== void 0) {\n                aiStateDelta = newAIStateDelta;\n                uiState = newUIState;\n            }\n        }\n        return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_rsc_shared_mjs__WEBPACK_IMPORTED_MODULE_10__.InternalAIProvider, {\n            wrappedActions,\n            wrappedSyncUIState,\n            initialUIState: uiState,\n            initialAIState: aiState,\n            initialAIStatePatch: aiStateDelta,\n            children: props.children\n        });\n    };\n    return AI;\n}\n //# sourceMappingURL=rsc-server.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvcnNjL2Rpc3QvcnNjLXNlcnZlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxtQkFBbUI7OztBQUM2QjtBQUNEO0FBRS9DLGdCQUFnQjtBQUNpQjtBQUN1QjtBQUN4RCxTQUFTTTtJQUNQLElBQUlDLFNBQVNDO0lBQ2IsTUFBTUMsVUFBVSxJQUFJQyxRQUFRLENBQUNDLEtBQUtDO1FBQ2hDTCxVQUFVSTtRQUNWSCxTQUFTSTtJQUNYO0lBQ0EsT0FBTztRQUNMSDtRQUNBRjtRQUNBQztJQUNGO0FBQ0Y7QUFDQSxJQUFJSyxJQUFJO0lBQ04sT0FBTyxFQUNMQyxDQUFDLEVBQ0QsVUFBVTtJQUNWQyxDQUFDLEVBRUY7UUFDQyxNQUFNQyxRQUFRLE1BQU1EO1FBQ3BCLElBQUlDLE1BQU1DLElBQUksRUFBRTtZQUNkLE9BQU9ELE1BQU1FLEtBQUs7UUFDcEI7UUFDQSxJQUFJRixNQUFNRyxNQUFNLEVBQUU7WUFDaEIsT0FBTyxhQUFhLEdBQUdkLHVEQUFJQSxDQUFDRix1REFBUUEsRUFBRTtnQkFBRWlCLFVBQVU7b0JBQ2hETjtvQkFDQSxhQUFhLEdBQUdWLHNEQUFHQSxDQUFDRiwyQ0FBUUEsRUFBRTt3QkFBRW1CLFVBQVVMLE1BQU1FLEtBQUs7d0JBQUVFLFVBQVUsYUFBYSxHQUFHaEIsc0RBQUdBLENBQUNTLEdBQUc7NEJBQUVDLEdBQUdFLE1BQU1FLEtBQUs7NEJBQUVILEdBQUdDLE1BQU1NLElBQUk7d0JBQUM7b0JBQUc7aUJBQzVIO1lBQUM7UUFDSjtRQUNBLE9BQU8sYUFBYSxHQUFHbEIsc0RBQUdBLENBQUNGLDJDQUFRQSxFQUFFO1lBQUVtQixVQUFVTCxNQUFNRSxLQUFLO1lBQUVFLFVBQVUsYUFBYSxHQUFHaEIsc0RBQUdBLENBQUNTLEdBQUc7Z0JBQUVDLEdBQUdFLE1BQU1FLEtBQUs7Z0JBQUVILEdBQUdDLE1BQU1NLElBQUk7WUFBQztRQUFHO0lBQ3BJO0NBQ0QsQ0FBQyxFQUFFO0FBQ0osU0FBU0MscUJBQXFCQyxZQUFZO0lBQ3hDLE1BQU0sRUFBRWYsT0FBTyxFQUFFRixPQUFPLEVBQUVDLE1BQU0sRUFBRSxHQUFHRjtJQUNyQyxPQUFPO1FBQ0xtQixLQUFLLGFBQWEsR0FBR3JCLHNEQUFHQSxDQUFDRiwyQ0FBUUEsRUFBRTtZQUFFbUIsVUFBVUc7WUFBY0osVUFBVSxhQUFhLEdBQUdoQixzREFBR0EsQ0FBQ1MsR0FBRztnQkFBRUMsR0FBR1U7Z0JBQWNULEdBQUdOO1lBQVE7UUFBRztRQUMvSEY7UUFDQUM7SUFDRjtBQUNGO0FBQ0EsSUFBSWtCLGFBQWEsQ0FBQ0MsSUFBTSxPQUFPQSxNQUFNO0FBQ3JDLElBQUlDLGdCQUFnQixPQUFPQztJQUN6QixNQUFNQyxTQUFTRCxPQUFPRSxTQUFTO0lBQy9CLE1BQU8sS0FBTTtRQUNYLE1BQU0sRUFBRWQsSUFBSSxFQUFFLEdBQUcsTUFBTWEsT0FBT0UsSUFBSTtRQUNsQyxJQUFJZixNQUNGO0lBQ0o7QUFDRjtBQUVBLG1CQUFtQjtBQUNuQixJQUFJZ0Isc0JBQXNCLElBQUlqQywwREFBaUJBO0FBQy9DLFNBQVNrQyx1QkFBdUJDLE9BQU87SUFDckMsTUFBTUMsUUFBUUgsb0JBQW9CSSxRQUFRO0lBQzFDLElBQUksQ0FBQ0QsT0FBTztRQUNWLE1BQU0sSUFBSUUsTUFBTUg7SUFDbEI7SUFDQSxPQUFPQztBQUNUO0FBQ0EsU0FBU0csWUFBWSxFQUFFQyxPQUFBQSxNQUFLLEVBQUVDLE9BQU8sRUFBRSxFQUFFQyxFQUFFO0lBQ3pDLE9BQU9ULG9CQUFvQlUsR0FBRyxDQUM1QjtRQUNFQyxjQUFjSjtRQUNkSyxlQUFlTDtRQUNmTSxRQUFRO1FBQ1JMO0lBQ0YsR0FDQUM7QUFFSjtBQUNBLFNBQVNLO0lBQ1AsTUFBTVgsUUFBUUYsdUJBQXVCO0lBQ3JDLE9BQU9FLE1BQU1ZLG9CQUFvQjtBQUNuQztBQUNBLFNBQVNDO0lBQ1AsTUFBTWIsUUFBUUYsdUJBQXVCO0lBQ3JDRSxNQUFNVSxNQUFNLEdBQUc7QUFDakI7QUFDQSxTQUFTSSxXQUFXLEdBQUdDLElBQUk7SUFDekIsTUFBTWYsUUFBUUYsdUJBQ1o7SUFFRixJQUFJaUIsS0FBS0MsTUFBTSxHQUFHLEdBQUc7UUFDbkIsTUFBTUMsTUFBTUYsSUFBSSxDQUFDLEVBQUU7UUFDbkIsSUFBSSxPQUFPZixNQUFNUSxZQUFZLEtBQUssVUFBVTtZQUMxQyxNQUFNLElBQUlOLE1BQ1IsQ0FBQyxtQkFBbUIsRUFBRWdCLE9BQ3BCRCxLQUNBLHFEQUFxRCxDQUFDO1FBRTVEO1FBQ0EsT0FBT2pCLE1BQU1RLFlBQVksQ0FBQ1MsSUFBSTtJQUNoQztJQUNBLE9BQU9qQixNQUFNUSxZQUFZO0FBQzNCO0FBQ0EsU0FBU1csa0JBQWtCLEdBQUdKLElBQUk7SUFDaEMsTUFBTWYsUUFBUUYsdUJBQ1o7SUFFRixJQUFJRSxNQUFNVSxNQUFNLEVBQUU7UUFDaEIsTUFBTSxJQUFJUixNQUNSO0lBRUo7SUFDQSxJQUFJLENBQUNGLE1BQU1ZLG9CQUFvQixFQUFFO1FBQy9CLE1BQU0sRUFBRXZDLE9BQU8sRUFBRUYsT0FBTyxFQUFFLEdBQUdEO1FBQzdCOEIsTUFBTVksb0JBQW9CLEdBQUd2QztRQUM3QjJCLE1BQU1vQixvQkFBb0IsR0FBR2pEO0lBQy9CO0lBQ0EsU0FBU2tELFNBQVNDLFFBQVEsRUFBRXpDLElBQUk7UUFDOUIsSUFBSTBDLElBQUlDO1FBQ1IsSUFBSVQsS0FBS0MsTUFBTSxHQUFHLEdBQUc7WUFDbkIsSUFBSSxPQUFPaEIsTUFBTVEsWUFBWSxLQUFLLFVBQVU7Z0JBQzFDLE1BQU1TLE1BQU1GLElBQUksQ0FBQyxFQUFFO2dCQUNuQixNQUFNLElBQUliLE1BQ1IsQ0FBQyxzQkFBc0IsRUFBRWdCLE9BQ3ZCRCxLQUNBLG1EQUFtRCxDQUFDO1lBRTFEO1FBQ0Y7UUFDQSxJQUFJM0IsV0FBV2dDLFdBQVc7WUFDeEIsSUFBSVAsS0FBS0MsTUFBTSxHQUFHLEdBQUc7Z0JBQ25CaEIsTUFBTVEsWUFBWSxDQUFDTyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUdPLFNBQVN0QixNQUFNUSxZQUFZLENBQUNPLElBQUksQ0FBQyxFQUFFLENBQUM7WUFDcEUsT0FBTztnQkFDTGYsTUFBTVEsWUFBWSxHQUFHYyxTQUFTdEIsTUFBTVEsWUFBWTtZQUNsRDtRQUNGLE9BQU87WUFDTCxJQUFJTyxLQUFLQyxNQUFNLEdBQUcsR0FBRztnQkFDbkJoQixNQUFNUSxZQUFZLENBQUNPLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBR087WUFDaEMsT0FBTztnQkFDTHRCLE1BQU1RLFlBQVksR0FBR2M7WUFDdkI7UUFDRjtRQUNDRSxDQUFBQSxLQUFLLENBQUNELEtBQUt2QixNQUFNSyxPQUFPLEVBQUVvQixZQUFZLEtBQUssT0FBTyxLQUFLLElBQUlELEdBQUdFLElBQUksQ0FBQ0gsSUFBSTtZQUN0RU4sS0FBS0YsS0FBS0MsTUFBTSxHQUFHLElBQUlELElBQUksQ0FBQyxFQUFFLEdBQUcsS0FBSztZQUN0Q1gsT0FBT0osTUFBTVEsWUFBWTtZQUN6QjNCO1FBQ0Y7SUFDRjtJQUNBLE1BQU04QyxlQUFlO1FBQ25CQyxLQUFLO1lBQ0gsSUFBSWIsS0FBS0MsTUFBTSxHQUFHLEdBQUc7Z0JBQ25CLE1BQU1DLE1BQU1GLElBQUksQ0FBQyxFQUFFO2dCQUNuQixJQUFJLE9BQU9mLE1BQU1RLFlBQVksS0FBSyxVQUFVO29CQUMxQyxNQUFNLElBQUlOLE1BQ1IsQ0FBQyxtQkFBbUIsRUFBRWdCLE9BQ3BCRCxLQUNBLHFEQUFxRCxDQUFDO2dCQUU1RDtnQkFDQSxPQUFPakIsTUFBTVEsWUFBWSxDQUFDUyxJQUFJO1lBQ2hDO1lBQ0EsT0FBT2pCLE1BQU1RLFlBQVk7UUFDM0I7UUFDQXFCLFFBQVEsU0FBU0EsT0FBT0MsVUFBVTtZQUNoQ1QsU0FBU1MsWUFBWTtRQUN2QjtRQUNBakQsTUFBTSxTQUFTQSxLQUFLLEdBQUdrRCxRQUFRO1lBQzdCLElBQUlBLFNBQVNmLE1BQU0sR0FBRyxHQUFHO2dCQUN2QkssU0FBU1UsUUFBUSxDQUFDLEVBQUUsRUFBRTtZQUN4QjtZQUNBLE1BQU1DLFFBQVFuRSwrQ0FBa0IsQ0FBQ21DLE1BQU1TLGFBQWEsRUFBRVQsTUFBTVEsWUFBWTtZQUN4RVIsTUFBTW9CLG9CQUFvQixDQUFDWTtRQUM3QjtJQUNGO0lBQ0EsT0FBT0w7QUFDVDtBQUVBLHFCQUFxQjtBQUM2QjtBQUVsRCxxQ0FBcUM7QUFDckMsSUFBSVEscUJBQXFCO0lBQ3ZCO1FBQUVDLFVBQVU7UUFBYUMsT0FBTztZQUFDO1lBQUk7WUFBSTtTQUFHO0lBQUM7SUFDN0M7UUFBRUQsVUFBVTtRQUFhQyxPQUFPO1lBQUM7WUFBSztZQUFJO1lBQUk7U0FBRztJQUFDO0lBQ2xEO1FBQUVELFVBQVU7UUFBY0MsT0FBTztZQUFDO1lBQUs7U0FBSTtJQUFDO0lBQzVDO1FBQUVELFVBQVU7UUFBY0MsT0FBTztZQUFDO1lBQUk7WUFBSTtZQUFJO1NBQUc7SUFBQztDQUNuRDtBQUNELFNBQVNDLG9CQUFvQkMsS0FBSztJQUNoQyxLQUFLLE1BQU0sRUFBRUYsS0FBSyxFQUFFRCxRQUFRLEVBQUUsSUFBSUQsbUJBQW9CO1FBQ3BELElBQUlJLE1BQU12QixNQUFNLElBQUlxQixNQUFNckIsTUFBTSxJQUFJcUIsTUFBTUcsS0FBSyxDQUFDLENBQUNDLE1BQU1DLFFBQVVILEtBQUssQ0FBQ0csTUFBTSxLQUFLRCxPQUFPO1lBQ3ZGLE9BQU9MO1FBQ1Q7SUFDRjtJQUNBLE9BQU8sS0FBSztBQUNkO0FBRUEsOEJBQThCO0FBQzZCO0FBSTNCO0FBQ2hDLFNBQVNVLCtCQUErQkMsT0FBTztJQUM3QyxJQUFJQSxtQkFBbUJDLFlBQVk7UUFDakMsT0FBT0Q7SUFDVDtJQUNBLElBQUksT0FBT0EsWUFBWSxVQUFVO1FBQy9CLE9BQU9ILGlGQUF5QkEsQ0FBQ0c7SUFDbkM7SUFDQSxJQUFJQSxtQkFBbUJFLGFBQWE7UUFDbEMsT0FBTyxJQUFJRCxXQUFXRDtJQUN4QjtJQUNBLE1BQU0sSUFBSUoscUVBQXVCQSxDQUFDO1FBQUVJO0lBQVE7QUFDOUM7QUFFQSxrREFBa0Q7QUFDbEQsU0FBU0csNkJBQTZCQyxNQUFNO0lBQzFDLE1BQU1DLHdCQUF3QixFQUFFO0lBQ2hDLElBQUlELE9BQU9FLE1BQU0sSUFBSSxNQUFNO1FBQ3pCRCxzQkFBc0JFLElBQUksQ0FBQztZQUFFQyxNQUFNO1lBQVVSLFNBQVNJLE9BQU9FLE1BQU07UUFBQztJQUN0RTtJQUNBLE9BQVFGLE9BQU9LLElBQUk7UUFDakIsS0FBSztZQUFVO2dCQUNiSixzQkFBc0JFLElBQUksQ0FBQztvQkFDekJDLE1BQU07b0JBQ05SLFNBQVM7d0JBQUM7NEJBQUVTLE1BQU07NEJBQVFDLE1BQU1OLE9BQU9BLE1BQU07d0JBQUM7cUJBQUU7Z0JBQ2xEO2dCQUNBO1lBQ0Y7UUFDQSxLQUFLO1lBQVk7Z0JBQ2ZDLHNCQUFzQkUsSUFBSSxJQUNyQkgsT0FBT08sUUFBUSxDQUFDQyxHQUFHLENBQUMsQ0FBQzVEO29CQUN0QixPQUFRQSxRQUFRd0QsSUFBSTt3QkFDbEIsS0FBSzs0QkFBUTtnQ0FDWCxJQUFJLE9BQU94RCxRQUFRZ0QsT0FBTyxLQUFLLFVBQVU7b0NBQ3ZDLE9BQU87d0NBQ0xRLE1BQU07d0NBQ05SLFNBQVM7NENBQUM7Z0RBQUVTLE1BQU07Z0RBQVFDLE1BQU0xRCxRQUFRZ0QsT0FBTzs0Q0FBQzt5Q0FBRTtvQ0FDcEQ7Z0NBQ0Y7Z0NBQ0EsT0FBTztvQ0FDTFEsTUFBTTtvQ0FDTlIsU0FBU2hELFFBQVFnRCxPQUFPLENBQUNZLEdBQUcsQ0FDMUIsQ0FBQ0M7d0NBQ0MsSUFBSXJDO3dDQUNKLE9BQVFxQyxLQUFLSixJQUFJOzRDQUNmLEtBQUs7Z0RBQVE7b0RBQ1gsT0FBT0k7Z0RBQ1Q7NENBQ0EsS0FBSztnREFBUztvREFDWixJQUFJQSxLQUFLckIsS0FBSyxZQUFZc0IsS0FBSzt3REFDN0IsT0FBTzs0REFDTEwsTUFBTTs0REFDTmpCLE9BQU9xQixLQUFLckIsS0FBSzs0REFDakJILFVBQVV3QixLQUFLeEIsUUFBUTt3REFDekI7b0RBQ0Y7b0RBQ0EsTUFBTTBCLGFBQWFoQiwrQkFDakJjLEtBQUtyQixLQUFLO29EQUVaLE9BQU87d0RBQ0xpQixNQUFNO3dEQUNOakIsT0FBT3VCO3dEQUNQMUIsVUFBVSxDQUFDYixLQUFLcUMsS0FBS3hCLFFBQVEsS0FBSyxPQUFPYixLQUFLZSxvQkFBb0J3QjtvREFDcEU7Z0RBQ0Y7d0NBQ0Y7b0NBQ0Y7Z0NBRUo7NEJBQ0Y7d0JBQ0EsS0FBSzs0QkFBYTtnQ0FDaEIsSUFBSSxPQUFPL0QsUUFBUWdELE9BQU8sS0FBSyxVQUFVO29DQUN2QyxPQUFPO3dDQUNMUSxNQUFNO3dDQUNOUixTQUFTOzRDQUFDO2dEQUFFUyxNQUFNO2dEQUFRQyxNQUFNMUQsUUFBUWdELE9BQU87NENBQUM7eUNBQUU7b0NBQ3BEO2dDQUNGO2dDQUNBLE9BQU87b0NBQUVRLE1BQU07b0NBQWFSLFNBQVNoRCxRQUFRZ0QsT0FBTztnQ0FBQzs0QkFDdkQ7d0JBQ0EsS0FBSzs0QkFBUTtnQ0FDWCxPQUFPaEQ7NEJBQ1Q7b0JBQ0Y7Z0JBQ0Y7Z0JBRUY7WUFDRjtRQUNBO1lBQVM7Z0JBQ1AsTUFBTWdFLG1CQUFtQlo7Z0JBQ3pCLE1BQU0sSUFBSWpELE1BQU0sQ0FBQyx5QkFBeUIsRUFBRTZELGlCQUFpQixDQUFDO1lBQ2hFO0lBQ0Y7SUFDQSxPQUFPWDtBQUNUO0FBRUEsc0NBQXNDO0FBQ2dCO0FBQ3RELFNBQVNhLG1CQUFtQmQsTUFBTTtJQUNoQyxJQUFJQSxPQUFPQSxNQUFNLElBQUksUUFBUUEsT0FBT08sUUFBUSxJQUFJLE1BQU07UUFDcEQsTUFBTSxJQUFJTSxnRUFBa0JBLENBQUM7WUFDM0JiO1lBQ0FwRCxTQUFTO1FBQ1g7SUFDRjtJQUNBLElBQUlvRCxPQUFPQSxNQUFNLElBQUksUUFBUUEsT0FBT08sUUFBUSxJQUFJLE1BQU07UUFDcEQsTUFBTSxJQUFJTSxnRUFBa0JBLENBQUM7WUFDM0JiO1lBQ0FwRCxTQUFTO1FBQ1g7SUFDRjtJQUNBLE9BQU9vRCxPQUFPQSxNQUFNLElBQUksT0FBTztRQUM3QkssTUFBTTtRQUNOTCxRQUFRQSxPQUFPQSxNQUFNO1FBQ3JCTyxVQUFVLEtBQUs7UUFDZkwsUUFBUUYsT0FBT0UsTUFBTTtJQUN2QixJQUFJO1FBQ0ZHLE1BQU07UUFDTkwsUUFBUSxLQUFLO1FBQ2JPLFVBQVVQLE9BQU9PLFFBQVE7UUFDekIsd0NBQXdDO1FBQ3hDTCxRQUFRRixPQUFPRSxNQUFNO0lBQ3ZCO0FBQ0Y7QUFFQSx1Q0FBdUM7QUFDaUI7QUFDeEQsU0FBU2Msb0JBQW9CLEVBQzNCQyxTQUFTLEVBQ1RDLFdBQVcsRUFDWEMsSUFBSSxFQUNKQyxlQUFlLEVBQ2ZDLGdCQUFnQixFQUNoQkMsSUFBSSxFQUNKQyxVQUFVLEVBQ1g7SUFDQyxJQUFJTixhQUFhLE1BQU07UUFDckIsSUFBSSxDQUFDTyxPQUFPQyxTQUFTLENBQUNSLFlBQVk7WUFDaEMsTUFBTSxJQUFJRixrRUFBb0JBLENBQUM7Z0JBQzdCVyxXQUFXO2dCQUNYL0YsT0FBT3NGO2dCQUNQckUsU0FBUztZQUNYO1FBQ0Y7UUFDQSxJQUFJcUUsWUFBWSxHQUFHO1lBQ2pCLE1BQU0sSUFBSUYsa0VBQW9CQSxDQUFDO2dCQUM3QlcsV0FBVztnQkFDWC9GLE9BQU9zRjtnQkFDUHJFLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFDQSxJQUFJc0UsZUFBZSxNQUFNO1FBQ3ZCLElBQUksT0FBT0EsZ0JBQWdCLFVBQVU7WUFDbkMsTUFBTSxJQUFJSCxrRUFBb0JBLENBQUM7Z0JBQzdCVyxXQUFXO2dCQUNYL0YsT0FBT3VGO2dCQUNQdEUsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUNBLElBQUl1RSxRQUFRLE1BQU07UUFDaEIsSUFBSSxPQUFPQSxTQUFTLFVBQVU7WUFDNUIsTUFBTSxJQUFJSixrRUFBb0JBLENBQUM7Z0JBQzdCVyxXQUFXO2dCQUNYL0YsT0FBT3dGO2dCQUNQdkUsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUNBLElBQUl3RSxtQkFBbUIsTUFBTTtRQUMzQixJQUFJLE9BQU9BLG9CQUFvQixVQUFVO1lBQ3ZDLE1BQU0sSUFBSUwsa0VBQW9CQSxDQUFDO2dCQUM3QlcsV0FBVztnQkFDWC9GLE9BQU95RjtnQkFDUHhFLFNBQVM7WUFDWDtRQUNGO0lBQ0Y7SUFDQSxJQUFJeUUsb0JBQW9CLE1BQU07UUFDNUIsSUFBSSxPQUFPQSxxQkFBcUIsVUFBVTtZQUN4QyxNQUFNLElBQUlOLGtFQUFvQkEsQ0FBQztnQkFDN0JXLFdBQVc7Z0JBQ1gvRixPQUFPMEY7Z0JBQ1B6RSxTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBQ0EsSUFBSTBFLFFBQVEsTUFBTTtRQUNoQixJQUFJLENBQUNFLE9BQU9DLFNBQVMsQ0FBQ0gsT0FBTztZQUMzQixNQUFNLElBQUlQLGtFQUFvQkEsQ0FBQztnQkFDN0JXLFdBQVc7Z0JBQ1gvRixPQUFPMkY7Z0JBQ1AxRSxTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBQ0EsSUFBSTJFLGNBQWMsTUFBTTtRQUN0QixJQUFJLENBQUNDLE9BQU9DLFNBQVMsQ0FBQ0YsYUFBYTtZQUNqQyxNQUFNLElBQUlSLGtFQUFvQkEsQ0FBQztnQkFDN0JXLFdBQVc7Z0JBQ1gvRixPQUFPNEY7Z0JBQ1AzRSxTQUFTO1lBQ1g7UUFDRjtRQUNBLElBQUkyRSxhQUFhLEdBQUc7WUFDbEIsTUFBTSxJQUFJUixrRUFBb0JBLENBQUM7Z0JBQzdCVyxXQUFXO2dCQUNYL0YsT0FBTzRGO2dCQUNQM0UsU0FBUztZQUNYO1FBQ0Y7SUFDRjtJQUNBLE9BQU87UUFDTHFFO1FBQ0FDLGFBQWFBLGVBQWUsT0FBT0EsY0FBYztRQUNqREM7UUFDQUM7UUFDQUM7UUFDQUM7UUFDQUMsWUFBWUEsY0FBYyxPQUFPQSxhQUFhO0lBQ2hEO0FBQ0Y7QUFFQSwwQ0FBMEM7QUFDTztBQUNqRCxTQUFTSyx1QkFBdUJDLFNBQVM7SUFDdkMsT0FBT0YsOERBQWVBLENBQUNFO0FBQ3pCO0FBRUEsOENBQThDO0FBQ2M7QUFDVztBQUV2RSxxQkFBcUI7QUFDckIsZUFBZUssTUFBTUMsU0FBUztJQUM1QixPQUFPLElBQUloSCxRQUFRLENBQUNILFVBQVlvSCxXQUFXcEgsU0FBU21IO0FBQ3REO0FBRUEsOENBQThDO0FBQzlDLElBQUlFLDhCQUE4QixDQUFDLEVBQ2pDZCxhQUFhLENBQUMsRUFDZGUsbUJBQW1CLEdBQUcsRUFDdEJDLGdCQUFnQixDQUFDLEVBQ2xCLEdBQUcsQ0FBQyxDQUFDLEdBQUssT0FBT0MsSUFBTUMsNkJBQTZCRCxHQUFHO1lBQ3REakI7WUFDQVksV0FBV0c7WUFDWEM7UUFDRjtBQUNBLGVBQWVFLDZCQUE2QkQsQ0FBQyxFQUFFLEVBQzdDakIsVUFBVSxFQUNWWSxTQUFTLEVBQ1RJLGFBQWEsRUFDZCxFQUFFRyxTQUFTLEVBQUU7SUFDWixJQUFJO1FBQ0YsT0FBTyxNQUFNRjtJQUNmLEVBQUUsT0FBT0csT0FBTztRQUNkLElBQUlWLG9FQUFZQSxDQUFDVSxRQUFRO1lBQ3ZCLE1BQU1BO1FBQ1I7UUFDQSxJQUFJcEIsZUFBZSxHQUFHO1lBQ3BCLE1BQU1vQjtRQUNSO1FBQ0EsTUFBTUMsZUFBZVosdUVBQWVBLENBQUNXO1FBQ3JDLE1BQU1FLFlBQVk7ZUFBSUg7WUFBUUM7U0FBTTtRQUNwQyxNQUFNRyxZQUFZRCxVQUFVaEYsTUFBTTtRQUNsQyxJQUFJaUYsWUFBWXZCLFlBQVk7WUFDMUIsTUFBTSxJQUFJUSx3REFBVUEsQ0FBQztnQkFDbkJuRixTQUFTLENBQUMsYUFBYSxFQUFFa0csVUFBVSx1QkFBdUIsRUFBRUYsYUFBYSxDQUFDO2dCQUMxRUcsUUFBUTtnQkFDUkwsUUFBUUc7WUFDVjtRQUNGO1FBQ0EsSUFBSUYsaUJBQWlCNUYsU0FBUytFLDBEQUFZQSxDQUFDa0IsY0FBYyxDQUFDTCxVQUFVQSxNQUFNTSxXQUFXLEtBQUssUUFBUUgsYUFBYXZCLFlBQVk7WUFDekgsTUFBTVcsTUFBTUM7WUFDWixPQUFPTSw2QkFDTEQsR0FDQTtnQkFBRWpCO2dCQUFZWSxXQUFXSSxnQkFBZ0JKO2dCQUFXSTtZQUFjLEdBQ2xFTTtRQUVKO1FBQ0EsSUFBSUMsY0FBYyxHQUFHO1lBQ25CLE1BQU1IO1FBQ1I7UUFDQSxNQUFNLElBQUlaLHdEQUFVQSxDQUFDO1lBQ25CbkYsU0FBUyxDQUFDLGFBQWEsRUFBRWtHLFVBQVUscUNBQXFDLEVBQUVGLGFBQWEsQ0FBQyxDQUFDO1lBQ3pGRyxRQUFRO1lBQ1JMLFFBQVFHO1FBQ1Y7SUFDRjtBQUNGO0FBRUEseUJBQXlCO0FBQ3pCLElBQUlLLGlCQUFpQjtJQUNuQkMsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQzFIO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJb0IsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRXNELE1BQU07WUFBUTFFO1FBQU07SUFDL0I7QUFDRjtBQUNBLElBQUkySCx5QkFBeUI7SUFDM0JILE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUMxSDtRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxvQkFBbUJBLEtBQUksS0FBTSxPQUFPQSxNQUFNNEgsYUFBYSxLQUFLLFlBQVk1SCxNQUFNNEgsYUFBYSxJQUFJLFFBQVEsQ0FBRSxXQUFVNUgsTUFBTTRILGFBQWEsS0FBSyxDQUFFLGdCQUFlNUgsTUFBTTRILGFBQWEsS0FBSyxPQUFPNUgsTUFBTTRILGFBQWEsQ0FBQ0gsSUFBSSxLQUFLLFlBQVksT0FBT3pILE1BQU00SCxhQUFhLENBQUNDLFNBQVMsS0FBSyxVQUFVO1lBQ3pVLE1BQU0sSUFBSXpHLE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTHNELE1BQU07WUFDTjFFO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSThILGlCQUFpQjtJQUNuQk4sTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQzFIO1FBQ04sSUFBSSxDQUFDK0gsTUFBTUMsT0FBTyxDQUFDaEksUUFBUTtZQUN6QixNQUFNLElBQUlvQixNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFc0QsTUFBTTtZQUFRMUU7UUFBTTtJQUMvQjtBQUNGO0FBQ0EsSUFBSWlJLGtCQUFrQjtJQUNwQlQsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQzFIO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJb0IsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRXNELE1BQU07WUFBUzFFO1FBQU07SUFDaEM7QUFDRjtBQUNBLElBQUlrSSw2QkFBNkI7SUFDL0JWLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUMxSDtRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxTQUFRQSxLQUFJLEtBQU0sQ0FBRSxXQUFVQSxLQUFJLEtBQU0sQ0FBRSxjQUFhQSxLQUFJLEtBQU0sT0FBT0EsTUFBTW1JLEVBQUUsS0FBSyxZQUFZLE9BQU9uSSxNQUFNeUUsSUFBSSxLQUFLLFlBQVl6RSxNQUFNeUUsSUFBSSxLQUFLLGVBQWUsQ0FBQ3NELE1BQU1DLE9BQU8sQ0FBQ2hJLE1BQU1pRSxPQUFPLEtBQUssQ0FBQ2pFLE1BQU1pRSxPQUFPLENBQUNQLEtBQUssQ0FDeFEsQ0FBQzBFLE9BQVNBLFFBQVEsUUFBUSxPQUFPQSxTQUFTLFlBQVksVUFBVUEsUUFBUUEsS0FBSzFELElBQUksS0FBSyxVQUFVLFVBQVUwRCxRQUFRQSxLQUFLekQsSUFBSSxJQUFJLFFBQVEsT0FBT3lELEtBQUt6RCxJQUFJLEtBQUssWUFBWSxXQUFXeUQsS0FBS3pELElBQUksSUFBSSxPQUFPeUQsS0FBS3pELElBQUksQ0FBQzNFLEtBQUssS0FBSyxXQUMxTjtZQUNELE1BQU0sSUFBSW9CLE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTHNELE1BQU07WUFDTjFFO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSXFJLGlDQUFpQztJQUNuQ2IsTUFBTTtJQUNOQyxNQUFNO0lBQ05DLE9BQU8sQ0FBQzFIO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLGVBQWNBLEtBQUksS0FBTSxDQUFFLGdCQUFlQSxLQUFJLEtBQU0sT0FBT0EsTUFBTXNJLFFBQVEsS0FBSyxZQUFZLE9BQU90SSxNQUFNdUksU0FBUyxLQUFLLFVBQVU7WUFDaEwsTUFBTSxJQUFJbkgsTUFDUjtRQUVKO1FBQ0EsT0FBTztZQUNMc0QsTUFBTTtZQUNOMUUsT0FBTztnQkFDTHNJLFVBQVV0SSxNQUFNc0ksUUFBUTtnQkFDeEJDLFdBQVd2SSxNQUFNdUksU0FBUztZQUM1QjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUlDLHdCQUF3QjtJQUMxQmhCLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUMxSDtRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxXQUFVQSxLQUFJLEtBQU0sQ0FBRSxXQUFVQSxLQUFJLEtBQU0sT0FBT0EsTUFBTXlFLElBQUksS0FBSyxZQUFZekUsTUFBTXlFLElBQUksS0FBSyxRQUFRO1lBQ3JKLE1BQU0sSUFBSXJELE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTHNELE1BQU07WUFDTjFFO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSXlJLHFCQUFxQjtJQUN2QmpCLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUMxSDtRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxpQkFBZ0JBLEtBQUksS0FBTSxPQUFPQSxNQUFNMEksVUFBVSxLQUFLLFlBQVkxSSxNQUFNMEksVUFBVSxJQUFJLFFBQVEsQ0FBQ1gsTUFBTUMsT0FBTyxDQUFDaEksTUFBTTBJLFVBQVUsS0FBSzFJLE1BQU0wSSxVQUFVLENBQUNDLElBQUksQ0FDek0sQ0FBQ0MsS0FBT0EsTUFBTSxRQUFRLE9BQU9BLE9BQU8sWUFBWSxDQUFFLFNBQVFBLEVBQUMsS0FBTSxPQUFPQSxHQUFHVCxFQUFFLEtBQUssWUFBWSxDQUFFLFdBQVVTLEVBQUMsS0FBTSxPQUFPQSxHQUFHbEUsSUFBSSxLQUFLLFlBQVksQ0FBRSxlQUFja0UsRUFBQyxLQUFNQSxHQUFHQyxRQUFRLElBQUksUUFBUSxPQUFPRCxHQUFHQyxRQUFRLEtBQUssWUFBWSxDQUFFLGdCQUFlRCxHQUFHQyxRQUFRLEtBQUssT0FBT0QsR0FBR0MsUUFBUSxDQUFDcEIsSUFBSSxLQUFLLFlBQVksT0FBT21CLEdBQUdDLFFBQVEsQ0FBQ2hCLFNBQVMsS0FBSyxXQUMxVTtZQUNELE1BQU0sSUFBSXpHLE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTHNELE1BQU07WUFDTjFFO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSThJLCtCQUErQjtJQUNqQ3RCLE1BQU07SUFDTkMsTUFBTTtJQUNOQyxPQUFPLENBQUMxSDtRQUNOLElBQUksQ0FBQytILE1BQU1DLE9BQU8sQ0FBQ2hJLFFBQVE7WUFDekIsTUFBTSxJQUFJb0IsTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRXNELE1BQU07WUFBdUIxRTtRQUFNO0lBQzlDO0FBQ0Y7QUFDQSxJQUFJK0ksY0FBYztJQUNoQnhCO0lBQ0FJO0lBQ0FHO0lBQ0FHO0lBQ0FDO0lBQ0FHO0lBQ0FHO0lBQ0FDO0lBQ0FLO0NBQ0Q7QUFDRCxJQUFJRSxvQkFBb0I7SUFDdEIsQ0FBQ3pCLGVBQWVDLElBQUksQ0FBQyxFQUFFRDtJQUN2QixDQUFDSSx1QkFBdUJILElBQUksQ0FBQyxFQUFFRztJQUMvQixDQUFDRyxlQUFlTixJQUFJLENBQUMsRUFBRU07SUFDdkIsQ0FBQ0csZ0JBQWdCVCxJQUFJLENBQUMsRUFBRVM7SUFDeEIsQ0FBQ0MsMkJBQTJCVixJQUFJLENBQUMsRUFBRVU7SUFDbkMsQ0FBQ0csK0JBQStCYixJQUFJLENBQUMsRUFBRWE7SUFDdkMsQ0FBQ0csc0JBQXNCaEIsSUFBSSxDQUFDLEVBQUVnQjtJQUM5QixDQUFDQyxtQkFBbUJqQixJQUFJLENBQUMsRUFBRWlCO0lBQzNCLENBQUNLLDZCQUE2QnRCLElBQUksQ0FBQyxFQUFFc0I7QUFDdkM7QUFDQSxJQUFJRyx1QkFBdUI7SUFDekIsQ0FBQzFCLGVBQWVFLElBQUksQ0FBQyxFQUFFRixlQUFlQyxJQUFJO0lBQzFDLENBQUNHLHVCQUF1QkYsSUFBSSxDQUFDLEVBQUVFLHVCQUF1QkgsSUFBSTtJQUMxRCxDQUFDTSxlQUFlTCxJQUFJLENBQUMsRUFBRUssZUFBZU4sSUFBSTtJQUMxQyxDQUFDUyxnQkFBZ0JSLElBQUksQ0FBQyxFQUFFUSxnQkFBZ0JULElBQUk7SUFDNUMsQ0FBQ1UsMkJBQTJCVCxJQUFJLENBQUMsRUFBRVMsMkJBQTJCVixJQUFJO0lBQ2xFLENBQUNhLCtCQUErQlosSUFBSSxDQUFDLEVBQUVZLCtCQUErQmIsSUFBSTtJQUMxRSxDQUFDZ0Isc0JBQXNCZixJQUFJLENBQUMsRUFBRWUsc0JBQXNCaEIsSUFBSTtJQUN4RCxDQUFDaUIsbUJBQW1CaEIsSUFBSSxDQUFDLEVBQUVnQixtQkFBbUJqQixJQUFJO0lBQ2xELENBQUNzQiw2QkFBNkJyQixJQUFJLENBQUMsRUFBRXFCLDZCQUE2QnRCLElBQUk7QUFDeEU7QUFDQSxJQUFJMEIsYUFBYUgsWUFBWWxFLEdBQUcsQ0FBQyxDQUFDQyxPQUFTQSxLQUFLMEMsSUFBSTtBQUNwRCxJQUFJMkIsa0JBQWtCLENBQUNDO0lBQ3JCLE1BQU1DLHNCQUFzQkQsS0FBS0UsT0FBTyxDQUFDO0lBQ3pDLElBQUlELHdCQUF3QixDQUFDLEdBQUc7UUFDOUIsTUFBTSxJQUFJakksTUFBTTtJQUNsQjtJQUNBLE1BQU1tSSxTQUFTSCxLQUFLSSxLQUFLLENBQUMsR0FBR0g7SUFDN0IsSUFBSSxDQUFDSCxXQUFXTyxRQUFRLENBQUNGLFNBQVM7UUFDaEMsTUFBTSxJQUFJbkksTUFBTSxDQUFDLDRDQUE0QyxFQUFFbUksT0FBTyxDQUFDLENBQUM7SUFDMUU7SUFDQSxNQUFNL0IsT0FBTytCO0lBQ2IsTUFBTUcsWUFBWU4sS0FBS0ksS0FBSyxDQUFDSCxzQkFBc0I7SUFDbkQsTUFBTU0sWUFBWUMsS0FBS2xDLEtBQUssQ0FBQ2dDO0lBQzdCLE9BQU9WLGlCQUFpQixDQUFDeEIsS0FBSyxDQUFDRSxLQUFLLENBQUNpQztBQUN2QztBQUNBLFNBQVNFLGlCQUFpQm5GLElBQUksRUFBRTFFLEtBQUs7SUFDbkMsTUFBTThKLGFBQWFmLFlBQVlnQixJQUFJLENBQUMsQ0FBQ2pGLE9BQVNBLEtBQUsyQyxJQUFJLEtBQUsvQztJQUM1RCxJQUFJLENBQUNvRixZQUFZO1FBQ2YsTUFBTSxJQUFJMUksTUFBTSxDQUFDLDBCQUEwQixFQUFFc0QsS0FBSyxDQUFDO0lBQ3JEO0lBQ0EsT0FBTyxDQUFDLEVBQUVvRixXQUFXdEMsSUFBSSxDQUFDLENBQUMsRUFBRW9DLEtBQUtJLFNBQVMsQ0FBQ2hLLE9BQU87QUFDckQsQ0FBQztBQUNEO0FBRUEsa0JBQWtCO0FBQ2xCLFNBQVNpSyxtQkFBbUJDLE9BQU87SUFDakMsTUFBTUMsVUFBVSxJQUFJQztJQUNwQixJQUFJLENBQUNGLFNBQVM7UUFDWixPQUFPLFNBQVNwSyxLQUFLO1lBQ25CLElBQUksQ0FBQ0EsT0FDSCxPQUFPO1lBQ1QsT0FBT3FLLFFBQVFFLE1BQU0sQ0FBQ3ZLLE9BQU87Z0JBQUVhLFFBQVE7WUFBSztRQUM5QztJQUNGO0lBQ0EsT0FBTyxTQUFTYixLQUFLO1FBQ25CLE1BQU13SyxVQUFVSCxRQUFRRSxNQUFNLENBQUN2SyxPQUFPO1lBQUVhLFFBQVE7UUFBSyxHQUFHNEosS0FBSyxDQUFDLE1BQU1DLE1BQU0sQ0FBQyxDQUFDcEIsT0FBU0EsU0FBUztRQUM5RixPQUFPa0IsUUFBUXpGLEdBQUcsQ0FBQ3NFLGlCQUFpQnFCLE1BQU0sQ0FBQ0M7SUFDN0M7QUFDRjtBQUVBLHVCQUF1QjtBQUdLO0FBQzVCLFNBQVNFLDZCQUE2QkMsWUFBWTtJQUNoRCxNQUFNQyxjQUFjLElBQUlUO0lBQ3hCLElBQUlVO0lBQ0osT0FBTyxJQUFJQyxnQkFBZ0I7UUFDekIsTUFBTUMsT0FBTUMsVUFBVTtZQUNwQkgsb0JBQW9CSixnRUFBWUEsQ0FDOUIsQ0FBQ1E7Z0JBQ0MsSUFBSSxVQUFVQSxTQUFTQSxNQUFNeEcsSUFBSSxLQUFLLFdBQVd3RyxNQUFNQyxJQUFJLEtBQUssWUFBWSw2REFBNkQ7Z0JBQ3pJLDRDQUE0QztnQkFDNUNELE1BQU1BLEtBQUssS0FBSyxRQUFRO29CQUN0QkQsV0FBV0csU0FBUztvQkFDcEI7Z0JBQ0Y7Z0JBQ0EsSUFBSSxVQUFVRixPQUFPO29CQUNuQixNQUFNRyxnQkFBZ0JULGVBQWVBLGFBQWFNLE1BQU1DLElBQUksRUFBRTt3QkFDNURELE9BQU9BLE1BQU1BLEtBQUs7b0JBQ3BCLEtBQUtBLE1BQU1DLElBQUk7b0JBQ2YsSUFBSUUsZUFDRkosV0FBV0ssT0FBTyxDQUFDRDtnQkFDdkI7WUFDRjtRQUVKO1FBQ0FFLFdBQVV6TCxLQUFLO1lBQ2JnTCxrQkFBa0JVLElBQUksQ0FBQ1gsWUFBWVIsTUFBTSxDQUFDdks7UUFDNUM7SUFDRjtBQUNGO0FBQ0EsU0FBUzJMLDJCQUEyQkMsRUFBRTtJQUNwQyxNQUFNQyxjQUFjLElBQUlDO0lBQ3hCLElBQUlDLHFCQUFxQjtJQUN6QixNQUFNQyxZQUFZSixNQUFNLENBQUM7SUFDekIsT0FBTyxJQUFJWCxnQkFBZ0I7UUFDekIsTUFBTUM7WUFDSixJQUFJYyxVQUFVQyxPQUFPLEVBQ25CLE1BQU1ELFVBQVVDLE9BQU87UUFDM0I7UUFDQSxNQUFNUixXQUFVdEssT0FBTyxFQUFFZ0ssVUFBVTtZQUNqQyxNQUFNaEgsVUFBVSxPQUFPaEQsWUFBWSxXQUFXQSxVQUFVQSxRQUFRZ0QsT0FBTztZQUN2RWdILFdBQVdLLE9BQU8sQ0FBQ0ssWUFBWUssTUFBTSxDQUFDL0g7WUFDdEM0SCxzQkFBc0I1SDtZQUN0QixJQUFJNkgsVUFBVUcsT0FBTyxFQUNuQixNQUFNSCxVQUFVRyxPQUFPLENBQUNoSTtZQUMxQixJQUFJNkgsVUFBVUksTUFBTSxJQUFJLE9BQU9qTCxZQUFZLFVBQVU7Z0JBQ25ELE1BQU02SyxVQUFVSSxNQUFNLENBQUNqTDtZQUN6QjtRQUNGO1FBQ0EsTUFBTWtMO1lBQ0osTUFBTUMsb0JBQW9CQyw4QkFBOEJQO1lBQ3hELElBQUlBLFVBQVVRLFlBQVksRUFBRTtnQkFDMUIsTUFBTVIsVUFBVVEsWUFBWSxDQUFDVDtZQUMvQjtZQUNBLElBQUlDLFVBQVVTLE9BQU8sSUFBSSxDQUFDSCxtQkFBbUI7Z0JBQzNDLE1BQU1OLFVBQVVTLE9BQU8sQ0FBQ1Y7WUFDMUI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxTQUFTUSw4QkFBOEJQLFNBQVM7SUFDOUMsT0FBTyxpQ0FBaUNBO0FBQzFDO0FBQ0EsU0FBU1U7SUFDUCxJQUFJQyxnQkFBZ0I7SUFDcEIsT0FBTyxDQUFDOUg7UUFDTixJQUFJOEgsZUFBZTtZQUNqQjlILE9BQU9BLEtBQUsrSCxTQUFTO1lBQ3JCLElBQUkvSCxNQUNGOEgsZ0JBQWdCO1FBQ3BCO1FBQ0EsT0FBTzlIO0lBQ1Q7QUFDRjtBQUNBLFNBQVNnSSxTQUFTQyxRQUFRLEVBQUVoQyxZQUFZLEVBQUVrQixTQUFTO0lBQ2pELElBQUksQ0FBQ2MsU0FBU0MsRUFBRSxFQUFFO1FBQ2hCLElBQUlELFNBQVNFLElBQUksRUFBRTtZQUNqQixNQUFNbE0sU0FBU2dNLFNBQVNFLElBQUksQ0FBQ2pNLFNBQVM7WUFDdEMsT0FBTyxJQUFJa00sZUFBZTtnQkFDeEIsTUFBTS9CLE9BQU1DLFVBQVU7b0JBQ3BCLE1BQU0sRUFBRWxMLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVksT0FBT0UsSUFBSTtvQkFDekMsSUFBSSxDQUFDZixNQUFNO3dCQUNULE1BQU1pTixZQUFZLElBQUk1QyxjQUFjQyxNQUFNLENBQUNySzt3QkFDM0NpTCxXQUFXakUsS0FBSyxDQUFDLElBQUk1RixNQUFNLENBQUMsZ0JBQWdCLEVBQUU0TCxVQUFVLENBQUM7b0JBQzNEO2dCQUNGO1lBQ0Y7UUFDRixPQUFPO1lBQ0wsT0FBTyxJQUFJRCxlQUFlO2dCQUN4Qi9CLE9BQU1DLFVBQVU7b0JBQ2RBLFdBQVdqRSxLQUFLLENBQUMsSUFBSTVGLE1BQU07Z0JBQzdCO1lBQ0Y7UUFDRjtJQUNGO0lBQ0EsTUFBTTZMLHFCQUFxQkwsU0FBU0UsSUFBSSxJQUFJSTtJQUM1QyxPQUFPRCxtQkFBbUJFLFdBQVcsQ0FBQ3hDLDZCQUE2QkMsZUFBZXVDLFdBQVcsQ0FBQzFCLDJCQUEyQks7QUFDM0g7QUFDQSxTQUFTb0I7SUFDUCxPQUFPLElBQUlILGVBQWU7UUFDeEIvQixPQUFNQyxVQUFVO1lBQ2RBLFdBQVdtQyxLQUFLO1FBQ2xCO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLDBCQUEwQkMsUUFBUTtJQUN6QyxJQUFJQyxLQUFLRCxRQUFRLENBQUNFLE9BQU9DLGFBQWEsQ0FBQztJQUN2QyxPQUFPLElBQUlWLGVBQWU7UUFDeEIsTUFBTVcsTUFBS3pDLFVBQVU7WUFDbkIsTUFBTSxFQUFFbEwsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNdU4sR0FBR25OLElBQUk7WUFDckMsSUFBSUwsTUFDRmtMLFdBQVdtQyxLQUFLO2lCQUVoQm5DLFdBQVdLLE9BQU8sQ0FBQ3RMO1FBQ3ZCO1FBQ0EsTUFBTTJOLFFBQU92RyxNQUFNO1lBQ2pCLElBQUkzRTtZQUNKLE1BQU8sRUFBQ0EsS0FBSzhLLEdBQUdLLE1BQU0sS0FBSyxPQUFPLEtBQUssSUFBSW5MLEdBQUdHLElBQUksQ0FBQzJLLElBQUluRyxPQUFNO1FBQy9EO0lBQ0Y7QUFDRjtBQUVBLHlCQUF5QjtBQUN6QixTQUFTeUc7SUFDUCxNQUFNQyxVQUFVLElBQUlsQztJQUNwQixNQUFNekIsVUFBVSxJQUFJQztJQUNwQixPQUFPLElBQUlXLGdCQUFnQjtRQUN6QlEsV0FBVyxPQUFPekwsT0FBT21MO1lBQ3ZCLE1BQU1oSyxVQUFVa0osUUFBUUUsTUFBTSxDQUFDdks7WUFDL0JtTCxXQUFXSyxPQUFPLENBQUN3QyxRQUFROUIsTUFBTSxDQUFDbkMsaUJBQWlCLFFBQVE1STtRQUM3RDtJQUNGO0FBQ0Y7QUFFQSwyQkFBMkI7QUFDM0IsU0FBUzhNO0lBQ1AsTUFBTUMsVUFBVUM7SUFDaEIsT0FBTyxDQUFDOUMsT0FBUzZDLFFBQVFwRSxLQUFLbEMsS0FBSyxDQUFDeUQ7QUFDdEM7QUFDQSxnQkFBZ0IrQyxXQUFXdk4sTUFBTTtJQUMvQixNQUFNcU4sVUFBVUM7SUFDaEIsV0FBVyxJQUFJbk8sU0FBU2EsT0FBUTtRQUM5QixJQUFJLHlCQUF5QmIsT0FBTztZQUNsQ0EsUUFBUTtnQkFDTnFJLElBQUlySSxNQUFNcUksRUFBRTtnQkFDWmdHLFNBQVNyTyxNQUFNcU8sT0FBTyxDQUFDQyxPQUFPO2dCQUM5QkMsUUFBUXZPLE1BQU11TyxNQUFNO2dCQUNwQiwyQkFBMkI7Z0JBQzNCQyxPQUFPeE8sTUFBTXdPLEtBQUs7Z0JBQ2xCLDJCQUEyQjtnQkFDM0JDLFNBQVN6TyxNQUFNeU8sT0FBTyxDQUFDMUosR0FBRyxDQUFDLENBQUMySjtvQkFDMUIsSUFBSS9MLElBQUlDLElBQUkrTCxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztvQkFDNUIsT0FBTzt3QkFDTDNMLE9BQU87NEJBQ0xlLFNBQVMsQ0FBQ3hCLEtBQUsrTCxPQUFPdEwsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJVCxHQUFHd0IsT0FBTzs0QkFDMUQyRCxlQUFlLENBQUNsRixLQUFLOEwsT0FBT3RMLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSVIsR0FBR29NLFlBQVk7NEJBQ3JFckssTUFBTSxDQUFDZ0ssS0FBS0QsT0FBT3RMLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSXVMLEdBQUdoSyxJQUFJOzRCQUNwRGlFLFlBQVksQ0FBQyxDQUFDaUcsS0FBSyxDQUFDRCxLQUFLRixPQUFPdEwsS0FBSyxLQUFLLE9BQU8sS0FBSyxJQUFJd0wsR0FBR0ssU0FBUyxLQUFLLE9BQU8sS0FBSyxJQUFJSixHQUFHek0sTUFBTSxJQUFJLENBQUMyTSxLQUFLLENBQUNELEtBQUtKLE9BQU90TCxLQUFLLEtBQUssT0FBTyxLQUFLLElBQUkwTCxHQUFHRyxTQUFTLEtBQUssT0FBTyxLQUFLLElBQUlGLEdBQUdoSyxHQUFHLENBQUMsQ0FBQ21LLFVBQVVwTCxRQUFXO29DQUNqTkE7b0NBQ0F1RSxJQUFJNkcsU0FBUzdHLEVBQUU7b0NBQ2ZVLFVBQVVtRyxTQUFTbkcsUUFBUTtvQ0FDM0JuRSxNQUFNc0ssU0FBU3RLLElBQUk7Z0NBQ3JCLE1BQU0sS0FBSzt3QkFDYjt3QkFDQXVLLGVBQWVULE9BQU9VLFlBQVk7d0JBQ2xDdEwsT0FBTzRLLE9BQU81SyxLQUFLO29CQUNyQjtnQkFDRjtZQUNGO1FBQ0Y7UUFDQSxNQUFNZSxPQUFPcUosUUFBUWxPO1FBQ3JCLElBQUk2RSxNQUNGLE1BQU1BO0lBQ1Y7QUFDRjtBQUNBLFNBQVNzSjtJQUNQLE1BQU1rQixvQkFBb0IzQztJQUMxQixJQUFJNEM7SUFDSixPQUFPLENBQUNDO1FBQ04sSUFBSTVNLElBQUlDLElBQUkrTCxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJUyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQyxJQUFJQztRQUN4RSxJQUFJQyxzQkFBc0JaLE9BQU87WUFDL0IsTUFBTW5NLFFBQVEsQ0FBQ1QsS0FBSzRNLEtBQUtkLE9BQU8sQ0FBQyxFQUFFLEtBQUssT0FBTyxLQUFLLElBQUk5TCxHQUFHUyxLQUFLO1lBQ2hFLElBQUksQ0FBQ1IsS0FBS1EsTUFBTTBFLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSWxGLEdBQUcrRSxJQUFJLEVBQUU7Z0JBQ3pEMkgsd0JBQXdCO2dCQUN4QixPQUFPO29CQUNMYyxRQUFRO29CQUNSak0sU0FBUyxDQUFDLDRCQUE0QixFQUFFZixNQUFNMEUsYUFBYSxDQUFDSCxJQUFJLENBQUMsaUJBQWlCLENBQUM7Z0JBQ3JGO1lBQ0YsT0FBTyxJQUFJLENBQUNrSCxLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBS3ZMLE1BQU13RixVQUFVLEtBQUssT0FBTyxLQUFLLElBQUkrRixFQUFFLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJQyxHQUFHN0YsUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJOEYsR0FBR2xILElBQUksRUFBRTtnQkFDbkkySCx3QkFBd0I7Z0JBQ3hCLE1BQU1KLFdBQVc5TCxNQUFNd0YsVUFBVSxDQUFDLEVBQUU7Z0JBQ3BDLElBQUlzRyxTQUFTcEwsS0FBSyxLQUFLLEdBQUc7b0JBQ3hCLE9BQU87d0JBQ0xzTSxRQUFRO3dCQUNSak0sU0FBUyxDQUFDLHdCQUF3QixFQUFFK0ssU0FBUzdHLEVBQUUsQ0FBQyw2Q0FBNkMsRUFBRSxDQUFDeUcsS0FBS0ksU0FBU25HLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSStGLEdBQUduSCxJQUFJLENBQUMsaUJBQWlCLENBQUM7b0JBQ3ZLO2dCQUNGLE9BQU87b0JBQ0wsT0FBTzt3QkFDTHlJLFFBQVE7d0JBQ1JqTSxTQUFTLENBQUMsYUFBYSxFQUFFK0ssU0FBUzdHLEVBQUUsQ0FBQyw2Q0FBNkMsRUFBRSxDQUFDMEcsS0FBS0csU0FBU25HLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSWdHLEdBQUdwSCxJQUFJLENBQUMsaUJBQWlCLENBQUM7b0JBQzVKO2dCQUNGO1lBQ0YsT0FBTyxJQUFJLENBQUM2SCxLQUFLcE0sTUFBTTBFLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSTBILEdBQUd6SCxTQUFTLEVBQUU7Z0JBQ3JFLE9BQU87b0JBQ0xxSSxRQUFRO29CQUNSak0sU0FBU2tNLGlCQUFpQixDQUFDWixLQUFLck0sTUFBTTBFLGFBQWEsS0FBSyxPQUFPLEtBQUssSUFBSTJILEdBQUcxSCxTQUFTO2dCQUN0RjtZQUNGLE9BQU8sSUFBSSxDQUFDNkgsS0FBSyxDQUFDRCxLQUFLLENBQUNELEtBQUt0TSxNQUFNd0YsVUFBVSxLQUFLLE9BQU8sS0FBSyxJQUFJOEcsRUFBRSxDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSUMsR0FBRzVHLFFBQVEsS0FBSyxPQUFPLEtBQUssSUFBSTZHLEdBQUc3SCxTQUFTLEVBQUU7Z0JBQ3hJLE9BQU87b0JBQ0xxSSxRQUFRO29CQUNSak0sU0FBU2tNLGlCQUFpQixDQUFDTixLQUFLLENBQUNELEtBQUssQ0FBQ0QsS0FBS3pNLE1BQU13RixVQUFVLEtBQUssT0FBTyxLQUFLLElBQUlpSCxFQUFFLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJQyxHQUFHL0csUUFBUSxLQUFLLE9BQU8sS0FBSyxJQUFJZ0gsR0FBR2hJLFNBQVM7Z0JBQ3pKO1lBQ0YsT0FBTyxJQUFJdUgseUJBQTBCLEVBQUMsQ0FBQ1UsS0FBS1QsS0FBS2QsT0FBTyxDQUFDLEVBQUUsS0FBSyxPQUFPLEtBQUssSUFBSXVCLEdBQUdiLGFBQWEsTUFBTSxtQkFBbUIsQ0FBQyxDQUFDYyxLQUFLVixLQUFLZCxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJd0IsR0FBR2QsYUFBYSxNQUFNLE1BQUssR0FBSTtnQkFDak1HLHdCQUF3QjtnQkFDeEIsT0FBTztvQkFDTGMsUUFBUTtvQkFDUmpNLFNBQVM7Z0JBQ1g7WUFDRixPQUFPLElBQUltTCx5QkFBeUIsQ0FBQyxDQUFDWSxLQUFLWCxLQUFLZCxPQUFPLENBQUMsRUFBRSxLQUFLLE9BQU8sS0FBSyxJQUFJeUIsR0FBR2YsYUFBYSxNQUFNLGNBQWM7Z0JBQ2pIRyx3QkFBd0I7Z0JBQ3hCLE9BQU87b0JBQ0xjLFFBQVE7b0JBQ1JqTSxTQUFTO2dCQUNYO1lBQ0Y7UUFDRjtRQUNBLE1BQU1VLE9BQU93SyxrQkFDWGMsc0JBQXNCWixTQUFTQSxLQUFLZCxPQUFPLENBQUMsRUFBRSxDQUFDckwsS0FBSyxDQUFDZSxPQUFPLEdBQUdvTCxLQUFLZCxPQUFPLENBQUMsRUFBRSxDQUFDckwsS0FBSyxDQUFDZSxPQUFPLEdBQUdtTSxhQUFhZixRQUFRQSxLQUFLZCxPQUFPLENBQUMsRUFBRSxDQUFDNUosSUFBSSxHQUFHO1FBRTdJLE9BQU9BO0lBQ1Q7SUFDQSxTQUFTd0wsaUJBQWlCRSxhQUFhO1FBQ3JDLElBQUlDLHFCQUFxQkQsY0FBY0UsT0FBTyxDQUFDLE9BQU8sUUFBUUEsT0FBTyxDQUFDLE9BQU8sT0FBT0EsT0FBTyxDQUFDLE1BQU0sT0FBT0EsT0FBTyxDQUFDLE9BQU8sT0FBT0EsT0FBTyxDQUFDLE9BQU8sT0FBT0EsT0FBTyxDQUFDLE9BQU8sT0FBT0EsT0FBTyxDQUFDLE9BQU87UUFDMUwsT0FBTyxDQUFDLEVBQUVELG1CQUFtQixDQUFDO0lBQ2hDO0FBQ0Y7QUFDQSxJQUFJRSxxQ0FBcUNoRCxPQUN2QztBQUVGLFNBQVN5QyxzQkFBc0I5RSxJQUFJO0lBQ2pDLE9BQU8sYUFBYUEsUUFBUUEsS0FBS29ELE9BQU8sSUFBSXBELEtBQUtvRCxPQUFPLENBQUMsRUFBRSxJQUFJLFdBQVdwRCxLQUFLb0QsT0FBTyxDQUFDLEVBQUU7QUFDM0Y7QUFDQSxTQUFTNkIsYUFBYWpGLElBQUk7SUFDeEIsT0FBTyxhQUFhQSxRQUFRQSxLQUFLb0QsT0FBTyxJQUFJcEQsS0FBS29ELE9BQU8sQ0FBQyxFQUFFLElBQUksVUFBVXBELEtBQUtvRCxPQUFPLENBQUMsRUFBRTtBQUMxRjtBQUNBLFNBQVNrQyxhQUFhaFIsR0FBRyxFQUFFcU0sU0FBUztJQUNsQyxNQUFNSixLQUFLSTtJQUNYLElBQUluTDtJQUNKLElBQUk2TSxPQUFPQyxhQUFhLElBQUloTyxLQUFLO1FBQy9Ca0IsU0FBUzBNLDBCQUEwQmEsV0FBV3pPLE1BQU0wTixXQUFXLENBQzdEMUIsMkJBQ0UsQ0FBQ0MsTUFBTSxPQUFPLEtBQUssSUFBSUEsR0FBR2dGLDJCQUEyQixLQUFNaEYsQ0FBQUEsTUFBTSxPQUFPLEtBQUssSUFBSUEsR0FBR2lGLHVCQUF1QixJQUFJO1lBQzdHLEdBQUdqRixFQUFFO1lBQ0xhLFNBQVMsS0FBSztRQUNoQixJQUFJO1lBQ0YsR0FBR2IsRUFBRTtRQUNQO0lBR04sT0FBTztRQUNML0ssU0FBU2dNLFNBQ1BsTixLQUNBc08scUJBQ0EsQ0FBQ3JDLE1BQU0sT0FBTyxLQUFLLElBQUlBLEdBQUdnRiwyQkFBMkIsS0FBTWhGLENBQUFBLE1BQU0sT0FBTyxLQUFLLElBQUlBLEdBQUdpRix1QkFBdUIsSUFBSTtZQUM3RyxHQUFHakYsRUFBRTtZQUNMYSxTQUFTLEtBQUs7UUFDaEIsSUFBSTtZQUNGLEdBQUdiLEVBQUU7UUFDUDtJQUVKO0lBQ0EsSUFBSUEsTUFBT0EsQ0FBQUEsR0FBR2dGLDJCQUEyQixJQUFJaEYsR0FBR2lGLHVCQUF1QixHQUFHO1FBQ3hFLE1BQU1DLDBCQUEwQkMsOEJBQThCbkY7UUFDOUQsT0FBTy9LLE9BQU93TSxXQUFXLENBQUN5RDtJQUM1QixPQUFPO1FBQ0wsT0FBT2pRLE9BQU93TSxXQUFXLENBQUNVO0lBQzVCO0FBQ0Y7QUFDQSxTQUFTZ0QsOEJBQThCL0UsU0FBUztJQUM5QyxNQUFNSCxjQUFjLElBQUlDO0lBQ3hCLElBQUlrRixlQUFlO0lBQ25CLElBQUlqRixxQkFBcUI7SUFDekIsSUFBSWtGLG9DQUFvQztJQUN4QyxJQUFJM0Isd0JBQXdCO0lBQzVCLElBQUk0Qix1QkFBdUJsRixTQUFTLENBQUMwRSxtQ0FBbUMsSUFBSSxFQUFFO0lBQzlFLE1BQU1uRyxTQUFTSjtJQUNmLE9BQU8sSUFBSWMsZ0JBQWdCO1FBQ3pCLE1BQU1RLFdBQVV6TCxLQUFLLEVBQUVtTCxVQUFVO1lBQy9CLE1BQU1oSyxVQUFVb0osT0FBT3ZLO1lBQ3ZCaVIscUNBQXFDOVA7WUFDckMsTUFBTWdRLHlCQUF5QkgsZ0JBQWlCN1AsQ0FBQUEsUUFBUWlRLFVBQVUsQ0FBQyx3QkFBd0JqUSxRQUFRaVEsVUFBVSxDQUFDLGlCQUFnQjtZQUM5SCxJQUFJRCx3QkFBd0I7Z0JBQzFCN0Isd0JBQXdCO2dCQUN4QnZELHNCQUFzQjVLO2dCQUN0QjZQLGVBQWU7Z0JBQ2Y7WUFDRjtZQUNBLElBQUksQ0FBQzFCLHVCQUF1QjtnQkFDMUJuRSxXQUFXSyxPQUFPLENBQ2hCSyxZQUFZSyxNQUFNLENBQUNuQyxpQkFBaUIsUUFBUTVJO2dCQUU5QztZQUNGLE9BQU87Z0JBQ0w0SyxzQkFBc0I1SztZQUN4QjtRQUNGO1FBQ0EsTUFBTWtMLE9BQU1sQixVQUFVO1lBQ3BCLElBQUk7Z0JBQ0YsSUFBSSxDQUFDNkYsZ0JBQWdCMUIseUJBQTBCdEQsQ0FBQUEsVUFBVTRFLDJCQUEyQixJQUFJNUUsVUFBVTZFLHVCQUF1QixHQUFHO29CQUMxSHZCLHdCQUF3QjtvQkFDeEIsTUFBTStCLFVBQVV2SCxLQUFLbEMsS0FBSyxDQUFDbUU7b0JBQzNCLElBQUl1RiwwQkFBMEI7MkJBQ3pCSjtxQkFDSjtvQkFDRCxJQUFJSyxtQkFBbUIsS0FBSztvQkFDNUIsSUFBSXZGLFVBQVU0RSwyQkFBMkIsRUFBRTt3QkFDekMsSUFBSVMsUUFBUXZKLGFBQWEsS0FBSyxLQUFLLEdBQUc7NEJBQ3BDMEosUUFBUUMsSUFBSSxDQUNWO3dCQUVKO3dCQUNBLE1BQU1DLG1CQUFtQjVILEtBQUtsQyxLQUFLLENBQ2pDeUosUUFBUXZKLGFBQWEsQ0FBQ0MsU0FBUzt3QkFFakN3SixtQkFBbUIsTUFBTXZGLFVBQVU0RSwyQkFBMkIsQ0FDNUQ7NEJBQ0VqSixNQUFNMEosUUFBUXZKLGFBQWEsQ0FBQ0gsSUFBSTs0QkFDaENJLFdBQVcySjt3QkFDYixHQUNBLENBQUNDOzRCQUNDTCwwQkFBMEI7bUNBQ3JCSjtnQ0FDSDtvQ0FDRXZNLE1BQU07b0NBQ05SLFNBQVM7b0NBQ1QyRCxlQUFldUosUUFBUXZKLGFBQWE7Z0NBQ3RDO2dDQUNBO29DQUNFbkQsTUFBTTtvQ0FDTmdELE1BQU0wSixRQUFRdkosYUFBYSxDQUFDSCxJQUFJO29DQUNoQ3hELFNBQVMyRixLQUFLSSxTQUFTLENBQUN5SDtnQ0FDMUI7NkJBQ0Q7NEJBQ0QsT0FBT0w7d0JBQ1Q7b0JBRUo7b0JBQ0EsSUFBSXRGLFVBQVU2RSx1QkFBdUIsRUFBRTt3QkFDckMsTUFBTTVCLFlBQVk7NEJBQ2hCMkMsT0FBTyxFQUFFO3dCQUNYO3dCQUNBLEtBQUssTUFBTUMsUUFBUVIsUUFBUXpJLFVBQVUsQ0FBRTs0QkFDckNxRyxVQUFVMkMsS0FBSyxDQUFDbE4sSUFBSSxDQUFDO2dDQUNuQjJELElBQUl3SixLQUFLeEosRUFBRTtnQ0FDWHpELE1BQU07Z0NBQ05rTixNQUFNO29DQUNKbkssTUFBTWtLLEtBQUs5SSxRQUFRLENBQUNwQixJQUFJO29DQUN4QkksV0FBVytCLEtBQUtsQyxLQUFLLENBQUNpSyxLQUFLOUksUUFBUSxDQUFDaEIsU0FBUztnQ0FDL0M7NEJBQ0Y7d0JBQ0Y7d0JBQ0EsSUFBSWdLLGdCQUFnQjt3QkFDcEIsSUFBSTs0QkFDRlIsbUJBQW1CLE1BQU12RixVQUFVNkUsdUJBQXVCLENBQ3hENUIsV0FDQSxDQUFDMEM7Z0NBQ0MsSUFBSUEsUUFBUTtvQ0FDVixNQUFNLEVBQUVLLFlBQVksRUFBRUMsYUFBYSxFQUFFQyxnQkFBZ0IsRUFBRSxHQUFHUDtvQ0FDMURMLDBCQUEwQjsyQ0FDckJBO3dDQUNILCtEQUErRDsyQ0FDNURTLGtCQUFrQixJQUFJOzRDQUN2QjtnREFDRXBOLE1BQU07Z0RBQ05SLFNBQVM7Z0RBQ1R5RSxZQUFZeUksUUFBUXpJLFVBQVUsQ0FBQzdELEdBQUcsQ0FDaEMsQ0FBQytELEtBQVE7d0RBQ1BULElBQUlTLEdBQUdULEVBQUU7d0RBQ1R6RCxNQUFNO3dEQUNObUUsVUFBVTs0REFDUnBCLE1BQU1tQixHQUFHQyxRQUFRLENBQUNwQixJQUFJOzREQUN0Qix3R0FBd0c7NERBQ3hHSSxXQUFXK0IsS0FBS0ksU0FBUyxDQUN2QnBCLEdBQUdDLFFBQVEsQ0FBQ2hCLFNBQVM7d0RBRXpCO29EQUNGOzRDQUVKO3lDQUNELEdBQUcsRUFBRTt3Q0FDTiwwQ0FBMEM7d0NBQzFDOzRDQUNFcEQsTUFBTTs0Q0FDTnFOOzRDQUNBckssTUFBTXNLOzRDQUNOOU4sU0FBUzJGLEtBQUtJLFNBQVMsQ0FBQ2dJO3dDQUMxQjtxQ0FDRDtvQ0FDREg7Z0NBQ0Y7Z0NBQ0EsT0FBT1Q7NEJBQ1Q7d0JBRUosRUFBRSxPQUFPYSxHQUFHOzRCQUNWWCxRQUFRdEssS0FBSyxDQUFDLDBDQUEwQ2lMO3dCQUMxRDtvQkFDRjtvQkFDQSxJQUFJLENBQUNaLGtCQUFrQjt3QkFDckJwRyxXQUFXSyxPQUFPLENBQ2hCSyxZQUFZSyxNQUFNLENBQ2hCbkMsaUJBQ0VzSCxRQUFRdkosYUFBYSxHQUFHLGtCQUFrQixjQUMxQyxvQ0FBb0M7d0JBQ3BDZ0MsS0FBS2xDLEtBQUssQ0FBQ21FO3dCQUlqQjtvQkFDRixPQUFPLElBQUksT0FBT3dGLHFCQUFxQixVQUFVO3dCQUMvQ3BHLFdBQVdLLE9BQU8sQ0FDaEJLLFlBQVlLLE1BQU0sQ0FBQ25DLGlCQUFpQixRQUFRd0g7d0JBRTlDTixvQ0FBb0NNO3dCQUNwQztvQkFDRjtvQkFDQSxNQUFNYSxvQkFBb0I7d0JBQ3hCLEdBQUdwRyxTQUFTO3dCQUNaQyxTQUFTLEtBQUs7b0JBQ2hCO29CQUNBRCxVQUFVUyxPQUFPLEdBQUcsS0FBSztvQkFDekIsTUFBTTRGLGVBQWUxQixhQUFhWSxrQkFBa0I7d0JBQ2xELEdBQUdhLGlCQUFpQjt3QkFDcEIsQ0FBQzFCLG1DQUFtQyxFQUFFWTtvQkFDeEM7b0JBQ0EsTUFBTXhRLFNBQVN1UixhQUFhdFIsU0FBUztvQkFDckMsTUFBTyxLQUFNO3dCQUNYLE1BQU0sRUFBRWQsSUFBSSxFQUFFQyxLQUFLLEVBQUUsR0FBRyxNQUFNWSxPQUFPRSxJQUFJO3dCQUN6QyxJQUFJZixNQUFNOzRCQUNSO3dCQUNGO3dCQUNBa0wsV0FBV0ssT0FBTyxDQUFDdEw7b0JBQ3JCO2dCQUNGO1lBQ0YsU0FBVTtnQkFDUixJQUFJOEwsVUFBVVMsT0FBTyxJQUFJd0UsbUNBQW1DO29CQUMxRCxNQUFNakYsVUFBVVMsT0FBTyxDQUFDd0U7Z0JBQzFCO1lBQ0Y7UUFDRjtJQUNGO0FBQ0Y7QUFFQSxtQkFBbUI7QUFDbkIsSUFBSXFCLHdCQUF3QjVFLE9BQU82RSxHQUFHLENBQUM7QUFDdkMsSUFBSUMsc0NBQXNDLEtBQUs7QUFFL0MscUJBQXFCO0FBQ3JCLFNBQVNDLG1CQUFtQmpTLFlBQVk7SUFDdEMsSUFBSWtTLGVBQWVsUztJQUNuQixJQUFJbVMsU0FBUztJQUNiLElBQUksRUFBRWxTLEdBQUcsRUFBRWxCLE9BQU8sRUFBRUMsTUFBTSxFQUFFLEdBQUdlLHFCQUFxQkM7SUFDcEQsU0FBU29TLGFBQWFDLE1BQU07UUFDMUIsSUFBSUYsUUFBUTtZQUNWLE1BQU0sSUFBSXJSLE1BQU11UixTQUFTO1FBQzNCO0lBQ0Y7SUFDQSxJQUFJQztJQUNKLFNBQVNDO1FBQ1AsSUFBSUMsSUFBc0MsRUFBRTtZQUMxQyxJQUFJRixnQkFBZ0I7Z0JBQ2xCRyxhQUFhSDtZQUNmO1lBQ0FBLGlCQUFpQm5NLFdBQVc7Z0JBQzFCNkssUUFBUUMsSUFBSSxDQUNWO1lBRUosR0FBR2U7UUFDTDtJQUNGO0lBQ0FPO0lBQ0EsT0FBTztRQUNMOztLQUVDLEdBQ0Q3UyxPQUFPTztRQUNQOztLQUVDLEdBQ0R3QyxRQUFPL0MsS0FBSztZQUNWMFMsYUFBYTtZQUNiLElBQUkxUyxVQUFVd1MsY0FBYztnQkFDMUJLO2dCQUNBO1lBQ0Y7WUFDQSxNQUFNRyxhQUFhNVQ7WUFDbkJvVCxlQUFleFM7WUFDZlgsUUFBUTtnQkFBRVcsT0FBT3dTO2dCQUFjelMsTUFBTTtnQkFBT0ssTUFBTTRTLFdBQVd6VCxPQUFPO1lBQUM7WUFDckVGLFVBQVUyVCxXQUFXM1QsT0FBTztZQUM1QkMsU0FBUzBULFdBQVcxVCxNQUFNO1lBQzFCdVQ7UUFDRjtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7S0FlQyxHQUNENVMsUUFBT0QsS0FBSztZQUNWMFMsYUFBYTtZQUNiLE1BQU1NLGFBQWE1VDtZQUNuQm9ULGVBQWV4UztZQUNmWCxRQUFRO2dCQUFFVztnQkFBT0QsTUFBTTtnQkFBT0UsUUFBUTtnQkFBTUcsTUFBTTRTLFdBQVd6VCxPQUFPO1lBQUM7WUFDckVGLFVBQVUyVCxXQUFXM1QsT0FBTztZQUM1QkMsU0FBUzBULFdBQVcxVCxNQUFNO1lBQzFCdVQ7UUFDRjtRQUNBOzs7S0FHQyxHQUNEN0wsT0FBTUEsS0FBSztZQUNUMEwsYUFBYTtZQUNiLElBQUlFLGdCQUFnQjtnQkFDbEJHLGFBQWFIO1lBQ2Y7WUFDQUgsU0FBUztZQUNUblQsT0FBTzBIO1FBQ1Q7UUFDQTs7Ozs7S0FLQyxHQUNEakgsTUFBSyxHQUFHa0MsSUFBSTtZQUNWeVEsYUFBYTtZQUNiLElBQUlFLGdCQUFnQjtnQkFDbEJHLGFBQWFIO1lBQ2Y7WUFDQUgsU0FBUztZQUNULElBQUl4USxLQUFLQyxNQUFNLEVBQUU7Z0JBQ2Y3QyxRQUFRO29CQUFFVyxPQUFPaUMsSUFBSSxDQUFDLEVBQUU7b0JBQUVsQyxNQUFNO2dCQUFLO2dCQUNyQztZQUNGO1lBQ0FWLFFBQVE7Z0JBQUVXLE9BQU93UztnQkFBY3pTLE1BQU07WUFBSztRQUM1QztJQUNGO0FBQ0Y7QUFDQSxJQUFJa1QsaUNBQWlDekYsT0FBTztBQUM1QyxTQUFTMEYsc0JBQXNCNVMsWUFBWTtJQUN6QyxNQUFNNlMsbUJBQW1CN1Msd0JBQXdCeU0sa0JBQWtCLE9BQU96TSxpQkFBaUIsWUFBWUEsaUJBQWlCLFFBQVEsZUFBZUEsZ0JBQWdCLE9BQU9BLGFBQWFPLFNBQVMsS0FBSyxjQUFjLFlBQVlQLGdCQUFnQixPQUFPQSxhQUFhOFMsTUFBTSxLQUFLO0lBQzFRLElBQUksQ0FBQ0Qsa0JBQWtCO1FBQ3JCLE9BQU9FLDBCQUEwQi9TO0lBQ25DO0lBQ0EsTUFBTWdULGtCQUFrQkQ7SUFDeEJDLGVBQWUsQ0FBQ0wsK0JBQStCLEdBQUc7SUFDakQ7UUFDQyxJQUFJO1lBQ0YsTUFBTXJTLFNBQVNOLGFBQWFPLFNBQVM7WUFDckMsTUFBTyxLQUFNO2dCQUNYLE1BQU0sRUFBRWIsS0FBSyxFQUFFRCxJQUFJLEVBQUUsR0FBRyxNQUFNYSxPQUFPRSxJQUFJO2dCQUN6QyxJQUFJZixNQUFNO29CQUNSO2dCQUNGO2dCQUNBdVQsZUFBZSxDQUFDTCwrQkFBK0IsR0FBRztnQkFDbEQsSUFBSSxPQUFPalQsVUFBVSxVQUFVO29CQUM3QnNULGdCQUFnQnJULE1BQU0sQ0FBQ0Q7Z0JBQ3pCLE9BQU87b0JBQ0xzVCxnQkFBZ0J2USxNQUFNLENBQUMvQztnQkFDekI7Z0JBQ0FzVCxlQUFlLENBQUNMLCtCQUErQixHQUFHO1lBQ3BEO1lBQ0FLLGVBQWUsQ0FBQ0wsK0JBQStCLEdBQUc7WUFDbERLLGdCQUFnQnZULElBQUk7UUFDdEIsRUFBRSxPQUFPa1MsR0FBRztZQUNWcUIsZUFBZSxDQUFDTCwrQkFBK0IsR0FBRztZQUNsREssZ0JBQWdCdE0sS0FBSyxDQUFDaUw7UUFDeEI7SUFDRjtJQUNBLE9BQU9xQjtBQUNUO0FBQ0EsU0FBU0QsMEJBQTBCL1MsWUFBWTtJQUM3QyxJQUFJbVMsU0FBUztJQUNiLElBQUlXLFNBQVM7SUFDYixJQUFJSixhQUFhNVQ7SUFDakIsSUFBSW9ULGVBQWVsUztJQUNuQixJQUFJaVQ7SUFDSixJQUFJQyxpQkFBaUJSLFdBQVd6VCxPQUFPO0lBQ3ZDLElBQUlrVTtJQUNKLFNBQVNmLGFBQWFDLE1BQU07UUFDMUIsSUFBSUYsUUFBUTtZQUNWLE1BQU0sSUFBSXJSLE1BQU11UixTQUFTO1FBQzNCO1FBQ0EsSUFBSVMsUUFBUTtZQUNWLE1BQU0sSUFBSWhTLE1BQ1J1UixTQUFTO1FBRWI7SUFDRjtJQUNBLElBQUlDO0lBQ0osU0FBU0M7UUFDUCxJQUFJQyxJQUFzQyxFQUFFO1lBQzFDLElBQUlGLGdCQUFnQjtnQkFDbEJHLGFBQWFIO1lBQ2Y7WUFDQUEsaUJBQWlCbk0sV0FBVztnQkFDMUI2SyxRQUFRQyxJQUFJLENBQ1Y7WUFFSixHQUFHZTtRQUNMO0lBQ0Y7SUFDQU87SUFDQSxTQUFTYSxjQUFjQyxZQUFZO1FBQ2pDLElBQUlDO1FBQ0osSUFBSUwsaUJBQWlCLEtBQUssR0FBRztZQUMzQkssT0FBTztnQkFBRTVNLE9BQU91TTtZQUFhO1FBQy9CLE9BQU87WUFDTCxJQUFJRSxxQkFBcUIsQ0FBQ0UsY0FBYztnQkFDdENDLE9BQU87b0JBQUV6USxNQUFNc1E7Z0JBQWtCO1lBQ25DLE9BQU87Z0JBQ0xHLE9BQU87b0JBQUVDLE1BQU1yQjtnQkFBYTtZQUM5QjtRQUNGO1FBQ0EsSUFBSWdCLGdCQUFnQjtZQUNsQkksS0FBS3hULElBQUksR0FBR29UO1FBQ2Q7UUFDQSxJQUFJRyxjQUFjO1lBQ2hCQyxLQUFLbFAsSUFBSSxHQUFHME47UUFDZDtRQUNBLE9BQU93QjtJQUNUO0lBQ0EsU0FBU0Usa0JBQWtCOVQsS0FBSztRQUM5QnlULG9CQUFvQixLQUFLO1FBQ3pCLElBQUksT0FBT3pULFVBQVUsVUFBVTtZQUM3QixJQUFJLE9BQU93UyxpQkFBaUIsVUFBVTtnQkFDcEMsSUFBSXhTLE1BQU1rUixVQUFVLENBQUNzQixlQUFlO29CQUNsQ2lCLG9CQUFvQjt3QkFBQzt3QkFBR3pULE1BQU13SixLQUFLLENBQUNnSixhQUFhdFEsTUFBTTtxQkFBRTtnQkFDM0Q7WUFDRjtRQUNGO1FBQ0FzUSxlQUFleFM7SUFDakI7SUFDQSxPQUFPO1FBQ0w7OztLQUdDLEdBQ0QsSUFBSSxDQUFDaVQsK0JBQStCLEVBQUMzUixNQUFPO1lBQzFDOFIsU0FBUzlSO1FBQ1g7UUFDQTs7OztLQUlDLEdBQ0QsSUFBSXRCLFNBQVE7WUFDVixPQUFPMFQsY0FBYztRQUN2QjtRQUNBOztLQUVDLEdBQ0QzUSxRQUFPL0MsS0FBSztZQUNWMFMsYUFBYTtZQUNiLE1BQU1xQixrQkFBa0JmLFdBQVczVCxPQUFPO1lBQzFDMlQsYUFBYTVUO1lBQ2IwVSxrQkFBa0I5VDtZQUNsQndULGlCQUFpQlIsV0FBV3pULE9BQU87WUFDbkN3VSxnQkFBZ0JMO1lBQ2hCYjtRQUNGO1FBQ0E7Ozs7Ozs7Ozs7O0tBV0MsR0FDRDVTLFFBQU9ELEtBQUs7WUFDVjBTLGFBQWE7WUFDYixJQUFJLE9BQU9GLGlCQUFpQixZQUFZLE9BQU9BLGlCQUFpQixhQUFhO2dCQUMzRSxNQUFNLElBQUlwUixNQUNSLENBQUMsd0RBQXdELEVBQUUsT0FBT29SLGFBQWEsQ0FBQztZQUVwRjtZQUNBLElBQUksT0FBT3hTLFVBQVUsVUFBVTtnQkFDN0IsTUFBTSxJQUFJb0IsTUFDUixDQUFDLGdEQUFnRCxFQUFFLE9BQU9wQixNQUFNLENBQUM7WUFFckU7WUFDQSxNQUFNK1Qsa0JBQWtCZixXQUFXM1QsT0FBTztZQUMxQzJULGFBQWE1VDtZQUNiLElBQUksT0FBT29ULGlCQUFpQixVQUFVO2dCQUNwQ2lCLG9CQUFvQjtvQkFBQztvQkFBR3pUO2lCQUFNO2dCQUM5QndTLGVBQWVBLGVBQWV4UztZQUNoQyxPQUFPO2dCQUNMeVQsb0JBQW9CLEtBQUs7Z0JBQ3pCakIsZUFBZXhTO1lBQ2pCO1lBQ0F3VCxpQkFBaUJSLFdBQVd6VCxPQUFPO1lBQ25Dd1UsZ0JBQWdCTDtZQUNoQmI7UUFDRjtRQUNBOzs7O0tBSUMsR0FDRDdMLE9BQU1BLEtBQUs7WUFDVDBMLGFBQWE7WUFDYixJQUFJRSxnQkFBZ0I7Z0JBQ2xCRyxhQUFhSDtZQUNmO1lBQ0FILFNBQVM7WUFDVGMsZUFBZXZNO1lBQ2Z3TSxpQkFBaUIsS0FBSztZQUN0QlIsV0FBVzNULE9BQU8sQ0FBQztnQkFBRTJIO1lBQU07UUFDN0I7UUFDQTs7Ozs7OztLQU9DLEdBQ0RqSCxNQUFLLEdBQUdrQyxJQUFJO1lBQ1Z5USxhQUFhO1lBQ2IsSUFBSUUsZ0JBQWdCO2dCQUNsQkcsYUFBYUg7WUFDZjtZQUNBSCxTQUFTO1lBQ1RlLGlCQUFpQixLQUFLO1lBQ3RCLElBQUl2UixLQUFLQyxNQUFNLEVBQUU7Z0JBQ2Y0UixrQkFBa0I3UixJQUFJLENBQUMsRUFBRTtnQkFDekIrUSxXQUFXM1QsT0FBTyxDQUFDcVU7Z0JBQ25CO1lBQ0Y7WUFDQVYsV0FBVzNULE9BQU8sQ0FBQyxDQUFDO1FBQ3RCO0lBQ0Y7QUFDRjtBQUNBLFNBQVMyVSxPQUFPelMsT0FBTztJQUNyQixNQUFNMFMsS0FBSzFCLG1CQUFtQmhSLFFBQVEyUyxPQUFPO0lBQzdDLE1BQU12UCxPQUFPcEQsUUFBUW9ELElBQUksR0FBR3BELFFBQVFvRCxJQUFJLEdBQUcsQ0FBQyxFQUFFVixPQUFPLEVBQUUsR0FBS0E7SUFDNUQsTUFBTWtRLFlBQVk1UyxRQUFRNFMsU0FBUyxHQUFHQyxPQUFPQyxPQUFPLENBQUM5UyxRQUFRNFMsU0FBUyxFQUFFdFAsR0FBRyxDQUN6RSxDQUFDLENBQUM0QyxNQUFNLEVBQUU2TSxXQUFXLEVBQUVDLFVBQVUsRUFBRSxDQUFDO1FBQ2xDLE9BQU87WUFDTDlNO1lBQ0E2TTtZQUNBQyxZQUFZblIsOERBQWdCQSxDQUFDbVI7UUFDL0I7SUFDRixLQUNFLEtBQUs7SUFDVCxNQUFNN0MsUUFBUW5RLFFBQVFtUSxLQUFLLEdBQUcwQyxPQUFPQyxPQUFPLENBQUM5UyxRQUFRbVEsS0FBSyxFQUFFN00sR0FBRyxDQUM3RCxDQUFDLENBQUM0QyxNQUFNLEVBQUU2TSxXQUFXLEVBQUVDLFVBQVUsRUFBRSxDQUFDO1FBQ2xDLE9BQU87WUFDTDdQLE1BQU07WUFDTm1FLFVBQVU7Z0JBQ1JwQjtnQkFDQTZNO2dCQUNBQyxZQUFZblIsOERBQWdCQSxDQUFDbVI7WUFDL0I7UUFDRjtJQUNGLEtBQ0UsS0FBSztJQUNULElBQUlKLGFBQWF6QyxPQUFPO1FBQ3RCLE1BQU0sSUFBSXRRLE1BQ1I7SUFFSjtJQUNBLElBQUlvVDtJQUNKLGVBQWVDLGFBQWF4UyxJQUFJLEVBQUV5UyxRQUFRLEVBQUVqVixHQUFHO1FBQzdDLElBQUksQ0FBQ2lWLFVBQ0g7UUFDRixNQUFNMUIsYUFBYTVUO1FBQ25CLElBQUlvVixVQUFVO1lBQ1pBLFdBQVdBLFNBQVNHLElBQUksQ0FBQyxJQUFNM0IsV0FBV3pULE9BQU87UUFDbkQsT0FBTztZQUNMaVYsV0FBV3hCLFdBQVd6VCxPQUFPO1FBQy9CO1FBQ0EsTUFBTVMsUUFBUTBVLFNBQVN6UztRQUN2QixJQUFJakMsaUJBQWlCUixXQUFXUSxTQUFTLE9BQU9BLFVBQVUsWUFBWSxVQUFVQSxTQUFTLE9BQU9BLE1BQU0yVSxJQUFJLEtBQUssWUFBWTtZQUN6SCxNQUFNQyxPQUFPLE1BQU01VTtZQUNuQlAsSUFBSXNELE1BQU0sQ0FBQzZSO1lBQ1g1QixXQUFXM1QsT0FBTyxDQUFDLEtBQUs7UUFDMUIsT0FBTyxJQUFJVyxTQUFTLE9BQU9BLFVBQVUsWUFBWXdOLE9BQU9DLGFBQWEsSUFBSXpOLE9BQU87WUFDOUUsTUFBTXVOLEtBQUt2TjtZQUNYLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVELElBQUksRUFBRUMsT0FBTzZVLE1BQU0sRUFBRSxHQUFHLE1BQU10SCxHQUFHbk4sSUFBSTtnQkFDN0NYLElBQUlzRCxNQUFNLENBQUM4UjtnQkFDWCxJQUFJOVUsTUFDRjtZQUNKO1lBQ0FpVCxXQUFXM1QsT0FBTyxDQUFDLEtBQUs7UUFDMUIsT0FBTyxJQUFJVyxTQUFTLE9BQU9BLFVBQVUsWUFBWXdOLE9BQU9zSCxRQUFRLElBQUk5VSxPQUFPO1lBQ3pFLE1BQU11TixLQUFLdk47WUFDWCxNQUFPLEtBQU07Z0JBQ1gsTUFBTSxFQUFFRCxJQUFJLEVBQUVDLE9BQU82VSxNQUFNLEVBQUUsR0FBR3RILEdBQUduTixJQUFJO2dCQUN2Q1gsSUFBSXNELE1BQU0sQ0FBQzhSO2dCQUNYLElBQUk5VSxNQUNGO1lBQ0o7WUFDQWlULFdBQVczVCxPQUFPLENBQUMsS0FBSztRQUMxQixPQUFPO1lBQ0xJLElBQUlzRCxNQUFNLENBQUMvQztZQUNYZ1QsV0FBVzNULE9BQU8sQ0FBQyxLQUFLO1FBQzFCO0lBQ0Y7SUFDQztRQUNDLElBQUkwVixjQUFjO1FBQ2xCLElBQUk5USxVQUFVO1FBQ2R2RCxjQUNFK1AsYUFDRSxNQUFNbFAsUUFBUXlULFFBQVEsQ0FBQ0MsSUFBSSxDQUFDQyxXQUFXLENBQUNDLE1BQU0sQ0FBQztZQUM3QzdHLE9BQU8vTSxRQUFRK00sS0FBSztZQUNwQjFKLFVBQVVyRCxRQUFRcUQsUUFBUTtZQUMxQlcsYUFBYWhFLFFBQVFnRSxXQUFXO1lBQ2hDNUUsUUFBUTtZQUNSLEdBQUd3VCxZQUFZO2dCQUNiQTtZQUNGLElBQUksQ0FBQyxDQUFDO1lBQ04sR0FBR3pDLFFBQVE7Z0JBQ1RBO1lBQ0YsSUFBSSxDQUFDLENBQUM7UUFDUixJQUNBO1lBQ0UsR0FBR3lDLFlBQVk7Z0JBQ2IsTUFBTXpELDZCQUE0QjBFLG1CQUFtQjtvQkFDbkQsSUFBSTNTLElBQUlDO29CQUNScVMsY0FBYztvQkFDZE4sYUFDRVcsb0JBQW9Cdk4sU0FBUyxFQUM3QixDQUFDbkYsS0FBSyxDQUFDRCxLQUFLbEIsUUFBUTRTLFNBQVMsS0FBSyxPQUFPLEtBQUssSUFBSTFSLEVBQUUsQ0FBQzJTLG9CQUFvQjNOLElBQUksQ0FBQyxLQUFLLE9BQU8sS0FBSyxJQUFJL0UsR0FBR3NSLE1BQU0sRUFDNUdDO2dCQUVKO1lBQ0YsSUFBSSxDQUFDLENBQUM7WUFDTixHQUFHdkMsUUFBUTtnQkFDVCxNQUFNZix5QkFBd0IwRSxlQUFlO29CQUMzQyxJQUFJNVMsSUFBSUM7b0JBQ1JxUyxjQUFjO29CQUNkLEtBQUssTUFBTXBELFFBQVEwRCxnQkFBZ0IzRCxLQUFLLENBQUU7d0JBQ3hDK0MsYUFDRTlDLEtBQUtDLElBQUksQ0FBQy9KLFNBQVMsRUFDbkIsQ0FBQ25GLEtBQUssQ0FBQ0QsS0FBS2xCLFFBQVFtUSxLQUFLLEtBQUssT0FBTyxLQUFLLElBQUlqUCxFQUFFLENBQUNrUCxLQUFLQyxJQUFJLENBQUNuSyxJQUFJLENBQUMsS0FBSyxPQUFPLEtBQUssSUFBSS9FLEdBQUdzUixNQUFNLEVBQzlGQztvQkFFSjtnQkFDRjtZQUNGLElBQUksQ0FBQyxDQUFDO1lBQ04vSCxRQUFPcE0sS0FBSztnQkFDVm1FLFdBQVduRTtnQkFDWDJVLGFBQWE7b0JBQUV4UTtvQkFBU2xFLE1BQU07b0JBQU9tRCxPQUFPcEQ7Z0JBQU0sR0FBRzZFLE1BQU1zUDtZQUM3RDtZQUNBLE1BQU0xSDtnQkFDSixJQUFJd0ksYUFBYTtvQkFDZixNQUFNUDtvQkFDTlAsR0FBR2xVLElBQUk7b0JBQ1A7Z0JBQ0Y7Z0JBQ0EwVSxhQUFhO29CQUFFeFE7b0JBQVNsRSxNQUFNO2dCQUFLLEdBQUc0RSxNQUFNc1A7Z0JBQzVDLE1BQU1PO2dCQUNOUCxHQUFHbFUsSUFBSTtZQUNUO1FBQ0Y7SUFHTjtJQUNBLE9BQU9rVSxHQUFHalUsS0FBSztBQUNqQjtBQUVBLDhCQUE4QjtBQUlKO0FBQzZCO0FBQ3ZELElBQUl5VixzQkFBc0IsQ0FBQyxFQUFFeFIsT0FBTyxFQUFFLEdBQUtBO0FBQzNDLGVBQWV5UixTQUFTLEVBQ3RCcEgsS0FBSyxFQUNMb0QsS0FBSyxFQUNMbk4sTUFBTSxFQUNORixNQUFNLEVBQ05PLFFBQVEsRUFDUmdCLFVBQVUsRUFDVitQLFdBQVcsRUFDWHpCLE9BQU8sRUFDUHZQLElBQUksRUFDSixHQUFHaVIsVUFDSjtJQUNDLElBQUksT0FBT3RILFVBQVUsVUFBVTtRQUM3QixNQUFNLElBQUlsTixNQUNSO0lBRUo7SUFDQSxJQUFJLGVBQWV3VSxVQUFVO1FBQzNCLE1BQU0sSUFBSXhVLE1BQ1I7SUFFSjtJQUNBLElBQUksY0FBY3dVLFVBQVU7UUFDMUIsTUFBTSxJQUFJeFUsTUFDUjtJQUVKO0lBQ0EsSUFBSXNRLE9BQU87UUFDVCxLQUFLLE1BQU0sQ0FBQ2pLLE1BQU1rSyxLQUFLLElBQUl5QyxPQUFPQyxPQUFPLENBQUMzQyxPQUFRO1lBQ2hELElBQUksWUFBWUMsTUFBTTtnQkFDcEIsTUFBTSxJQUFJdlEsTUFDUiw2R0FBNkdxRztZQUVqSDtRQUNGO0lBQ0Y7SUFDQSxNQUFNd00sS0FBSzFCLG1CQUFtQjJCO0lBQzlCLE1BQU0yQixhQUFhbFIsUUFBUThRO0lBQzNCLElBQUlqQjtJQUNKLGVBQWVDLGFBQWF4UyxJQUFJLEVBQUV5UyxRQUFRLEVBQUVqVixHQUFHO1FBQzdDLElBQUksQ0FBQ2lWLFVBQ0g7UUFDRixNQUFNMUIsYUFBYTVUO1FBQ25CLElBQUlvVixVQUFVO1lBQ1pBLFdBQVdBLFNBQVNHLElBQUksQ0FBQyxJQUFNM0IsV0FBV3pULE9BQU87UUFDbkQsT0FBTztZQUNMaVYsV0FBV3hCLFdBQVd6VCxPQUFPO1FBQy9CO1FBQ0EsTUFBTVMsUUFBUTBVLFlBQVl6UztRQUMxQixJQUFJakMsaUJBQWlCUixXQUFXUSxTQUFTLE9BQU9BLFVBQVUsWUFBWSxVQUFVQSxTQUFTLE9BQU9BLE1BQU0yVSxJQUFJLEtBQUssWUFBWTtZQUN6SCxNQUFNQyxPQUFPLE1BQU01VTtZQUNuQlAsSUFBSXNELE1BQU0sQ0FBQzZSO1lBQ1g1QixXQUFXM1QsT0FBTyxDQUFDLEtBQUs7UUFDMUIsT0FBTyxJQUFJVyxTQUFTLE9BQU9BLFVBQVUsWUFBWXdOLE9BQU9DLGFBQWEsSUFBSXpOLE9BQU87WUFDOUUsTUFBTXVOLEtBQUt2TjtZQUNYLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVELElBQUksRUFBRUMsT0FBTzZVLE1BQU0sRUFBRSxHQUFHLE1BQU10SCxHQUFHbk4sSUFBSTtnQkFDN0NYLElBQUlzRCxNQUFNLENBQUM4UjtnQkFDWCxJQUFJOVUsTUFDRjtZQUNKO1lBQ0FpVCxXQUFXM1QsT0FBTyxDQUFDLEtBQUs7UUFDMUIsT0FBTyxJQUFJVyxTQUFTLE9BQU9BLFVBQVUsWUFBWXdOLE9BQU9zSCxRQUFRLElBQUk5VSxPQUFPO1lBQ3pFLE1BQU11TixLQUFLdk47WUFDWCxNQUFPLEtBQU07Z0JBQ1gsTUFBTSxFQUFFRCxJQUFJLEVBQUVDLE9BQU82VSxNQUFNLEVBQUUsR0FBR3RILEdBQUduTixJQUFJO2dCQUN2Q1gsSUFBSXNELE1BQU0sQ0FBQzhSO2dCQUNYLElBQUk5VSxNQUNGO1lBQ0o7WUFDQWlULFdBQVczVCxPQUFPLENBQUMsS0FBSztRQUMxQixPQUFPO1lBQ0xJLElBQUlzRCxNQUFNLENBQUMvQztZQUNYZ1QsV0FBVzNULE9BQU8sQ0FBQyxLQUFLO1FBQzFCO0lBQ0Y7SUFDQSxNQUFNeVcsUUFBUXBQLDRCQUE0QjtRQUFFZDtJQUFXO0lBQ3ZELE1BQU1tUSxrQkFBa0I1USxtQkFBbUI7UUFBRVo7UUFBUUY7UUFBUU87SUFBUztJQUN0RSxNQUFNNk0sU0FBUyxNQUFNcUUsTUFDbkIsSUFBTXhILE1BQU0wSCxRQUFRLENBQUM7WUFDbkJDLE1BQU07Z0JBQ0p2UixNQUFNO2dCQUNOZ04sT0FBT0EsU0FBUyxPQUFPLEtBQUssSUFBSTBDLE9BQU9DLE9BQU8sQ0FBQzNDLE9BQU83TSxHQUFHLENBQUMsQ0FBQyxDQUFDNEMsTUFBTWtLLEtBQUssR0FBTTt3QkFDM0VqTixNQUFNO3dCQUNOK0M7d0JBQ0E2TSxhQUFhM0MsS0FBSzJDLFdBQVc7d0JBQzdCQyxZQUFZdE8sdUJBQXVCMEwsS0FBSzRDLFVBQVU7b0JBQ3BEO1lBQ0Y7WUFDQSxHQUFHbFAsb0JBQW9CdVEsU0FBUztZQUNoQ00sYUFBYUgsZ0JBQWdCclIsSUFBSTtZQUNqQ0wsUUFBUUQsNkJBQTZCMlI7WUFDckNKO1FBQ0Y7SUFFRixNQUFNLENBQUNoVixRQUFRd1YsYUFBYSxHQUFHMUUsT0FBTzlRLE1BQU0sQ0FBQ3lWLEdBQUc7SUFDL0M7UUFDQyxJQUFJO1lBQ0YsSUFBSW5TLFVBQVU7WUFDZCxJQUFJb1MsY0FBYztZQUNsQixNQUFNelYsU0FBU3VWLGFBQWF0VixTQUFTO1lBQ3JDLE1BQU8sS0FBTTtnQkFDWCxNQUFNLEVBQUVkLElBQUksRUFBRUMsS0FBSyxFQUFFLEdBQUcsTUFBTVksT0FBT0UsSUFBSTtnQkFDekMsSUFBSWYsTUFDRjtnQkFDRixPQUFRQyxNQUFNMEUsSUFBSTtvQkFDaEIsS0FBSzt3QkFBYzs0QkFDakJULFdBQVdqRSxNQUFNc1csU0FBUzs0QkFDMUI3QixhQUNFO2dDQUFDO29DQUFFeFE7b0NBQVNsRSxNQUFNO29DQUFPbUQsT0FBT2xELE1BQU1zVyxTQUFTO2dDQUFDOzZCQUFFLEVBQ2xEVCxZQUNBNUI7NEJBRUY7d0JBQ0Y7b0JBQ0EsS0FBSzt3QkFBbUI7NEJBQ3RCb0MsY0FBYzs0QkFDZDt3QkFDRjtvQkFDQSxLQUFLO3dCQUFhOzRCQUNoQixNQUFNRSxXQUFXdlcsTUFBTXVXLFFBQVE7NEJBQy9CLElBQUksQ0FBQzdFLE9BQU87Z0NBQ1YsTUFBTSxJQUFJNkQsNkRBQWVBLENBQUM7b0NBQUVnQjtnQ0FBUzs0QkFDdkM7NEJBQ0EsTUFBTTVFLE9BQU9ELEtBQUssQ0FBQzZFLFNBQVM7NEJBQzVCLElBQUksQ0FBQzVFLE1BQU07Z0NBQ1QsTUFBTSxJQUFJNEQsNkRBQWVBLENBQUM7b0NBQ3hCZ0I7b0NBQ0FDLGdCQUFnQnBDLE9BQU9xQyxJQUFJLENBQUMvRTtnQ0FDOUI7NEJBQ0Y7NEJBQ0EsTUFBTWdGLGNBQWNsQixxRUFBYUEsQ0FBQztnQ0FDaEM3USxNQUFNM0UsTUFBTWlDLElBQUk7Z0NBQ2hCMFUsUUFBUWhGLEtBQUs0QyxVQUFVOzRCQUN6Qjs0QkFDQSxJQUFJbUMsWUFBWUUsT0FBTyxLQUFLLE9BQU87Z0NBQ2pDLE1BQU0sSUFBSXRCLHVFQUF5QkEsQ0FBQztvQ0FDbENpQjtvQ0FDQU0sVUFBVTdXLE1BQU1pQyxJQUFJO29DQUNwQjZVLE9BQU9KLFlBQVkxUCxLQUFLO2dDQUMxQjs0QkFDRjs0QkFDQXlOLGFBQ0U7Z0NBQ0VpQyxZQUFZMVcsS0FBSztnQ0FDakI7b0NBQ0V1VztvQ0FDQVEsWUFBWS9XLE1BQU0rVyxVQUFVO2dDQUM5Qjs2QkFDRCxFQUNEcEYsS0FBS3FGLFFBQVEsRUFDYi9DOzRCQUVGO3dCQUNGO29CQUNBLEtBQUs7d0JBQVM7NEJBQ1osTUFBTWpVLE1BQU1nSCxLQUFLO3dCQUNuQjtvQkFDQSxLQUFLO3dCQUFVLENBQ2Y7Z0JBQ0Y7WUFDRjtZQUNBLElBQUlxUCxhQUFhO2dCQUNmLE1BQU03QjtnQkFDTlAsR0FBR2xVLElBQUk7WUFDVCxPQUFPO2dCQUNMMFUsYUFBYTtvQkFBQzt3QkFBRXhRO3dCQUFTbEUsTUFBTTtvQkFBSztpQkFBRSxFQUFFOFYsWUFBWTVCO2dCQUNwRCxNQUFNTztnQkFDTlAsR0FBR2xVLElBQUk7WUFDVDtRQUNGLEVBQUUsT0FBT2lILE9BQU87WUFDZGlOLEdBQUdqTixLQUFLLENBQUNBO1FBQ1g7SUFDRjtJQUNBLE9BQU87UUFDTCxHQUFHeUssTUFBTTtRQUNUOVE7UUFDQVgsT0FBT2lVLEdBQUdqVSxLQUFLO0lBQ2pCO0FBQ0Y7QUFFQSxtQkFBbUI7QUFDYTtBQUNzQjtBQUNOO0lBQ2pDb1gsY0FBQUEsMEZBQUFBO0FBQWYsMEJBQTJCLEVBQ3pCQyxNQUFNLEVBQ045VixPQUFPLEVBQ1IsRUFBRUQsTUFBSyxFQUFFLEdBQUdXLElBQUk7SUFFZixPQUFPLE1BQU1aLFlBQ1g7UUFDRUMsT0FBQUE7UUFDQUM7SUFDRixHQUNBO1FBQ0UsTUFBTWtRLFNBQVMsTUFBTTRGLFVBQVVwVjtRQUMvQkY7UUFDQSxPQUFPO1lBQUNGO1lBQTBCNFA7U0FBTztJQUMzQztBQUVKO0FBQ0EsU0FBUzZGLFdBQVdELE1BQU0sRUFBRTlWLE9BQU87SUFDakMsT0FBTzZWLFlBQVlHLElBQUksQ0FBQyxNQUFNO1FBQUVGO1FBQVE5VjtJQUFRO0FBQ2xEO0FBQ0EsU0FBU2lXLFNBQVMsRUFDaEJDLE9BQU8sRUFDUEMsY0FBYyxFQUNkQyxjQUFjLEVBQ2RoVixZQUFZLEVBQ1ppVixZQUFZLEVBQ2I7SUFDQyxNQUFNQyxpQkFBaUIsQ0FBQztJQUN4QixJQUFLLE1BQU1wUSxRQUFRZ1EsUUFBUztRQUMxQkksY0FBYyxDQUFDcFEsS0FBSyxHQUFHNlAsV0FBV0csT0FBTyxDQUFDaFEsS0FBSyxFQUFFO1lBQy9DOUU7UUFDRjtJQUNGO0lBQ0EsTUFBTW1WLHFCQUFxQkYsZUFBZU4sV0FBV00sY0FBYyxDQUFDLEtBQUssS0FBSztJQUM5RSxNQUFNRyxLQUFLLE9BQU9DO1FBQ2hCLElBQUl2VixJQUFJQztRQUNSLElBQUksdU1BQW9CdVUsRUFBRTtZQUN4QixNQUFNLElBQUk3VixNQUNSO1FBRUo7UUFDQSxJQUFJNlcsVUFBVSxDQUFDeFYsS0FBS3VWLE1BQU1MLGNBQWMsS0FBSyxPQUFPbFYsS0FBS2tWO1FBQ3pELElBQUlPLFVBQVUsQ0FBQ3hWLEtBQUtzVixNQUFNTixjQUFjLEtBQUssT0FBT2hWLEtBQUtnVjtRQUN6RCxJQUFJUyxlQUFlLEtBQUs7UUFDeEIsSUFBSUwsb0JBQW9CO1lBQ3RCLE1BQU0sQ0FBQ00saUJBQWlCQyxXQUFXLEdBQUcsTUFBTVAsbUJBQW1CSTtZQUMvRCxJQUFJRyxlQUFlLEtBQUssR0FBRztnQkFDekJGLGVBQWVDO2dCQUNmSCxVQUFVSTtZQUNaO1FBQ0Y7UUFDQSxPQUFPLGFBQWEsR0FBR2xCLHNEQUFJQSxDQUN6QkQsZ0VBQWtCQSxFQUNsQjtZQUNFVztZQUNBQztZQUNBSCxnQkFBZ0JNO1lBQ2hCUCxnQkFBZ0JRO1lBQ2hCSSxxQkFBcUJIO1lBQ3JCalksVUFBVThYLE1BQU05WCxRQUFRO1FBQzFCO0lBRUo7SUFDQSxPQUFPNlg7QUFDVDtBQVNFLENBQ0YsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGRldmlhcy1raXQtcHJvL25leHRqcy10ZW1wbGF0ZS8uL25vZGVfbW9kdWxlcy9haS9yc2MvZGlzdC9yc2Mtc2VydmVyLm1qcz9iOTdjIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJzYy9haS1zdGF0ZS50c3hcbmltcG9ydCB7IEFzeW5jTG9jYWxTdG9yYWdlIH0gZnJvbSBcImFzeW5jX2hvb2tzXCI7XG5pbXBvcnQgKiBhcyBqc29uZGlmZnBhdGNoIGZyb20gXCJqc29uZGlmZnBhdGNoXCI7XG5cbi8vIHJzYy91dGlscy50c3hcbmltcG9ydCB7IFN1c3BlbnNlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBGcmFnbWVudCwganN4LCBqc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpIHtcbiAgbGV0IHJlc29sdmUsIHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59XG52YXIgUiA9IFtcbiAgYXN5bmMgKHtcbiAgICBjLFxuICAgIC8vIGN1cnJlbnRcbiAgICBuXG4gICAgLy8gbmV4dFxuICB9KSA9PiB7XG4gICAgY29uc3QgY2h1bmsgPSBhd2FpdCBuO1xuICAgIGlmIChjaHVuay5kb25lKSB7XG4gICAgICByZXR1cm4gY2h1bmsudmFsdWU7XG4gICAgfVxuICAgIGlmIChjaHVuay5hcHBlbmQpIHtcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4cyhGcmFnbWVudCwgeyBjaGlsZHJlbjogW1xuICAgICAgICBjLFxuICAgICAgICAvKiBAX19QVVJFX18gKi8ganN4KFN1c3BlbnNlLCB7IGZhbGxiYWNrOiBjaHVuay52YWx1ZSwgY2hpbGRyZW46IC8qIEBfX1BVUkVfXyAqLyBqc3goUiwgeyBjOiBjaHVuay52YWx1ZSwgbjogY2h1bmsubmV4dCB9KSB9KVxuICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goU3VzcGVuc2UsIHsgZmFsbGJhY2s6IGNodW5rLnZhbHVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChSLCB7IGM6IGNodW5rLnZhbHVlLCBuOiBjaHVuay5uZXh0IH0pIH0pO1xuICB9XG5dWzBdO1xuZnVuY3Rpb24gY3JlYXRlU3VzcGVuc2VkQ2h1bmsoaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICByZXR1cm4ge1xuICAgIHJvdzogLyogQF9fUFVSRV9fICovIGpzeChTdXNwZW5zZSwgeyBmYWxsYmFjazogaW5pdGlhbFZhbHVlLCBjaGlsZHJlbjogLyogQF9fUFVSRV9fICovIGpzeChSLCB7IGM6IGluaXRpYWxWYWx1ZSwgbjogcHJvbWlzZSB9KSB9KSxcbiAgICByZXNvbHZlLFxuICAgIHJlamVjdFxuICB9O1xufVxudmFyIGlzRnVuY3Rpb24gPSAoeCkgPT4gdHlwZW9mIHggPT09IFwiZnVuY3Rpb25cIjtcbnZhciBjb25zdW1lU3RyZWFtID0gYXN5bmMgKHN0cmVhbSkgPT4ge1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyBkb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgIGlmIChkb25lKVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbi8vIHJzYy9haS1zdGF0ZS50c3hcbnZhciBhc3luY0FJU3RhdGVTdG9yYWdlID0gbmV3IEFzeW5jTG9jYWxTdG9yYWdlKCk7XG5mdW5jdGlvbiBnZXRBSVN0YXRlU3RvcmVPclRocm93KG1lc3NhZ2UpIHtcbiAgY29uc3Qgc3RvcmUgPSBhc3luY0FJU3RhdGVTdG9yYWdlLmdldFN0b3JlKCk7XG4gIGlmICghc3RvcmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIH1cbiAgcmV0dXJuIHN0b3JlO1xufVxuZnVuY3Rpb24gd2l0aEFJU3RhdGUoeyBzdGF0ZSwgb3B0aW9ucyB9LCBmbikge1xuICByZXR1cm4gYXN5bmNBSVN0YXRlU3RvcmFnZS5ydW4oXG4gICAge1xuICAgICAgY3VycmVudFN0YXRlOiBzdGF0ZSxcbiAgICAgIG9yaWdpbmFsU3RhdGU6IHN0YXRlLFxuICAgICAgc2VhbGVkOiBmYWxzZSxcbiAgICAgIG9wdGlvbnNcbiAgICB9LFxuICAgIGZuXG4gICk7XG59XG5mdW5jdGlvbiBnZXRBSVN0YXRlRGVsdGFQcm9taXNlKCkge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXCJJbnRlcm5hbCBlcnJvciBvY2N1cnJlZC5cIik7XG4gIHJldHVybiBzdG9yZS5tdXRhdGlvbkRlbHRhUHJvbWlzZTtcbn1cbmZ1bmN0aW9uIHNlYWxNdXRhYmxlQUlTdGF0ZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBnZXRBSVN0YXRlU3RvcmVPclRocm93KFwiSW50ZXJuYWwgZXJyb3Igb2NjdXJyZWQuXCIpO1xuICBzdG9yZS5zZWFsZWQgPSB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0QUlTdGF0ZSguLi5hcmdzKSB7XG4gIGNvbnN0IHN0b3JlID0gZ2V0QUlTdGF0ZVN0b3JlT3JUaHJvdyhcbiAgICBcImBnZXRBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCB3aXRoaW4gYW4gQUkgQWN0aW9uLlwiXG4gICk7XG4gIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBZb3UgY2FuJ3QgZ2V0IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgIGtleVxuICAgICAgICApfVwiIGZpZWxkIGZyb20gdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZS5jdXJyZW50U3RhdGVba2V5XTtcbiAgfVxuICByZXR1cm4gc3RvcmUuY3VycmVudFN0YXRlO1xufVxuZnVuY3Rpb24gZ2V0TXV0YWJsZUFJU3RhdGUoLi4uYXJncykge1xuICBjb25zdCBzdG9yZSA9IGdldEFJU3RhdGVTdG9yZU9yVGhyb3coXG4gICAgXCJgZ2V0TXV0YWJsZUFJU3RhdGVgIG11c3QgYmUgY2FsbGVkIHdpdGhpbiBhbiBBSSBBY3Rpb24uXCJcbiAgKTtcbiAgaWYgKHN0b3JlLnNlYWxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYGdldE11dGFibGVBSVN0YXRlYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgcmV0dXJuaW5nIGZyb20gYW4gQUkgQWN0aW9uLiBQbGVhc2UgbW92ZSBpdCB0byB0aGUgdG9wIGxldmVsIG9mIHRoZSBBY3Rpb24ncyBmdW5jdGlvbiBib2R5LlwiXG4gICAgKTtcbiAgfVxuICBpZiAoIXN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlKSB7XG4gICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHN0b3JlLm11dGF0aW9uRGVsdGFQcm9taXNlID0gcHJvbWlzZTtcbiAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZSA9IHJlc29sdmU7XG4gIH1cbiAgZnVuY3Rpb24gZG9VcGRhdGUobmV3U3RhdGUsIGRvbmUpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmUuY3VycmVudFN0YXRlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGFyZ3NbMF07XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgWW91IGNhbid0IG1vZGlmeSB0aGUgXCIke1N0cmluZyhcbiAgICAgICAgICAgIGtleVxuICAgICAgICAgICl9XCIgZmllbGQgb2YgdGhlIEFJIHN0YXRlIGJlY2F1c2UgaXQncyBub3QgYW4gb2JqZWN0LmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzRnVuY3Rpb24obmV3U3RhdGUpKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlKHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9yZS5jdXJyZW50U3RhdGUgPSBuZXdTdGF0ZShzdG9yZS5jdXJyZW50U3RhdGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHN0b3JlLmN1cnJlbnRTdGF0ZVthcmdzWzBdXSA9IG5ld1N0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RvcmUuY3VycmVudFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICB9XG4gICAgfVxuICAgIChfYiA9IChfYSA9IHN0b3JlLm9wdGlvbnMpLm9uU2V0QUlTdGF0ZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgIGtleTogYXJncy5sZW5ndGggPiAwID8gYXJnc1swXSA6IHZvaWQgMCxcbiAgICAgIHN0YXRlOiBzdG9yZS5jdXJyZW50U3RhdGUsXG4gICAgICBkb25lXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgbXV0YWJsZVN0YXRlID0ge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBrZXkgPSBhcmdzWzBdO1xuICAgICAgICBpZiAodHlwZW9mIHN0b3JlLmN1cnJlbnRTdGF0ZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBZb3UgY2FuJ3QgZ2V0IHRoZSBcIiR7U3RyaW5nKFxuICAgICAgICAgICAgICBrZXlcbiAgICAgICAgICAgICl9XCIgZmllbGQgZnJvbSB0aGUgQUkgc3RhdGUgYmVjYXVzZSBpdCdzIG5vdCBhbiBvYmplY3QuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZVtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0b3JlLmN1cnJlbnRTdGF0ZTtcbiAgICB9LFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gdXBkYXRlKG5ld0FJU3RhdGUpIHtcbiAgICAgIGRvVXBkYXRlKG5ld0FJU3RhdGUsIGZhbHNlKTtcbiAgICB9LFxuICAgIGRvbmU6IGZ1bmN0aW9uIGRvbmUoLi4uZG9uZUFyZ3MpIHtcbiAgICAgIGlmIChkb25lQXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGRvVXBkYXRlKGRvbmVBcmdzWzBdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRlbHRhID0ganNvbmRpZmZwYXRjaC5kaWZmKHN0b3JlLm9yaWdpbmFsU3RhdGUsIHN0b3JlLmN1cnJlbnRTdGF0ZSk7XG4gICAgICBzdG9yZS5tdXRhdGlvbkRlbHRhUmVzb2x2ZShkZWx0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbXV0YWJsZVN0YXRlO1xufVxuXG4vLyByc2Mvc3RyZWFtYWJsZS50c3hcbmltcG9ydCB6b2RUb0pzb25TY2hlbWEyIGZyb20gXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjtcblxuLy8gY29yZS91dGlsL2RldGVjdC1pbWFnZS1taW1ldHlwZS50c1xudmFyIG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9naWZcIiwgYnl0ZXM6IFs3MSwgNzMsIDcwXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3BuZ1wiLCBieXRlczogWzEzNywgODAsIDc4LCA3MV0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9qcGVnXCIsIGJ5dGVzOiBbMjU1LCAyMTZdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2Uvd2VicFwiLCBieXRlczogWzgyLCA3MywgNzAsIDcwXSB9XG5dO1xuZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZSkge1xuICBmb3IgKGNvbnN0IHsgYnl0ZXMsIG1pbWVUeXBlIH0gb2YgbWltZVR5cGVTaWduYXR1cmVzKSB7XG4gICAgaWYgKGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiYgYnl0ZXMuZXZlcnkoKGJ5dGUsIGluZGV4KSA9PiBpbWFnZVtpbmRleF0gPT09IGJ5dGUpKSB7XG4gICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHsgSW52YWxpZERhdGFDb250ZW50RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoY29udGVudCk7XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWxhbmd1YWdlLW1vZGVsLXByb21wdC50c1xuZnVuY3Rpb24gY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdChwcm9tcHQpIHtcbiAgY29uc3QgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzID0gW107XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwpIHtcbiAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaCh7IHJvbGU6IFwic3lzdGVtXCIsIGNvbnRlbnQ6IHByb21wdC5zeXN0ZW0gfSk7XG4gIH1cbiAgc3dpdGNoIChwcm9tcHQudHlwZSkge1xuICAgIGNhc2UgXCJwcm9tcHRcIjoge1xuICAgICAgbGFuZ3VhZ2VNb2RlbE1lc3NhZ2VzLnB1c2goe1xuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IHByb21wdC5wcm9tcHQgfV1cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJtZXNzYWdlc1wiOiB7XG4gICAgICBsYW5ndWFnZU1vZGVsTWVzc2FnZXMucHVzaChcbiAgICAgICAgLi4ucHJvbXB0Lm1lc3NhZ2VzLm1hcCgobWVzc2FnZSkgPT4ge1xuICAgICAgICAgIHN3aXRjaCAobWVzc2FnZS5yb2xlKSB7XG4gICAgICAgICAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgICAgICAgICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IG1lc3NhZ2UuY29udGVudCB9XVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgICAgICAgICBjb250ZW50OiBtZXNzYWdlLmNvbnRlbnQubWFwKFxuICAgICAgICAgICAgICAgICAgKHBhcnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHBhcnQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaW1hZ2VcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnQuaW1hZ2UgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2U6IHBhcnQuaW1hZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWltZVR5cGU6IHBhcnQubWltZVR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlVWludDggPSBjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnQuaW1hZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVVpbnQ4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBtaW1lVHlwZTogKF9hID0gcGFydC5taW1lVHlwZSkgIT0gbnVsbCA/IF9hIDogZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZVVpbnQ4KVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB7IHJvbGU6IFwiYXNzaXN0YW50XCIsIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IF9leGhhdXN0aXZlQ2hlY2sgPSBwcm9tcHQ7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHByb21wdCB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsYW5ndWFnZU1vZGVsTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2dldC12YWxpZGF0ZWQtcHJvbXB0LnRzXG5pbXBvcnQgeyBJbnZhbGlkUHJvbXB0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZ2V0VmFsaWRhdGVkUHJvbXB0KHByb21wdCkge1xuICBpZiAocHJvbXB0LnByb21wdCA9PSBudWxsICYmIHByb21wdC5tZXNzYWdlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRQcm9tcHRFcnJvcih7XG4gICAgICBwcm9tcHQsXG4gICAgICBtZXNzYWdlOiBcInByb21wdCBvciBtZXNzYWdlcyBtdXN0IGJlIGRlZmluZWRcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IGFuZCBtZXNzYWdlcyBjYW5ub3QgYmUgZGVmaW5lZCBhdCB0aGUgc2FtZSB0aW1lXCJcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gcHJvbXB0LnByb21wdCAhPSBudWxsID8ge1xuICAgIHR5cGU6IFwicHJvbXB0XCIsXG4gICAgcHJvbXB0OiBwcm9tcHQucHJvbXB0LFxuICAgIG1lc3NhZ2VzOiB2b2lkIDAsXG4gICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtXG4gIH0gOiB7XG4gICAgdHlwZTogXCJtZXNzYWdlc1wiLFxuICAgIHByb21wdDogdm9pZCAwLFxuICAgIG1lc3NhZ2VzOiBwcm9tcHQubWVzc2FnZXMsXG4gICAgLy8gb25seSBwb3NzaWJsZSBjYXNlIGJjIG9mIGNoZWNrcyBhYm92ZVxuICAgIHN5c3RlbTogcHJvbXB0LnN5c3RlbVxuICB9O1xufVxuXG4vLyBjb3JlL3Byb21wdC9wcmVwYXJlLWNhbGwtc2V0dGluZ3MudHNcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIHByZXBhcmVDYWxsU2V0dGluZ3Moe1xuICBtYXhUb2tlbnMsXG4gIHRlbXBlcmF0dXJlLFxuICB0b3BQLFxuICBwcmVzZW5jZVBlbmFsdHksXG4gIGZyZXF1ZW5jeVBlbmFsdHksXG4gIHNlZWQsXG4gIG1heFJldHJpZXNcbn0pIHtcbiAgaWYgKG1heFRva2VucyAhPSBudWxsKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFRva2VucykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4VG9rZW5zIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcIm1heFRva2Vuc1wiLFxuICAgICAgICB2YWx1ZTogbWF4VG9rZW5zLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFRva2VucyBtdXN0IGJlID49IDFcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmICh0ZW1wZXJhdHVyZSAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0ZW1wZXJhdHVyZSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRlbXBlcmF0dXJlXCIsXG4gICAgICAgIHZhbHVlOiB0ZW1wZXJhdHVyZSxcbiAgICAgICAgbWVzc2FnZTogXCJ0ZW1wZXJhdHVyZSBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wUCAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BQICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wUFwiLFxuICAgICAgICB2YWx1ZTogdG9wUCxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BQIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgIT0gbnVsbCA/IHRlbXBlcmF0dXJlIDogMCxcbiAgICB0b3BQLFxuICAgIHByZXNlbmNlUGVuYWx0eSxcbiAgICBmcmVxdWVuY3lQZW5hbHR5LFxuICAgIHNlZWQsXG4gICAgbWF4UmV0cmllczogbWF4UmV0cmllcyAhPSBudWxsID8gbWF4UmV0cmllcyA6IDJcbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL2NvbnZlcnQtem9kLXRvLWpzb24tc2NoZW1hLnRzXG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjtcbmZ1bmN0aW9uIGNvbnZlcnRab2RUb0pTT05TY2hlbWEoem9kU2NoZW1hKSB7XG4gIHJldHVybiB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hKTtcbn1cblxuLy8gY29yZS91dGlsL3JldHJ5LXdpdGgtZXhwb25lbnRpYWwtYmFja29mZi50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yLCBSZXRyeUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGdldEVycm9yTWVzc2FnZSwgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS91dGlsL2RlbGF5LnRzXG5hc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIGRlbGF5SW5NcykpO1xufVxuXG4vLyBjb3JlL3V0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG52YXIgcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmID0gKHtcbiAgbWF4UmV0cmllcyA9IDIsXG4gIGluaXRpYWxEZWxheUluTXMgPSAyZTMsXG4gIGJhY2tvZmZGYWN0b3IgPSAyXG59ID0ge30pID0+IGFzeW5jIChmKSA9PiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKGYsIHtcbiAgbWF4UmV0cmllcyxcbiAgZGVsYXlJbk1zOiBpbml0aWFsRGVsYXlJbk1zLFxuICBiYWNrb2ZmRmFjdG9yXG59KTtcbmFzeW5jIGZ1bmN0aW9uIF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0sIGVycm9ycyA9IFtdKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGF3YWl0IGYoKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIGlmIChtYXhSZXRyaWVzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlKGVycm9yKTtcbiAgICBjb25zdCBuZXdFcnJvcnMgPSBbLi4uZXJyb3JzLCBlcnJvcl07XG4gICAgY29uc3QgdHJ5TnVtYmVyID0gbmV3RXJyb3JzLmxlbmd0aDtcbiAgICBpZiAodHJ5TnVtYmVyID4gbWF4UmV0cmllcykge1xuICAgICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cy4gTGFzdCBlcnJvcjogJHtlcnJvck1lc3NhZ2V9YCxcbiAgICAgICAgcmVhc29uOiBcIm1heFJldHJpZXNFeGNlZWRlZFwiLFxuICAgICAgICBlcnJvcnM6IG5ld0Vycm9yc1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikgJiYgZXJyb3IuaXNSZXRyeWFibGUgPT09IHRydWUgJiYgdHJ5TnVtYmVyIDw9IG1heFJldHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlbGF5KGRlbGF5SW5Ncyk7XG4gICAgICByZXR1cm4gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihcbiAgICAgICAgZixcbiAgICAgICAgeyBtYXhSZXRyaWVzLCBkZWxheUluTXM6IGJhY2tvZmZGYWN0b3IgKiBkZWxheUluTXMsIGJhY2tvZmZGYWN0b3IgfSxcbiAgICAgICAgbmV3RXJyb3JzXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAodHJ5TnVtYmVyID09PSAxKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFJldHJ5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYEZhaWxlZCBhZnRlciAke3RyeU51bWJlcn0gYXR0ZW1wdHMgd2l0aCBub24tcmV0cnlhYmxlIGVycm9yOiAnJHtlcnJvck1lc3NhZ2V9J2AsXG4gICAgICByZWFzb246IFwiZXJyb3JOb3RSZXRyeWFibGVcIixcbiAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc2hhcmVkL3N0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIxXCIsXG4gIG5hbWU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmdW5jdGlvbl9jYWxsXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fCAhKFwibmFtZVwiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNFwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdmFsdWUpIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJjb250ZW50XCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5pZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8ICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgXCJ0ZXh0XCIgaW4gaXRlbSAmJiBpdGVtLnRleHQgIT0gbnVsbCAmJiB0eXBlb2YgaXRlbS50ZXh0ID09PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBpdGVtLnRleHQgJiYgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjVcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRocmVhZElkXCIgaW4gdmFsdWUpIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBkYXRhTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNlwiLFxuICBuYW1lOiBcImRhdGFfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiZGF0YVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiN1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbHNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbF9jYWxsc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHwgdmFsdWUudG9vbF9jYWxscy5zb21lKFxuICAgICAgKHRjKSA9PiB0YyA9PSBudWxsIHx8IHR5cGVvZiB0YyAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB0YykgfHwgdHlwZW9mIHRjLmlkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0eXBlXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy50eXBlICE9PSBcInN0cmluZ1wiIHx8ICEoXCJmdW5jdGlvblwiIGluIHRjKSB8fCB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gXCJvYmplY3RcIiB8fCAhKFwiYXJndW1lbnRzXCIgaW4gdGMuZnVuY3Rpb24pIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOFwiLFxuICBuYW1lOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0XG5dO1xudmFyIHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1QYXJ0LFxuICBbbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydC5jb2RlXTogbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVcbn07XG52YXIgdmFsaWRDb2RlcyA9IHN0cmVhbVBhcnRzLm1hcCgocGFydCkgPT4gcGFydC5jb2RlKTtcbnZhciBwYXJzZVN0cmVhbVBhcnQgPSAobGluZSkgPT4ge1xuICBjb25zdCBmaXJzdFNlcGFyYXRvckluZGV4ID0gbGluZS5pbmRleE9mKFwiOlwiKTtcbiAgaWYgKGZpcnN0U2VwYXJhdG9ySW5kZXggPT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIE5vIHNlcGFyYXRvciBmb3VuZC5cIik7XG4gIH1cbiAgY29uc3QgcHJlZml4ID0gbGluZS5zbGljZSgwLCBmaXJzdFNlcGFyYXRvckluZGV4KTtcbiAgaWYgKCF2YWxpZENvZGVzLmluY2x1ZGVzKHByZWZpeCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBJbnZhbGlkIGNvZGUgJHtwcmVmaXh9LmApO1xuICB9XG4gIGNvbnN0IGNvZGUgPSBwcmVmaXg7XG4gIGNvbnN0IHRleHRWYWx1ZSA9IGxpbmUuc2xpY2UoZmlyc3RTZXBhcmF0b3JJbmRleCArIDEpO1xuICBjb25zdCBqc29uVmFsdWUgPSBKU09OLnBhcnNlKHRleHRWYWx1ZSk7XG4gIHJldHVybiBzdHJlYW1QYXJ0c0J5Q29kZVtjb2RlXS5wYXJzZShqc29uVmFsdWUpO1xufTtcbmZ1bmN0aW9uIGZvcm1hdFN0cmVhbVBhcnQodHlwZSwgdmFsdWUpIHtcbiAgY29uc3Qgc3RyZWFtUGFydCA9IHN0cmVhbVBhcnRzLmZpbmQoKHBhcnQpID0+IHBhcnQubmFtZSA9PT0gdHlwZSk7XG4gIGlmICghc3RyZWFtUGFydCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdHJlYW0gcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgcmV0dXJuIGAke3N0cmVhbVBhcnQuY29kZX06JHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9XG5gO1xufVxuXG4vLyBzaGFyZWQvdXRpbHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICBpZiAoIWNodW5rKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIik7XG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxuXG4vLyBzdHJlYW1zL2FpLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJldmVudFwiICYmIGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCIgfHwgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgZXZlbnQuZXZlbnQgPT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXIgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSwge1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICAgIH0pIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlKVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlci5mZWVkKHRleHREZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgY29uc3QgY2FsbGJhY2tzID0gY2IgfHwge307XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydClcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICB9LFxuICAgIGFzeW5jIHRyYW5zZm9ybShtZXNzYWdlLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZS5jb250ZW50O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY29udGVudDtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4oY29udGVudCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICByZXR1cm4gXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGxcIiBpbiBjYWxsYmFja3M7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQpID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFJU3RyZWFtKHJlc3BvbnNlLCBjdXN0b21QYXJzZXIsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihcIlJlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGF3YWl0ICgoX2EgPSBpdC5yZXR1cm4pID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGl0LCByZWFzb24pKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBkZWNvZGVyLmRlY29kZShjaHVuayk7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgbWVzc2FnZSkpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL29wZW5haS1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlT3BlbkFJU3RyZWFtKCkge1xuICBjb25zdCBleHRyYWN0ID0gY2h1bmtUb1RleHQoKTtcbiAgcmV0dXJuIChkYXRhKSA9PiBleHRyYWN0KEpTT04ucGFyc2UoZGF0YSkpO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUoc3RyZWFtKSB7XG4gIGNvbnN0IGV4dHJhY3QgPSBjaHVua1RvVGV4dCgpO1xuICBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBpZiAoXCJwcm9tcHRGaWx0ZXJSZXN1bHRzXCIgaW4gY2h1bmspIHtcbiAgICAgIGNodW5rID0ge1xuICAgICAgICBpZDogY2h1bmsuaWQsXG4gICAgICAgIGNyZWF0ZWQ6IGNodW5rLmNyZWF0ZWQuZ2V0RGF0ZSgpLFxuICAgICAgICBvYmplY3Q6IGNodW5rLm9iamVjdCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIG1vZGVsOiBjaHVuay5tb2RlbCxcbiAgICAgICAgLy8gbm90IGV4cG9zZWQgYnkgQXp1cmUgQVBJXG4gICAgICAgIGNob2ljZXM6IGNodW5rLmNob2ljZXMubWFwKChjaG9pY2UpID0+IHtcbiAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbHRhOiB7XG4gICAgICAgICAgICAgIGNvbnRlbnQ6IChfYSA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNvbnRlbnQsXG4gICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IChfYiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmZ1bmN0aW9uQ2FsbCxcbiAgICAgICAgICAgICAgcm9sZTogKF9jID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2Mucm9sZSxcbiAgICAgICAgICAgICAgdG9vbF9jYWxsczogKChfZSA9IChfZCA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLmxlbmd0aCkgPyAoX2cgPSAoX2YgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfZi50b29sQ2FsbHMpID09IG51bGwgPyB2b2lkIDAgOiBfZy5tYXAoKHRvb2xDYWxsLCBpbmRleCkgPT4gKHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBpZDogdG9vbENhbGwuaWQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb246IHRvb2xDYWxsLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHR5cGU6IHRvb2xDYWxsLnR5cGVcbiAgICAgICAgICAgICAgfSkpIDogdm9pZCAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmluaXNoX3JlYXNvbjogY2hvaWNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIGluZGV4OiBjaG9pY2UuaW5kZXhcbiAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGV4dHJhY3QoY2h1bmspO1xuICAgIGlmICh0ZXh0KVxuICAgICAgeWllbGQgdGV4dDtcbiAgfVxufVxuZnVuY3Rpb24gY2h1bmtUb1RleHQoKSB7XG4gIGNvbnN0IHRyaW1TdGFydE9mU3RyZWFtID0gdHJpbVN0YXJ0T2ZTdHJlYW1IZWxwZXIoKTtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbjtcbiAgcmV0dXJuIChqc29uKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2ksIF9qLCBfaywgX2wsIF9tLCBfbiwgX28sIF9wLCBfcSwgX3I7XG4gICAgaWYgKGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSkge1xuICAgICAgY29uc3QgZGVsdGEgPSAoX2EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYS5kZWx0YTtcbiAgICAgIGlmICgoX2IgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2IubmFtZSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSB0cnVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogYHtcImZ1bmN0aW9uX2NhbGxcIjoge1wibmFtZVwiOiBcIiR7ZGVsdGEuZnVuY3Rpb25fY2FsbC5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9lID0gKF9kID0gKF9jID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9jWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2QuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZS5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsID0gZGVsdGEudG9vbF9jYWxsc1swXTtcbiAgICAgICAgaWYgKHRvb2xDYWxsLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgICBjb250ZW50OiBge1widG9vbF9jYWxsc1wiOlsge1wiaWRcIjogXCIke3Rvb2xDYWxsLmlkfVwiLCBcInR5cGVcIjogXCJmdW5jdGlvblwiLCBcImZ1bmN0aW9uXCI6IHtcIm5hbWVcIjogXCIkeyhfZiA9IHRvb2xDYWxsLmZ1bmN0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2YubmFtZX1cIiwgXCJhcmd1bWVudHNcIjogXCJgXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGBcIn19LCB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9nID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZy5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKChfaCA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfaC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9pID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKF9sID0gKF9rID0gKF9qID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9qWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2suZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfbC5hcmd1bWVudHMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6IGNsZWFudXBBcmd1bWVudHMoKF9vID0gKF9uID0gKF9tID0gZGVsdGEudG9vbF9jYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9tWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX24uZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfby5hcmd1bWVudHMpXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKChfcCA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9wLmZpbmlzaF9yZWFzb24pID09PSBcImZ1bmN0aW9uX2NhbGxcIiB8fCAoKF9xID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3EuZmluaXNoX3JlYXNvbikgPT09IFwic3RvcFwiKSkge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19J1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKChfciA9IGpzb24uY2hvaWNlc1swXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yLmZpbmlzaF9yZWFzb24pID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgICBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgIGNvbnRlbnQ6ICdcIn19XX0nXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHRleHQgPSB0cmltU3RhcnRPZlN0cmVhbShcbiAgICAgIGlzQ2hhdENvbXBsZXRpb25DaHVuayhqc29uKSAmJiBqc29uLmNob2ljZXNbMF0uZGVsdGEuY29udGVudCA/IGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50IDogaXNDb21wbGV0aW9uKGpzb24pID8ganNvbi5jaG9pY2VzWzBdLnRleHQgOiBcIlwiXG4gICAgKTtcbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbiAgZnVuY3Rpb24gY2xlYW51cEFyZ3VtZW50cyhhcmd1bWVudENodW5rKSB7XG4gICAgbGV0IGVzY2FwZWRQYXJ0aWFsSnNvbiA9IGFyZ3VtZW50Q2h1bmsucmVwbGFjZSgvXFxcXC9nLCBcIlxcXFxcXFxcXCIpLnJlcGxhY2UoL1xcLy9nLCBcIlxcXFwvXCIpLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKS5yZXBsYWNlKC9cXG4vZywgXCJcXFxcblwiKS5yZXBsYWNlKC9cXHIvZywgXCJcXFxcclwiKS5yZXBsYWNlKC9cXHQvZywgXCJcXFxcdFwiKS5yZXBsYWNlKC9cXGYvZywgXCJcXFxcZlwiKTtcbiAgICByZXR1cm4gYCR7ZXNjYXBlZFBhcnRpYWxKc29ufWA7XG4gIH1cbn1cbnZhciBfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sID0gU3ltYm9sKFxuICBcImludGVybmFsX29wZW5haV9mbl9tZXNzYWdlc1wiXG4pO1xuZnVuY3Rpb24gaXNDaGF0Q29tcGxldGlvbkNodW5rKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcImRlbHRhXCIgaW4gZGF0YS5jaG9pY2VzWzBdO1xufVxuZnVuY3Rpb24gaXNDb21wbGV0aW9uKGRhdGEpIHtcbiAgcmV0dXJuIFwiY2hvaWNlc1wiIGluIGRhdGEgJiYgZGF0YS5jaG9pY2VzICYmIGRhdGEuY2hvaWNlc1swXSAmJiBcInRleHRcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBPcGVuQUlTdHJlYW0ocmVzLCBjYWxsYmFja3MpIHtcbiAgY29uc3QgY2IgPSBjYWxsYmFja3M7XG4gIGxldCBzdHJlYW07XG4gIGlmIChTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiByZXMpIHtcbiAgICBzdHJlYW0gPSByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUocmVzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgICB9IDoge1xuICAgICAgICAgIC4uLmNiXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IEFJU3RyZWFtKFxuICAgICAgcmVzLFxuICAgICAgcGFyc2VPcGVuQUlTdHJlYW0oKSxcbiAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgLi4uY2IsXG4gICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY2JcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGlmIChjYiAmJiAoY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyID0gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2IpO1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYWxsYmFja3MpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlKGNodW5rKTtcbiAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9IGlzRmlyc3RDaHVuayAmJiAobWVzc2FnZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykgfHwgbWVzc2FnZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpO1xuICAgICAgaWYgKHNob3VsZEhhbmRsZUFzRnVuY3Rpb24pIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzRnVuY3Rpb25TdHJlYW1pbmdJbikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQoXCJ0ZXh0XCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gbWVzc2FnZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaXNGaXJzdENodW5rICYmIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCB8fCBjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpKSB7XG4gICAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gZmFsc2U7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZCA9IEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgICBsZXQgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIF07XG4gICAgICAgICAgbGV0IGZ1bmN0aW9uUmVzcG9uc2UgPSB2b2lkIDA7XG4gICAgICAgICAgaWYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXJndW1lbnRzUGF5bG9hZCA9IEpTT04ucGFyc2UoXG4gICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHNcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50czogYXJndW1lbnRzUGF5bG9hZFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBbXG4gICAgICAgICAgICAgICAgICAuLi5mdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogcGF5bG9hZC5mdW5jdGlvbl9jYWxsXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByb2xlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHBheWxvYWQuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBKU09OLnN0cmluZ2lmeShyZXN1bHQpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxscyA9IHtcbiAgICAgICAgICAgICAgdG9vbHM6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCB0b29sIG9mIHBheWxvYWQudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICB0b29sQ2FsbHMudG9vbHMucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHRvb2wuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5wYXJzZSh0b29sLmZ1bmN0aW9uLmFyZ3VtZW50cylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3BvbnNlSW5kZXggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25Ub29sQ2FsbChcbiAgICAgICAgICAgICAgICB0b29sQ2FsbHMsXG4gICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHRvb2xfY2FsbF9pZCwgZnVuY3Rpb25fbmFtZSwgdG9vbF9jYWxsX3Jlc3VsdCB9ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAuLi5uZXdGdW5jdGlvbkNhbGxNZXNzYWdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBPbmx5IGFwcGVuZCB0aGUgYXNzaXN0YW50IG1lc3NhZ2UgaWYgaXQncyB0aGUgZmlyc3QgcmVzcG9uc2VcbiAgICAgICAgICAgICAgICAgICAgICAuLi5yZXNwb25zZUluZGV4ID09PSAwID8gW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxzOiBwYXlsb2FkLnRvb2xfY2FsbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0YykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0Yy5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHRjLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyBhbiBvYmplY3QgdG8gdGhlIHVzZXIsIGJ1dCBhcyB0aGUgQVBJIGV4cGVjdHMgYSBzdHJpbmcsIHdlIG5lZWQgdG8gc3RyaW5naWZ5IGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGMuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXSA6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgZnVuY3Rpb24gY2FsbCByZXN1bHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwidG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9vbF9jYWxsX2lkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogZnVuY3Rpb25fbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KHRvb2xfY2FsbF9yZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgY2FsbGluZyBleHBlcmltZW50YWxfb25Ub29sQ2FsbDpcIiwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZnVuY3Rpb25SZXNwb25zZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/IFwiZnVuY3Rpb25fY2FsbFwiIDogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0byBwcmV2ZW50IGRvdWJsZS1lbmNvZGluZzpcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0KFwidGV4dFwiLCBmdW5jdGlvblJlc3BvbnNlKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UgPSBmdW5jdGlvblJlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmaWx0ZXJlZENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIC4uLmNhbGxiYWNrcyxcbiAgICAgICAgICAgIG9uU3RhcnQ6IHZvaWQgMFxuICAgICAgICAgIH07XG4gICAgICAgICAgY2FsbGJhY2tzLm9uRmluYWwgPSB2b2lkIDA7XG4gICAgICAgICAgY29uc3Qgb3BlbkFJU3RyZWFtID0gT3BlbkFJU3RyZWFtKGZ1bmN0aW9uUmVzcG9uc2UsIHtcbiAgICAgICAgICAgIC4uLmZpbHRlcmVkQ2FsbGJhY2tzLFxuICAgICAgICAgICAgW19faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2xdOiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG9wZW5BSVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25GaW5hbCAmJiBhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpIHtcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25GaW5hbChhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLy8gcnNjL2NvbnN0YW50cy50c1xudmFyIFNUUkVBTUFCTEVfVkFMVUVfVFlQRSA9IFN5bWJvbC5mb3IoXCJ1aS5zdHJlYW1hYmxlLnZhbHVlXCIpO1xudmFyIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FID0gMTUgKiAxZTM7XG5cbi8vIHJzYy9zdHJlYW1hYmxlLnRzeFxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtYWJsZVVJKGluaXRpYWxWYWx1ZSkge1xuICBsZXQgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCB7IHJvdywgcmVzb2x2ZSwgcmVqZWN0IH0gPSBjcmVhdGVTdXNwZW5zZWRDaHVuayhpbml0aWFsVmFsdWUpO1xuICBmdW5jdGlvbiBhc3NlcnRTdHJlYW0obWV0aG9kKSB7XG4gICAgaWYgKGNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1ldGhvZCArIFwiOiBVSSBzdHJlYW0gaXMgYWxyZWFkeSBjbG9zZWQuXCIpO1xuICAgIH1cbiAgfVxuICBsZXQgd2FybmluZ1RpbWVvdXQ7XG4gIGZ1bmN0aW9uIHdhcm5VbmNsb3NlZFN0cmVhbSgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICB3YXJuaW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgXCJUaGUgc3RyZWFtYWJsZSBVSSBoYXMgYmVlbiBzbG93IHRvIHVwZGF0ZS4gVGhpcyBtYXkgYmUgYSBidWcgb3IgYSBwZXJmb3JtYW5jZSBpc3N1ZSBvciB5b3UgZm9yZ290IHRvIGNhbGwgYC5kb25lKClgLlwiXG4gICAgICAgICk7XG4gICAgICB9LCBERVZfREVGQVVMVF9TVFJFQU1BQkxFX1dBUk5JTkdfVElNRSk7XG4gICAgfVxuICB9XG4gIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICByZXR1cm4ge1xuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiB0aGUgc3RyZWFtYWJsZSBVSS4gVGhpcyBjYW4gYmUgcmV0dXJuZWQgZnJvbSBhIFNlcnZlciBBY3Rpb24gYW5kIHJlY2VpdmVkIGJ5IHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgdmFsdWU6IHJvdyxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1cGRhdGVzIHRoZSBjdXJyZW50IFVJIG5vZGUuIEl0IHRha2VzIGEgbmV3IFVJIG5vZGUgYW5kIHJlcGxhY2VzIHRoZSBvbGQgb25lLlxuICAgICAqL1xuICAgIHVwZGF0ZSh2YWx1ZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKFwiLnVwZGF0ZSgpXCIpO1xuICAgICAgaWYgKHZhbHVlID09PSBjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICByZXNvbHZlKHsgdmFsdWU6IGN1cnJlbnRWYWx1ZSwgZG9uZTogZmFsc2UsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBuZXcgVUkgbm9kZSB0byB0aGUgZW5kIG9mIHRoZSBvbGQgb25lLlxuICAgICAqIE9uY2UgYXBwZW5kZWQgYSBuZXcgVUkgbm9kZSwgdGhlIHByZXZpb3VzIFVJIG5vZGUgY2Fubm90IGJlIHVwZGF0ZWQgYW55bW9yZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganN4XG4gICAgICogY29uc3QgdWkgPSBjcmVhdGVTdHJlYW1hYmxlVUkoPGRpdj5oZWxsbzwvZGl2PilcbiAgICAgKiB1aS5hcHBlbmQoPGRpdj53b3JsZDwvZGl2PilcbiAgICAgKlxuICAgICAqIC8vIFRoZSBVSSBub2RlIHdpbGwgYmU6XG4gICAgICogLy8gPD5cbiAgICAgKiAvLyAgIDxkaXY+aGVsbG88L2Rpdj5cbiAgICAgKiAvLyAgIDxkaXY+d29ybGQ8L2Rpdj5cbiAgICAgKiAvLyA8Lz5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBhcHBlbmQodmFsdWUpIHtcbiAgICAgIGFzc2VydFN0cmVhbShcIi5hcHBlbmQoKVwiKTtcbiAgICAgIGNvbnN0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICByZXNvbHZlKHsgdmFsdWUsIGRvbmU6IGZhbHNlLCBhcHBlbmQ6IHRydWUsIG5leHQ6IHJlc29sdmFibGUucHJvbWlzZSB9KTtcbiAgICAgIHJlc29sdmUgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZWplY3QgPSByZXNvbHZhYmxlLnJlamVjdDtcbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBzaWduYWwgdGhhdCB0aGVyZSBpcyBhbiBlcnJvciBpbiB0aGUgVUkgc3RyZWFtLlxuICAgICAqIEl0IHdpbGwgYmUgdGhyb3duIG9uIHRoZSBjbGllbnQgc2lkZSBhbmQgY2F1Z2h0IGJ5IHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBlcnJvcihlcnJvcikge1xuICAgICAgYXNzZXJ0U3RyZWFtKFwiLmVycm9yKClcIik7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIGNsb3NlZCA9IHRydWU7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgbWFya3MgdGhlIFVJIG5vZGUgYXMgZmluYWxpemVkLiBZb3UgY2FuIGVpdGhlciBjYWxsIGl0IHdpdGhvdXQgYW55IHBhcmFtZXRlcnMgb3Igd2l0aCBhIG5ldyBVSSBub2RlIGFzIHRoZSBmaW5hbCBzdGF0ZS5cbiAgICAgKiBPbmNlIGNhbGxlZCwgdGhlIFVJIG5vZGUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsd2F5cyAqKnJlcXVpcmVkKiogdG8gYmUgY2FsbGVkLCBvdGhlcndpc2UgdGhlIHJlc3BvbnNlIHdpbGwgYmUgc3R1Y2sgaW4gYSBsb2FkaW5nIHN0YXRlLlxuICAgICAqL1xuICAgIGRvbmUoLi4uYXJncykge1xuICAgICAgYXNzZXJ0U3RyZWFtKFwiLmRvbmUoKVwiKTtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICByZXNvbHZlKHsgdmFsdWU6IGFyZ3NbMF0sIGRvbmU6IHRydWUgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoeyB2YWx1ZTogY3VycmVudFZhbHVlLCBkb25lOiB0cnVlIH0pO1xuICAgIH1cbiAgfTtcbn1cbnZhciBTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0sgPSBTeW1ib2woXCJzdHJlYW1hYmxlLnZhbHVlLmxvY2tcIik7XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoaW5pdGlhbFZhbHVlKSB7XG4gIGNvbnN0IGlzUmVhZGFibGVTdHJlYW0gPSBpbml0aWFsVmFsdWUgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSB8fCB0eXBlb2YgaW5pdGlhbFZhbHVlID09PSBcIm9iamVjdFwiICYmIGluaXRpYWxWYWx1ZSAhPT0gbnVsbCAmJiBcImdldFJlYWRlclwiIGluIGluaXRpYWxWYWx1ZSAmJiB0eXBlb2YgaW5pdGlhbFZhbHVlLmdldFJlYWRlciA9PT0gXCJmdW5jdGlvblwiICYmIFwibG9ja2VkXCIgaW4gaW5pdGlhbFZhbHVlICYmIHR5cGVvZiBpbml0aWFsVmFsdWUubG9ja2VkID09PSBcImJvb2xlYW5cIjtcbiAgaWYgKCFpc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN0cmVhbWFibGVWYWx1ZUltcGwoaW5pdGlhbFZhbHVlKTtcbiAgfVxuICBjb25zdCBzdHJlYW1hYmxlVmFsdWUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsKCk7XG4gIHN0cmVhbWFibGVWYWx1ZVtTVFJFQU1BQkxFX1ZBTFVFX0lOVEVSTkFMX0xPQ0tdID0gdHJ1ZTtcbiAgKGFzeW5jICgpID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVhZGVyID0gaW5pdGlhbFZhbHVlLmdldFJlYWRlcigpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW1hYmxlVmFsdWVbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXSA9IGZhbHNlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVZhbHVlLmFwcGVuZCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RyZWFtYWJsZVZhbHVlLnVwZGF0ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZS5kb25lKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgc3RyZWFtYWJsZVZhbHVlW1NUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DS10gPSBmYWxzZTtcbiAgICAgIHN0cmVhbWFibGVWYWx1ZS5lcnJvcihlKTtcbiAgICB9XG4gIH0pKCk7XG4gIHJldHVybiBzdHJlYW1hYmxlVmFsdWU7XG59XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsKGluaXRpYWxWYWx1ZSkge1xuICBsZXQgY2xvc2VkID0gZmFsc2U7XG4gIGxldCBsb2NrZWQgPSBmYWxzZTtcbiAgbGV0IHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICBsZXQgY3VycmVudFZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICBsZXQgY3VycmVudEVycm9yO1xuICBsZXQgY3VycmVudFByb21pc2UgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gIGxldCBjdXJyZW50UGF0Y2hWYWx1ZTtcbiAgZnVuY3Rpb24gYXNzZXJ0U3RyZWFtKG1ldGhvZCkge1xuICAgIGlmIChjbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXRob2QgKyBcIjogVmFsdWUgc3RyZWFtIGlzIGFscmVhZHkgY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKGxvY2tlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBtZXRob2QgKyBcIjogVmFsdWUgc3RyZWFtIGlzIGxvY2tlZCBhbmQgY2Fubm90IGJlIHVwZGF0ZWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGxldCB3YXJuaW5nVGltZW91dDtcbiAgZnVuY3Rpb24gd2FyblVuY2xvc2VkU3RyZWFtKCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICBpZiAod2FybmluZ1RpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHdhcm5pbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHdhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIlRoZSBzdHJlYW1hYmxlIFVJIGhhcyBiZWVuIHNsb3cgdG8gdXBkYXRlLiBUaGlzIG1heSBiZSBhIGJ1ZyBvciBhIHBlcmZvcm1hbmNlIGlzc3VlIG9yIHlvdSBmb3Jnb3QgdG8gY2FsbCBgLmRvbmUoKWAuXCJcbiAgICAgICAgKTtcbiAgICAgIH0sIERFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FKTtcbiAgICB9XG4gIH1cbiAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVdyYXBwZWQoaW5pdGlhbENodW5rKSB7XG4gICAgbGV0IGluaXQ7XG4gICAgaWYgKGN1cnJlbnRFcnJvciAhPT0gdm9pZCAwKSB7XG4gICAgICBpbml0ID0geyBlcnJvcjogY3VycmVudEVycm9yIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50UGF0Y2hWYWx1ZSAmJiAhaW5pdGlhbENodW5rKSB7XG4gICAgICAgIGluaXQgPSB7IGRpZmY6IGN1cnJlbnRQYXRjaFZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0ID0geyBjdXJyOiBjdXJyZW50VmFsdWUgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQcm9taXNlKSB7XG4gICAgICBpbml0Lm5leHQgPSBjdXJyZW50UHJvbWlzZTtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxDaHVuaykge1xuICAgICAgaW5pdC50eXBlID0gU1RSRUFNQUJMRV9WQUxVRV9UWVBFO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdDtcbiAgfVxuICBmdW5jdGlvbiB1cGRhdGVWYWx1ZVN0YXRlcyh2YWx1ZSkge1xuICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IFswLCB2YWx1ZS5zbGljZShjdXJyZW50VmFsdWUubGVuZ3RoKV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWwgVGhpcyBpcyBhbiBpbnRlcm5hbCBsb2NrIHRvIHByZXZlbnQgdGhlIHZhbHVlIGZyb20gYmVpbmdcbiAgICAgKiB1cGRhdGVkIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIHNldCBbU1RSRUFNQUJMRV9WQUxVRV9JTlRFUk5BTF9MT0NLXShzdGF0ZSkge1xuICAgICAgbG9ja2VkID0gc3RhdGU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUuIFRoaXMgY2FuIGJlIHJldHVybmVkIGZyb20gYSBTZXJ2ZXIgQWN0aW9uIGFuZFxuICAgICAqIHJlY2VpdmVkIGJ5IHRoZSBjbGllbnQuIFRvIHJlYWQgdGhlIHN0cmVhbWVkIHZhbHVlcywgdXNlIHRoZVxuICAgICAqIGByZWFkU3RyZWFtYWJsZVZhbHVlYCBvciBgdXNlU3RyZWFtYWJsZVZhbHVlYCBBUElzLlxuICAgICAqL1xuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwcGVkKHRydWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgdXBkYXRlcyB0aGUgY3VycmVudCB2YWx1ZSB3aXRoIGEgbmV3IG9uZS5cbiAgICAgKi9cbiAgICB1cGRhdGUodmFsdWUpIHtcbiAgICAgIGFzc2VydFN0cmVhbShcIi51cGRhdGUoKVwiKTtcbiAgICAgIGNvbnN0IHJlc29sdmVQcmV2aW91cyA9IHJlc29sdmFibGUucmVzb2x2ZTtcbiAgICAgIHJlc29sdmFibGUgPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgICAgdXBkYXRlVmFsdWVTdGF0ZXModmFsdWUpO1xuICAgICAgY3VycmVudFByb21pc2UgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgICByZXNvbHZlUHJldmlvdXMoY3JlYXRlV3JhcHBlZCgpKTtcbiAgICAgIHdhcm5VbmNsb3NlZFN0cmVhbSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdXNlZCB0byBhcHBlbmQgYSBkZWx0YSBzdHJpbmcgdG8gdGhlIGN1cnJlbnQgdmFsdWUuIEl0XG4gICAgICogcmVxdWlyZXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHN0cmVhbWFibGUgdG8gYmUgYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzeFxuICAgICAqIGNvbnN0IHN0cmVhbWFibGUgPSBjcmVhdGVTdHJlYW1hYmxlVmFsdWUoJ2hlbGxvJyk7XG4gICAgICogc3RyZWFtYWJsZS5hcHBlbmQoJyB3b3JsZCcpO1xuICAgICAqXG4gICAgICogLy8gVGhlIHZhbHVlIHdpbGwgYmUgJ2hlbGxvIHdvcmxkJ1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFwcGVuZCh2YWx1ZSkge1xuICAgICAgYXNzZXJ0U3RyZWFtKFwiLmFwcGVuZCgpXCIpO1xuICAgICAgaWYgKHR5cGVvZiBjdXJyZW50VmFsdWUgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGN1cnJlbnRWYWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYC5hcHBlbmQoKTogVGhlIGN1cnJlbnQgdmFsdWUgaXMgbm90IGEgc3RyaW5nLiBSZWNlaXZlZDogJHt0eXBlb2YgY3VycmVudFZhbHVlfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGAuYXBwZW5kKCk6IFRoZSB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuIFJlY2VpdmVkOiAke3R5cGVvZiB2YWx1ZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNvbHZlUHJldmlvdXMgPSByZXNvbHZhYmxlLnJlc29sdmU7XG4gICAgICByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICAgIGlmICh0eXBlb2YgY3VycmVudFZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGN1cnJlbnRQYXRjaFZhbHVlID0gWzAsIHZhbHVlXTtcbiAgICAgICAgY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlICsgdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50UGF0Y2hWYWx1ZSA9IHZvaWQgMDtcbiAgICAgICAgY3VycmVudFZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBjdXJyZW50UHJvbWlzZSA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICAgIHJlc29sdmVQcmV2aW91cyhjcmVhdGVXcmFwcGVkKCkpO1xuICAgICAgd2FyblVuY2xvc2VkU3RyZWFtKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIHRvIHNpZ25hbCB0aGF0IHRoZXJlIGlzIGFuIGVycm9yIGluIHRoZSB2YWx1ZSBzdHJlYW0uXG4gICAgICogSXQgd2lsbCBiZSB0aHJvd24gb24gdGhlIGNsaWVudCBzaWRlIHdoZW4gY29uc3VtZWQgdmlhXG4gICAgICogYHJlYWRTdHJlYW1hYmxlVmFsdWVgIG9yIGB1c2VTdHJlYW1hYmxlVmFsdWVgLlxuICAgICAqL1xuICAgIGVycm9yKGVycm9yKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oXCIuZXJyb3IoKVwiKTtcbiAgICAgIGlmICh3YXJuaW5nVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQod2FybmluZ1RpbWVvdXQpO1xuICAgICAgfVxuICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgIGN1cnJlbnRFcnJvciA9IGVycm9yO1xuICAgICAgY3VycmVudFByb21pc2UgPSB2b2lkIDA7XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUoeyBlcnJvciB9KTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIG1hcmtzIHRoZSB2YWx1ZSBhcyBmaW5hbGl6ZWQuIFlvdSBjYW4gZWl0aGVyIGNhbGwgaXQgd2l0aG91dFxuICAgICAqIGFueSBwYXJhbWV0ZXJzIG9yIHdpdGggYSBuZXcgdmFsdWUgYXMgdGhlIGZpbmFsIHN0YXRlLlxuICAgICAqIE9uY2UgY2FsbGVkLCB0aGUgdmFsdWUgY2Fubm90IGJlIHVwZGF0ZWQgb3IgYXBwZW5kZWQgYW55bW9yZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGFsd2F5cyAqKnJlcXVpcmVkKiogdG8gYmUgY2FsbGVkLCBvdGhlcndpc2UgdGhlIHJlc3BvbnNlXG4gICAgICogd2lsbCBiZSBzdHVjayBpbiBhIGxvYWRpbmcgc3RhdGUuXG4gICAgICovXG4gICAgZG9uZSguLi5hcmdzKSB7XG4gICAgICBhc3NlcnRTdHJlYW0oXCIuZG9uZSgpXCIpO1xuICAgICAgaWYgKHdhcm5pbmdUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh3YXJuaW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBjbG9zZWQgPSB0cnVlO1xuICAgICAgY3VycmVudFByb21pc2UgPSB2b2lkIDA7XG4gICAgICBpZiAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgdXBkYXRlVmFsdWVTdGF0ZXMoYXJnc1swXSk7XG4gICAgICAgIHJlc29sdmFibGUucmVzb2x2ZShjcmVhdGVXcmFwcGVkKCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUoe30pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihvcHRpb25zKSB7XG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKG9wdGlvbnMuaW5pdGlhbCk7XG4gIGNvbnN0IHRleHQgPSBvcHRpb25zLnRleHQgPyBvcHRpb25zLnRleHQgOiAoeyBjb250ZW50IH0pID0+IGNvbnRlbnQ7XG4gIGNvbnN0IGZ1bmN0aW9ucyA9IG9wdGlvbnMuZnVuY3Rpb25zID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy5mdW5jdGlvbnMpLm1hcChcbiAgICAoW25hbWUsIHsgZGVzY3JpcHRpb24sIHBhcmFtZXRlcnMgfV0pID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICBwYXJhbWV0ZXJzOiB6b2RUb0pzb25TY2hlbWEyKHBhcmFtZXRlcnMpXG4gICAgICB9O1xuICAgIH1cbiAgKSA6IHZvaWQgMDtcbiAgY29uc3QgdG9vbHMgPSBvcHRpb25zLnRvb2xzID8gT2JqZWN0LmVudHJpZXMob3B0aW9ucy50b29scykubWFwKFxuICAgIChbbmFtZSwgeyBkZXNjcmlwdGlvbiwgcGFyYW1ldGVycyB9XSkgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBmdW5jdGlvbjoge1xuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgICAgcGFyYW1ldGVyczogem9kVG9Kc29uU2NoZW1hMihwYXJhbWV0ZXJzKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgKSA6IHZvaWQgMDtcbiAgaWYgKGZ1bmN0aW9ucyAmJiB0b29scykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiWW91IGNhbid0IGhhdmUgYm90aCBmdW5jdGlvbnMgYW5kIHRvb2xzIGRlZmluZWQuIFBsZWFzZSBjaG9vc2Ugb25lIG9yIHRoZSBvdGhlci5cIlxuICAgICk7XG4gIH1cbiAgbGV0IGZpbmlzaGVkO1xuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVSZW5kZXIoYXJncywgcmVuZGVyZXIsIHJlcykge1xuICAgIGlmICghcmVuZGVyZXIpXG4gICAgICByZXR1cm47XG4gICAgY29uc3QgcmVzb2x2YWJsZSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICBmaW5pc2hlZCA9IGZpbmlzaGVkLnRoZW4oKCkgPT4gcmVzb2x2YWJsZS5wcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmluaXNoZWQgPSByZXNvbHZhYmxlLnByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlID0gcmVuZGVyZXIoYXJncyk7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSB8fCB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgY29uc3Qgbm9kZSA9IGF3YWl0IHZhbHVlO1xuICAgICAgcmVzLnVwZGF0ZShub2RlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHZhbHVlKSB7XG4gICAgICBjb25zdCBpdCA9IHZhbHVlO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZTogdmFsdWUyIH0gPSBhd2FpdCBpdC5uZXh0KCk7XG4gICAgICAgIHJlcy51cGRhdGUodmFsdWUyKTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICByZXNvbHZhYmxlLnJlc29sdmUodm9pZCAwKTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWU7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiB2YWx1ZTIgfSA9IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZTIpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMudXBkYXRlKHZhbHVlKTtcbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH1cbiAgfVxuICAoYXN5bmMgKCkgPT4ge1xuICAgIGxldCBoYXNGdW5jdGlvbiA9IGZhbHNlO1xuICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICBjb25zdW1lU3RyZWFtKFxuICAgICAgT3BlbkFJU3RyZWFtKFxuICAgICAgICBhd2FpdCBvcHRpb25zLnByb3ZpZGVyLmNoYXQuY29tcGxldGlvbnMuY3JlYXRlKHtcbiAgICAgICAgICBtb2RlbDogb3B0aW9ucy5tb2RlbCxcbiAgICAgICAgICBtZXNzYWdlczogb3B0aW9ucy5tZXNzYWdlcyxcbiAgICAgICAgICB0ZW1wZXJhdHVyZTogb3B0aW9ucy50ZW1wZXJhdHVyZSxcbiAgICAgICAgICBzdHJlYW06IHRydWUsXG4gICAgICAgICAgLi4uZnVuY3Rpb25zID8ge1xuICAgICAgICAgICAgZnVuY3Rpb25zXG4gICAgICAgICAgfSA6IHt9LFxuICAgICAgICAgIC4uLnRvb2xzID8ge1xuICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICB9IDoge31cbiAgICAgICAgfSksXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5mdW5jdGlvbnMgPyB7XG4gICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoZnVuY3Rpb25DYWxsUGF5bG9hZCkge1xuICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICBoYXNGdW5jdGlvbiA9IHRydWU7XG4gICAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgICBmdW5jdGlvbkNhbGxQYXlsb2FkLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSBvcHRpb25zLmZ1bmN0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2Z1bmN0aW9uQ2FsbFBheWxvYWQubmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5yZW5kZXIsXG4gICAgICAgICAgICAgICAgdWlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgLi4udG9vbHMgPyB7XG4gICAgICAgICAgICBhc3luYyBleHBlcmltZW50YWxfb25Ub29sQ2FsbCh0b29sQ2FsbFBheWxvYWQpIHtcbiAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgaGFzRnVuY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2wgb2YgdG9vbENhbGxQYXlsb2FkLnRvb2xzKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICAgICAgdG9vbC5mdW5jLmFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IG9wdGlvbnMudG9vbHMpID09IG51bGwgPyB2b2lkIDAgOiBfYVt0b29sLmZ1bmMubmFtZV0pID09IG51bGwgPyB2b2lkIDAgOiBfYi5yZW5kZXIsXG4gICAgICAgICAgICAgICAgICB1aVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IDoge30sXG4gICAgICAgICAgb25UZXh0KGNodW5rKSB7XG4gICAgICAgICAgICBjb250ZW50ICs9IGNodW5rO1xuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKHsgY29udGVudCwgZG9uZTogZmFsc2UsIGRlbHRhOiBjaHVuayB9LCB0ZXh0LCB1aSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBhc3luYyBvbkZpbmFsKCkge1xuICAgICAgICAgICAgaWYgKGhhc0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgIGF3YWl0IGZpbmlzaGVkO1xuICAgICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcih7IGNvbnRlbnQsIGRvbmU6IHRydWUgfSwgdGV4dCwgdWkpO1xuICAgICAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgICAgICB1aS5kb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApXG4gICAgKTtcbiAgfSkoKTtcbiAgcmV0dXJuIHVpLnZhbHVlO1xufVxuXG4vLyByc2Mvc3RyZWFtLXVpL3N0cmVhbS11aS50c3hcbmltcG9ydCB7XG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvclxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG52YXIgZGVmYXVsdFRleHRSZW5kZXJlciA9ICh7IGNvbnRlbnQgfSkgPT4gY29udGVudDtcbmFzeW5jIGZ1bmN0aW9uIHN0cmVhbVVJKHtcbiAgbW9kZWwsXG4gIHRvb2xzLFxuICBzeXN0ZW0sXG4gIHByb21wdCxcbiAgbWVzc2FnZXMsXG4gIG1heFJldHJpZXMsXG4gIGFib3J0U2lnbmFsLFxuICBpbml0aWFsLFxuICB0ZXh0LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBpZiAodHlwZW9mIG1vZGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgbW9kZWxgIGNhbm5vdCBiZSBhIHN0cmluZyBpbiBgc3RyZWFtVUlgLiBVc2UgdGhlIGFjdHVhbCBtb2RlbCBpbnN0YW5jZSBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuICBpZiAoXCJmdW5jdGlvbnNcIiBpbiBzZXR0aW5ncykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiYGZ1bmN0aW9uc2AgaXMgbm90IHN1cHBvcnRlZCBpbiBgc3RyZWFtVUlgLCB1c2UgYHRvb2xzYCBpbnN0ZWFkLlwiXG4gICAgKTtcbiAgfVxuICBpZiAoXCJwcm92aWRlclwiIGluIHNldHRpbmdzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgXCJgcHJvdmlkZXJgIGlzIG5vIGxvbmdlciBuZWVkZWQgaW4gYHN0cmVhbVVJYC4gVXNlIGBtb2RlbGAgaW5zdGVhZC5cIlxuICAgICk7XG4gIH1cbiAgaWYgKHRvb2xzKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdG9vbF0gb2YgT2JqZWN0LmVudHJpZXModG9vbHMpKSB7XG4gICAgICBpZiAoXCJyZW5kZXJcIiBpbiB0b29sKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIlRvb2wgZGVmaW5pdGlvbiBpbiBgc3RyZWFtVUlgIHNob3VsZCBub3QgaGF2ZSBgcmVuZGVyYCBwcm9wZXJ0eS4gVXNlIGBnZW5lcmF0ZWAgaW5zdGVhZC4gRm91bmQgaW4gdG9vbDogXCIgKyBuYW1lXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHVpID0gY3JlYXRlU3RyZWFtYWJsZVVJKGluaXRpYWwpO1xuICBjb25zdCB0ZXh0UmVuZGVyID0gdGV4dCB8fCBkZWZhdWx0VGV4dFJlbmRlcmVyO1xuICBsZXQgZmluaXNoZWQ7XG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlbmRlcihhcmdzLCByZW5kZXJlciwgcmVzKSB7XG4gICAgaWYgKCFyZW5kZXJlcilcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCByZXNvbHZhYmxlID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgIGZpbmlzaGVkID0gZmluaXNoZWQudGhlbigoKSA9PiByZXNvbHZhYmxlLnByb21pc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaW5pc2hlZCA9IHJlc29sdmFibGUucHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWUgPSByZW5kZXJlciguLi5hcmdzKTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBcInRoZW5cIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBjb25zdCBub2RlID0gYXdhaXQgdmFsdWU7XG4gICAgICByZXMudXBkYXRlKG5vZGUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gdmFsdWUpIHtcbiAgICAgIGNvbnN0IGl0ID0gdmFsdWU7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlOiB2YWx1ZTIgfSA9IGF3YWl0IGl0Lm5leHQoKTtcbiAgICAgICAgcmVzLnVwZGF0ZSh2YWx1ZTIpO1xuICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc29sdmFibGUucmVzb2x2ZSh2b2lkIDApO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiB2YWx1ZSkge1xuICAgICAgY29uc3QgaXQgPSB2YWx1ZTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWU6IHZhbHVlMiB9ID0gaXQubmV4dCgpO1xuICAgICAgICByZXMudXBkYXRlKHZhbHVlMik7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcy51cGRhdGUodmFsdWUpO1xuICAgICAgcmVzb2x2YWJsZS5yZXNvbHZlKHZvaWQgMCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgY29uc3QgdmFsaWRhdGVkUHJvbXB0ID0gZ2V0VmFsaWRhdGVkUHJvbXB0KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pO1xuICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAoKSA9PiBtb2RlbC5kb1N0cmVhbSh7XG4gICAgICBtb2RlOiB7XG4gICAgICAgIHR5cGU6IFwicmVndWxhclwiLFxuICAgICAgICB0b29sczogdG9vbHMgPT0gbnVsbCA/IHZvaWQgMCA6IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5tYXAoKFtuYW1lLCB0b29sXSkgPT4gKHtcbiAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbC5kZXNjcmlwdGlvbixcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBjb252ZXJ0Wm9kVG9KU09OU2NoZW1hKHRvb2wucGFyYW1ldGVycylcbiAgICAgICAgfSkpXG4gICAgICB9LFxuICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICBpbnB1dEZvcm1hdDogdmFsaWRhdGVkUHJvbXB0LnR5cGUsXG4gICAgICBwcm9tcHQ6IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQodmFsaWRhdGVkUHJvbXB0KSxcbiAgICAgIGFib3J0U2lnbmFsXG4gICAgfSlcbiAgKTtcbiAgY29uc3QgW3N0cmVhbSwgZm9ya2VkU3RyZWFtXSA9IHJlc3VsdC5zdHJlYW0udGVlKCk7XG4gIChhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb250ZW50ID0gXCJcIjtcbiAgICAgIGxldCBoYXNUb29sQ2FsbCA9IGZhbHNlO1xuICAgICAgY29uc3QgcmVhZGVyID0gZm9ya2VkU3RyZWFtLmdldFJlYWRlcigpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6IHtcbiAgICAgICAgICAgIGNvbnRlbnQgKz0gdmFsdWUudGV4dERlbHRhO1xuICAgICAgICAgICAgaGFuZGxlUmVuZGVyKFxuICAgICAgICAgICAgICBbeyBjb250ZW50LCBkb25lOiBmYWxzZSwgZGVsdGE6IHZhbHVlLnRleHREZWx0YSB9XSxcbiAgICAgICAgICAgICAgdGV4dFJlbmRlcixcbiAgICAgICAgICAgICAgdWlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgICBoYXNUb29sQ2FsbCA9IHRydWU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgICBjb25zdCB0b29sTmFtZSA9IHZhbHVlLnRvb2xOYW1lO1xuICAgICAgICAgICAgaWYgKCF0b29scykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0b29sID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgaWYgKCF0b29sKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBOb1N1Y2hUb29sRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHNhZmVQYXJzZUpTT04oe1xuICAgICAgICAgICAgICB0ZXh0OiB2YWx1ZS5hcmdzLFxuICAgICAgICAgICAgICBzY2hlbWE6IHRvb2wucGFyYW1ldGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRUb29sQXJndW1lbnRzRXJyb3Ioe1xuICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIHRvb2xBcmdzOiB2YWx1ZS5hcmdzLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBwYXJzZVJlc3VsdC5lcnJvclxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZVJlbmRlcihcbiAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgIHBhcnNlUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgICAgdG9vbENhbGxJZDogdmFsdWUudG9vbENhbGxJZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgdG9vbC5nZW5lcmF0ZSxcbiAgICAgICAgICAgICAgdWlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgIHRocm93IHZhbHVlLmVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChoYXNUb29sQ2FsbCkge1xuICAgICAgICBhd2FpdCBmaW5pc2hlZDtcbiAgICAgICAgdWkuZG9uZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlUmVuZGVyKFt7IGNvbnRlbnQsIGRvbmU6IHRydWUgfV0sIHRleHRSZW5kZXIsIHVpKTtcbiAgICAgICAgYXdhaXQgZmluaXNoZWQ7XG4gICAgICAgIHVpLmRvbmUoKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdWkuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfSkoKTtcbiAgcmV0dXJuIHtcbiAgICAuLi5yZXN1bHQsXG4gICAgc3RyZWFtLFxuICAgIHZhbHVlOiB1aS52YWx1ZVxuICB9O1xufVxuXG4vLyByc2MvcHJvdmlkZXIudHN4XG5pbXBvcnQgKiBhcyBSZWFjdDIgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBJbnRlcm5hbEFJUHJvdmlkZXIgfSBmcm9tIFwiLi9yc2Mtc2hhcmVkLm1qc1wiO1xuaW1wb3J0IHsganN4IGFzIGpzeDIgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmFzeW5jIGZ1bmN0aW9uIGlubmVyQWN0aW9uKHtcbiAgYWN0aW9uLFxuICBvcHRpb25zXG59LCBzdGF0ZSwgLi4uYXJncykge1xuICBcInVzZSBzZXJ2ZXJcIjtcbiAgcmV0dXJuIGF3YWl0IHdpdGhBSVN0YXRlKFxuICAgIHtcbiAgICAgIHN0YXRlLFxuICAgICAgb3B0aW9uc1xuICAgIH0sXG4gICAgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYWN0aW9uKC4uLmFyZ3MpO1xuICAgICAgc2VhbE11dGFibGVBSVN0YXRlKCk7XG4gICAgICByZXR1cm4gW2dldEFJU3RhdGVEZWx0YVByb21pc2UoKSwgcmVzdWx0XTtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiB3cmFwQWN0aW9uKGFjdGlvbiwgb3B0aW9ucykge1xuICByZXR1cm4gaW5uZXJBY3Rpb24uYmluZChudWxsLCB7IGFjdGlvbiwgb3B0aW9ucyB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFJKHtcbiAgYWN0aW9ucyxcbiAgaW5pdGlhbEFJU3RhdGUsXG4gIGluaXRpYWxVSVN0YXRlLFxuICBvblNldEFJU3RhdGUsXG4gIG9uR2V0VUlTdGF0ZVxufSkge1xuICBjb25zdCB3cmFwcGVkQWN0aW9ucyA9IHt9O1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gYWN0aW9ucykge1xuICAgIHdyYXBwZWRBY3Rpb25zW25hbWVdID0gd3JhcEFjdGlvbihhY3Rpb25zW25hbWVdLCB7XG4gICAgICBvblNldEFJU3RhdGVcbiAgICB9KTtcbiAgfVxuICBjb25zdCB3cmFwcGVkU3luY1VJU3RhdGUgPSBvbkdldFVJU3RhdGUgPyB3cmFwQWN0aW9uKG9uR2V0VUlTdGF0ZSwge30pIDogdm9pZCAwO1xuICBjb25zdCBBSSA9IGFzeW5jIChwcm9wcykgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKFwidXNlU3RhdGVcIiBpbiBSZWFjdDIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJUaGlzIGNvbXBvbmVudCBjYW4gb25seSBiZSB1c2VkIGluc2lkZSBTZXJ2ZXIgQ29tcG9uZW50cy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHVpU3RhdGUgPSAoX2EgPSBwcm9wcy5pbml0aWFsVUlTdGF0ZSkgIT0gbnVsbCA/IF9hIDogaW5pdGlhbFVJU3RhdGU7XG4gICAgbGV0IGFpU3RhdGUgPSAoX2IgPSBwcm9wcy5pbml0aWFsQUlTdGF0ZSkgIT0gbnVsbCA/IF9iIDogaW5pdGlhbEFJU3RhdGU7XG4gICAgbGV0IGFpU3RhdGVEZWx0YSA9IHZvaWQgMDtcbiAgICBpZiAod3JhcHBlZFN5bmNVSVN0YXRlKSB7XG4gICAgICBjb25zdCBbbmV3QUlTdGF0ZURlbHRhLCBuZXdVSVN0YXRlXSA9IGF3YWl0IHdyYXBwZWRTeW5jVUlTdGF0ZShhaVN0YXRlKTtcbiAgICAgIGlmIChuZXdVSVN0YXRlICE9PSB2b2lkIDApIHtcbiAgICAgICAgYWlTdGF0ZURlbHRhID0gbmV3QUlTdGF0ZURlbHRhO1xuICAgICAgICB1aVN0YXRlID0gbmV3VUlTdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3gyKFxuICAgICAgSW50ZXJuYWxBSVByb3ZpZGVyLFxuICAgICAge1xuICAgICAgICB3cmFwcGVkQWN0aW9ucyxcbiAgICAgICAgd3JhcHBlZFN5bmNVSVN0YXRlLFxuICAgICAgICBpbml0aWFsVUlTdGF0ZTogdWlTdGF0ZSxcbiAgICAgICAgaW5pdGlhbEFJU3RhdGU6IGFpU3RhdGUsXG4gICAgICAgIGluaXRpYWxBSVN0YXRlUGF0Y2g6IGFpU3RhdGVEZWx0YSxcbiAgICAgICAgY2hpbGRyZW46IHByb3BzLmNoaWxkcmVuXG4gICAgICB9XG4gICAgKTtcbiAgfTtcbiAgcmV0dXJuIEFJO1xufVxuZXhwb3J0IHtcbiAgY3JlYXRlQUksXG4gIGNyZWF0ZVN0cmVhbWFibGVVSSxcbiAgY3JlYXRlU3RyZWFtYWJsZVZhbHVlLFxuICBnZXRBSVN0YXRlLFxuICBnZXRNdXRhYmxlQUlTdGF0ZSxcbiAgcmVuZGVyLFxuICBzdHJlYW1VSVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJzYy1zZXJ2ZXIubWpzLm1hcCJdLCJuYW1lcyI6WyJBc3luY0xvY2FsU3RvcmFnZSIsImpzb25kaWZmcGF0Y2giLCJTdXNwZW5zZSIsIkZyYWdtZW50IiwianN4IiwianN4cyIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInByb21pc2UiLCJQcm9taXNlIiwicmVzIiwicmVqIiwiUiIsImMiLCJuIiwiY2h1bmsiLCJkb25lIiwidmFsdWUiLCJhcHBlbmQiLCJjaGlsZHJlbiIsImZhbGxiYWNrIiwibmV4dCIsImNyZWF0ZVN1c3BlbnNlZENodW5rIiwiaW5pdGlhbFZhbHVlIiwicm93IiwiaXNGdW5jdGlvbiIsIngiLCJjb25zdW1lU3RyZWFtIiwic3RyZWFtIiwicmVhZGVyIiwiZ2V0UmVhZGVyIiwicmVhZCIsImFzeW5jQUlTdGF0ZVN0b3JhZ2UiLCJnZXRBSVN0YXRlU3RvcmVPclRocm93IiwibWVzc2FnZSIsInN0b3JlIiwiZ2V0U3RvcmUiLCJFcnJvciIsIndpdGhBSVN0YXRlIiwic3RhdGUiLCJvcHRpb25zIiwiZm4iLCJydW4iLCJjdXJyZW50U3RhdGUiLCJvcmlnaW5hbFN0YXRlIiwic2VhbGVkIiwiZ2V0QUlTdGF0ZURlbHRhUHJvbWlzZSIsIm11dGF0aW9uRGVsdGFQcm9taXNlIiwic2VhbE11dGFibGVBSVN0YXRlIiwiZ2V0QUlTdGF0ZSIsImFyZ3MiLCJsZW5ndGgiLCJrZXkiLCJTdHJpbmciLCJnZXRNdXRhYmxlQUlTdGF0ZSIsIm11dGF0aW9uRGVsdGFSZXNvbHZlIiwiZG9VcGRhdGUiLCJuZXdTdGF0ZSIsIl9hIiwiX2IiLCJvblNldEFJU3RhdGUiLCJjYWxsIiwibXV0YWJsZVN0YXRlIiwiZ2V0IiwidXBkYXRlIiwibmV3QUlTdGF0ZSIsImRvbmVBcmdzIiwiZGVsdGEiLCJkaWZmIiwiem9kVG9Kc29uU2NoZW1hMiIsIm1pbWVUeXBlU2lnbmF0dXJlcyIsIm1pbWVUeXBlIiwiYnl0ZXMiLCJkZXRlY3RJbWFnZU1pbWVUeXBlIiwiaW1hZ2UiLCJldmVyeSIsImJ5dGUiLCJpbmRleCIsIkludmFsaWREYXRhQ29udGVudEVycm9yIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJjb252ZXJ0RGF0YUNvbnRlbnRUb1VpbnQ4QXJyYXkiLCJjb250ZW50IiwiVWludDhBcnJheSIsIkFycmF5QnVmZmVyIiwiY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCIsInByb21wdCIsImxhbmd1YWdlTW9kZWxNZXNzYWdlcyIsInN5c3RlbSIsInB1c2giLCJyb2xlIiwidHlwZSIsInRleHQiLCJtZXNzYWdlcyIsIm1hcCIsInBhcnQiLCJVUkwiLCJpbWFnZVVpbnQ4IiwiX2V4aGF1c3RpdmVDaGVjayIsIkludmFsaWRQcm9tcHRFcnJvciIsImdldFZhbGlkYXRlZFByb21wdCIsIkludmFsaWRBcmd1bWVudEVycm9yIiwicHJlcGFyZUNhbGxTZXR0aW5ncyIsIm1heFRva2VucyIsInRlbXBlcmF0dXJlIiwidG9wUCIsInByZXNlbmNlUGVuYWx0eSIsImZyZXF1ZW5jeVBlbmFsdHkiLCJzZWVkIiwibWF4UmV0cmllcyIsIk51bWJlciIsImlzSW50ZWdlciIsInBhcmFtZXRlciIsInpvZFRvSnNvblNjaGVtYSIsImNvbnZlcnRab2RUb0pTT05TY2hlbWEiLCJ6b2RTY2hlbWEiLCJBUElDYWxsRXJyb3IiLCJSZXRyeUVycm9yIiwiZ2V0RXJyb3JNZXNzYWdlIiwiaXNBYm9ydEVycm9yIiwiZGVsYXkiLCJkZWxheUluTXMiLCJzZXRUaW1lb3V0IiwicmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9ycyIsImVycm9yIiwiZXJyb3JNZXNzYWdlIiwibmV3RXJyb3JzIiwidHJ5TnVtYmVyIiwicmVhc29uIiwiaXNBUElDYWxsRXJyb3IiLCJpc1JldHJ5YWJsZSIsInRleHRTdHJlYW1QYXJ0IiwiY29kZSIsIm5hbWUiLCJwYXJzZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCIsImlkIiwiaXRlbSIsImFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCIsInRocmVhZElkIiwibWVzc2FnZUlkIiwiZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0IiwidG9vbENhbGxTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInN0cmVhbVBhcnRzIiwic3RyZWFtUGFydHNCeUNvZGUiLCJTdHJlYW1TdHJpbmdQcmVmaXhlcyIsInZhbGlkQ29kZXMiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJzbGljZSIsImluY2x1ZGVzIiwidGV4dFZhbHVlIiwianNvblZhbHVlIiwiSlNPTiIsImZvcm1hdFN0cmVhbVBhcnQiLCJzdHJlYW1QYXJ0IiwiZmluZCIsInN0cmluZ2lmeSIsImNyZWF0ZUNodW5rRGVjb2RlciIsImNvbXBsZXgiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJkZWNvZGVkIiwic3BsaXQiLCJmaWx0ZXIiLCJCb29sZWFuIiwiY3JlYXRlUGFyc2VyIiwiY3JlYXRlRXZlbnRTdHJlYW1UcmFuc2Zvcm1lciIsImN1c3RvbVBhcnNlciIsInRleHREZWNvZGVyIiwiZXZlbnRTb3VyY2VQYXJzZXIiLCJUcmFuc2Zvcm1TdHJlYW0iLCJzdGFydCIsImNvbnRyb2xsZXIiLCJldmVudCIsImRhdGEiLCJ0ZXJtaW5hdGUiLCJwYXJzZWRNZXNzYWdlIiwiZW5xdWV1ZSIsInRyYW5zZm9ybSIsImZlZWQiLCJjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lciIsImNiIiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsImFnZ3JlZ2F0ZWRSZXNwb25zZSIsImNhbGxiYWNrcyIsIm9uU3RhcnQiLCJlbmNvZGUiLCJvblRva2VuIiwib25UZXh0IiwiZmx1c2giLCJpc09wZW5BSUNhbGxiYWNrcyIsImlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzIiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsInRyaW1TdGFydE9mU3RyZWFtSGVscGVyIiwiaXNTdHJlYW1TdGFydCIsInRyaW1TdGFydCIsIkFJU3RyZWFtIiwicmVzcG9uc2UiLCJvayIsImJvZHkiLCJSZWFkYWJsZVN0cmVhbSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJwaXBlVGhyb3VnaCIsImNsb3NlIiwicmVhZGFibGVGcm9tQXN5bmNJdGVyYWJsZSIsIml0ZXJhYmxlIiwiaXQiLCJTeW1ib2wiLCJhc3luY0l0ZXJhdG9yIiwicHVsbCIsImNhbmNlbCIsInJldHVybiIsImNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciIsImVuY29kZXIiLCJwYXJzZU9wZW5BSVN0cmVhbSIsImV4dHJhY3QiLCJjaHVua1RvVGV4dCIsInN0cmVhbWFibGUiLCJjcmVhdGVkIiwiZ2V0RGF0ZSIsIm9iamVjdCIsIm1vZGVsIiwiY2hvaWNlcyIsImNob2ljZSIsIl9jIiwiX2QiLCJfZSIsIl9mIiwiX2ciLCJmdW5jdGlvbkNhbGwiLCJ0b29sQ2FsbHMiLCJ0b29sQ2FsbCIsImZpbmlzaF9yZWFzb24iLCJmaW5pc2hSZWFzb24iLCJ0cmltU3RhcnRPZlN0cmVhbSIsImlzRnVuY3Rpb25TdHJlYW1pbmdJbiIsImpzb24iLCJfaCIsIl9pIiwiX2oiLCJfayIsIl9sIiwiX20iLCJfbiIsIl9vIiwiX3AiLCJfcSIsIl9yIiwiaXNDaGF0Q29tcGxldGlvbkNodW5rIiwiaXNUZXh0IiwiY2xlYW51cEFyZ3VtZW50cyIsImlzQ29tcGxldGlvbiIsImFyZ3VtZW50Q2h1bmsiLCJlc2NhcGVkUGFydGlhbEpzb24iLCJyZXBsYWNlIiwiX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbCIsIk9wZW5BSVN0cmVhbSIsImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCIsImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIiwiZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lciIsImlzRmlyc3RDaHVuayIsImFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSIsImZ1bmN0aW9uQ2FsbE1lc3NhZ2VzIiwic2hvdWxkSGFuZGxlQXNGdW5jdGlvbiIsInN0YXJ0c1dpdGgiLCJwYXlsb2FkIiwibmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJmdW5jdGlvblJlc3BvbnNlIiwiY29uc29sZSIsIndhcm4iLCJhcmd1bWVudHNQYXlsb2FkIiwicmVzdWx0IiwidG9vbHMiLCJ0b29sIiwiZnVuYyIsInJlc3BvbnNlSW5kZXgiLCJ0b29sX2NhbGxfaWQiLCJmdW5jdGlvbl9uYW1lIiwidG9vbF9jYWxsX3Jlc3VsdCIsImUiLCJmaWx0ZXJlZENhbGxiYWNrcyIsIm9wZW5BSVN0cmVhbSIsIlNUUkVBTUFCTEVfVkFMVUVfVFlQRSIsImZvciIsIkRFVl9ERUZBVUxUX1NUUkVBTUFCTEVfV0FSTklOR19USU1FIiwiY3JlYXRlU3RyZWFtYWJsZVVJIiwiY3VycmVudFZhbHVlIiwiY2xvc2VkIiwiYXNzZXJ0U3RyZWFtIiwibWV0aG9kIiwid2FybmluZ1RpbWVvdXQiLCJ3YXJuVW5jbG9zZWRTdHJlYW0iLCJwcm9jZXNzIiwiY2xlYXJUaW1lb3V0IiwicmVzb2x2YWJsZSIsIlNUUkVBTUFCTEVfVkFMVUVfSU5URVJOQUxfTE9DSyIsImNyZWF0ZVN0cmVhbWFibGVWYWx1ZSIsImlzUmVhZGFibGVTdHJlYW0iLCJsb2NrZWQiLCJjcmVhdGVTdHJlYW1hYmxlVmFsdWVJbXBsIiwic3RyZWFtYWJsZVZhbHVlIiwiY3VycmVudEVycm9yIiwiY3VycmVudFByb21pc2UiLCJjdXJyZW50UGF0Y2hWYWx1ZSIsImNyZWF0ZVdyYXBwZWQiLCJpbml0aWFsQ2h1bmsiLCJpbml0IiwiY3VyciIsInVwZGF0ZVZhbHVlU3RhdGVzIiwicmVzb2x2ZVByZXZpb3VzIiwicmVuZGVyIiwidWkiLCJpbml0aWFsIiwiZnVuY3Rpb25zIiwiT2JqZWN0IiwiZW50cmllcyIsImRlc2NyaXB0aW9uIiwicGFyYW1ldGVycyIsImZpbmlzaGVkIiwiaGFuZGxlUmVuZGVyIiwicmVuZGVyZXIiLCJ0aGVuIiwibm9kZSIsInZhbHVlMiIsIml0ZXJhdG9yIiwiaGFzRnVuY3Rpb24iLCJwcm92aWRlciIsImNoYXQiLCJjb21wbGV0aW9ucyIsImNyZWF0ZSIsImZ1bmN0aW9uQ2FsbFBheWxvYWQiLCJ0b29sQ2FsbFBheWxvYWQiLCJJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yIiwiTm9TdWNoVG9vbEVycm9yIiwic2FmZVBhcnNlSlNPTiIsImRlZmF1bHRUZXh0UmVuZGVyZXIiLCJzdHJlYW1VSSIsImFib3J0U2lnbmFsIiwic2V0dGluZ3MiLCJ0ZXh0UmVuZGVyIiwicmV0cnkiLCJ2YWxpZGF0ZWRQcm9tcHQiLCJkb1N0cmVhbSIsIm1vZGUiLCJpbnB1dEZvcm1hdCIsImZvcmtlZFN0cmVhbSIsInRlZSIsImhhc1Rvb2xDYWxsIiwidGV4dERlbHRhIiwidG9vbE5hbWUiLCJhdmFpbGFibGVUb29scyIsImtleXMiLCJwYXJzZVJlc3VsdCIsInNjaGVtYSIsInN1Y2Nlc3MiLCJ0b29sQXJncyIsImNhdXNlIiwidG9vbENhbGxJZCIsImdlbmVyYXRlIiwiUmVhY3QyIiwiSW50ZXJuYWxBSVByb3ZpZGVyIiwianN4MiIsImlubmVyQWN0aW9uIiwiYWN0aW9uIiwid3JhcEFjdGlvbiIsImJpbmQiLCJjcmVhdGVBSSIsImFjdGlvbnMiLCJpbml0aWFsQUlTdGF0ZSIsImluaXRpYWxVSVN0YXRlIiwib25HZXRVSVN0YXRlIiwid3JhcHBlZEFjdGlvbnMiLCJ3cmFwcGVkU3luY1VJU3RhdGUiLCJBSSIsInByb3BzIiwidWlTdGF0ZSIsImFpU3RhdGUiLCJhaVN0YXRlRGVsdGEiLCJuZXdBSVN0YXRlRGVsdGEiLCJuZXdVSVN0YXRlIiwiaW5pdGlhbEFJU3RhdGVQYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/rsc/dist/rsc-server.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/rsc/dist/rsc-shared.mjs":
/*!*************************************************!*\
  !*** ./node_modules/ai/rsc/dist/rsc-shared.mjs ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InternalAIProvider: () => (/* binding */ e0),
/* harmony export */   readStreamableValue: () => (/* binding */ e1),
/* harmony export */   useAIState: () => (/* binding */ e2),
/* harmony export */   useActions: () => (/* binding */ e3),
/* harmony export */   useStreamableValue: () => (/* binding */ e4),
/* harmony export */   useSyncUIState: () => (/* binding */ e5),
/* harmony export */   useUIState: () => (/* binding */ e6)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`D:\Dashboard\nextjs-template-javascript\node_modules\ai\rsc\dist\rsc-shared.mjs`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`D:\Dashboard\nextjs-template-javascript\node_modules\ai\rsc\dist\rsc-shared.mjs#InternalAIProvider`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`D:\Dashboard\nextjs-template-javascript\node_modules\ai\rsc\dist\rsc-shared.mjs#readStreamableValue`);

const e2 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`D:\Dashboard\nextjs-template-javascript\node_modules\ai\rsc\dist\rsc-shared.mjs#useAIState`);

const e3 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`D:\Dashboard\nextjs-template-javascript\node_modules\ai\rsc\dist\rsc-shared.mjs#useActions`);

const e4 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`D:\Dashboard\nextjs-template-javascript\node_modules\ai\rsc\dist\rsc-shared.mjs#useStreamableValue`);

const e5 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`D:\Dashboard\nextjs-template-javascript\node_modules\ai\rsc\dist\rsc-shared.mjs#useSyncUIState`);

const e6 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`D:\Dashboard\nextjs-template-javascript\node_modules\ai\rsc\dist\rsc-shared.mjs#useUIState`);


/***/ })

};
;