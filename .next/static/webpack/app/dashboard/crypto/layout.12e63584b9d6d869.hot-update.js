"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/dashboard/crypto/layout",{

/***/ "(app-pages-browser)/./src/app/actions.js":
/*!****************************!*\
  !*** ./src/app/actions.js ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fetchMarketData: function() { return /* binding */ fetchMarketData; },\n/* harmony export */   fetchWallet: function() { return /* binding */ fetchWallet; },\n/* harmony export */   fetchWalletProfile: function() { return /* binding */ fetchWalletProfile; },\n/* harmony export */   initializeMoralis: function() { return /* binding */ initializeMoralis; }\n/* harmony export */ });\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dayjs */ \"(app-pages-browser)/./node_modules/dayjs/dayjs.min.js\");\n/* harmony import */ var dayjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dayjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ethers */ \"(app-pages-browser)/./node_modules/ethers/lib.esm/utils/units.js\");\n/* harmony import */ var moralis__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! moralis */ \"(app-pages-browser)/./node_modules/moralis/lib/esm/index.js\");\n/* harmony import */ var _utilities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utilities */ \"(app-pages-browser)/./src/app/utilities.js\");\n/* eslint-disable no-await-in-loop -- need to do this in an awhile loop */ /* eslint-disable camelcase -- Disable the camelcase linting rule to allow the use of non-camelcase variable names. */ \"\";\n\n\n\n\nconst now = dayjs__WEBPACK_IMPORTED_MODULE_0___default()();\nlet isMoralisStarted = false;\nasync function initializeMoralis() {\n    if (!isMoralisStarted) {\n        await moralis__WEBPACK_IMPORTED_MODULE_2__[\"default\"].start({\n            apiKey: \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJub25jZSI6ImYyYWFjMzU4LWE5M2UtNDEwMS1iZTBmLWM5YjI5MDYyMzdmZiIsIm9yZ0lkIjoiMzkzODQzIiwidXNlcklkIjoiNDA0Njg5IiwidHlwZUlkIjoiYjg3OGQ0MGQtOTYxOC00NDQ4LTkyNDUtNzYwOTNhNGQ3MWMwIiwidHlwZSI6IlBST0pFQ1QiLCJpYXQiOjE3MTY3NzMzMzEsImV4cCI6NDg3MjUzMzMzMX0.76CE0ZsDOveqiwDMumSifjOCFKsfHbsUj89yFImVr8s\"\n        });\n        isMoralisStarted = true;\n    }\n}\nasync function fetchMarketData() {\n    try {\n        await initializeMoralis();\n        const response = await moralis__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EvmApi.marketData.getTopCryptoCurrenciesByMarketCap({});\n        return response.toJSON();\n    } catch (e) {\n        console.error(\"Failed to fetch market data\", e);\n    }\n}\nasync function fetchWallet(walletAddress) {\n    try {\n        const address = walletAddress;\n        await initializeMoralis();\n        const chainIds = _utilities__WEBPACK_IMPORTED_MODULE_1__.chains.map((chain)=>chain.id);\n        const walletChainsPromise = await moralis__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EvmApi.wallets.getWalletActiveChains({\n            address: walletAddress,\n            chains: [\n                \"0x1\",\n                \"0x38\"\n            ]\n        });\n        console.log(\"walletChainsPromise\", walletChainsPromise);\n        const balancePromise = await moralis__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EvmApi.balance.getNativeBalance({\n            chain: \"0x1\",\n            address: walletAddress\n        });\n        const [response, get_balance] = await Promise.all([\n            walletChainsPromise,\n            balancePromise\n        ]);\n        if (!response) {\n            throw new Error(\"Error fetching chains: \".concat(response.statusText));\n        }\n        const active_chains = response.toJSON();\n        console.log(\"active_chains\", active_chains);\n        const balance = get_balance.toJSON();\n        console.log(\"balance\", balance);\n        //const chainsArray = active_chains.active_chains.map((chain) => chain.chain_id);\n        const fetch_networth = await moralis__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EvmApi.wallets.getWalletNetWorth({\n            excludeSpam: true,\n            excludeUnverifiedContracts: true,\n            address: walletAddress,\n            chains: [\n                \"0x1\"\n            ]\n        });\n        let networth = 0;\n        if (!fetch_networth) {\n            console.log(\"Error fetching net-worth: \".concat(fetch_networth.statusText));\n        }\n        networth = fetch_networth.toJSON();\n        let networthDataLabels = [];\n        let networthDatasets = [];\n        if (networth.chains && networth.chains.length > 0) {\n            networth.chains.forEach((item)=>{\n                networthDataLabels.push(item.chain);\n                networthDatasets.push(Number(item.networth_usd));\n            });\n        }\n        let isWhale = false;\n        let earlyAdopter = false;\n        let multiChainer = false;\n        let speculator = false;\n        let isFresh = false;\n        //100 eth\n        if (ethers__WEBPACK_IMPORTED_MODULE_3__.formatEther(balance.balance) > ethers__WEBPACK_IMPORTED_MODULE_3__.formatEther(\"100000000000000000000\")) isWhale = true;\n        const wallet_chains = [];\n        const earlyAdopterDate = new Date(\"2016-01-01\");\n        for (const chain of active_chains.active_chains){\n            if (chain.first_transaction) {\n                wallet_chains.push(chain);\n                if (chain.first_transaction) {\n                    if (new Date(chain.first_transaction.block_timestamp) < earlyAdopterDate) earlyAdopter = true;\n                }\n            }\n        }\n        const one_day_ago = now.subtract(1, \"day\");\n        let firstSeenDate = _utilities__WEBPACK_IMPORTED_MODULE_1__.findEarliestAndLatestTimestamps(active_chains.active_chains).earliest;\n        let lastSeenDate = _utilities__WEBPACK_IMPORTED_MODULE_1__.findEarliestAndLatestTimestamps(active_chains.active_chains).latest;\n        wallet_chains.forEach((item)=>{\n            item.label = _utilities__WEBPACK_IMPORTED_MODULE_1__.getChainName(item.chain);\n            if (new Date(item.first_transaction.block_timestamp) < new Date(firstSeenDate.block_timestamp)) {\n                firstSeenDate = item.first_transaction.block_timestamp;\n            }\n            if (new Date(item.last_transaction.block_timestamp) > new Date(lastSeenDate.block_timestamp)) {\n                lastSeenDate = item.last_transaction.block_timestamp;\n            }\n        });\n        let walletAge = _utilities__WEBPACK_IMPORTED_MODULE_1__.calcAge(firstSeenDate);\n        if (new Date(firstSeenDate) > new Date(one_day_ago)) isFresh = true;\n        if (wallet_chains.length > 1) multiChainer = true;\n        const responseObject = {\n            address,\n            networth: networth.total_networth_usd,\n            networthDataLabels,\n            networthDatasets,\n            active_chains: wallet_chains,\n            walletAge,\n            firstSeenDate,\n            lastSeenDate,\n            isWhale,\n            earlyAdopter,\n            multiChainer,\n            speculator,\n            balance: balance.balance,\n            dayjs: (dayjs__WEBPACK_IMPORTED_MODULE_0___default()),\n            isFresh\n        };\n        console.log(\"fetched wallet\", responseObject);\n        return responseObject;\n    } catch (e) {\n        console.error(e);\n    }\n}\nasync function fetchWalletProfile(address, chain) {\n    try {\n        await initializeMoralis();\n        const statsPromise = await moralis__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EvmApi.wallets.getWalletStats({\n            address,\n            chain\n        });\n        const tokensPromise = await moralis__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EvmApi.wallets.getWalletTokenBalancesPrice({\n            address,\n            chain\n        });\n        // Initialize chart data for the last 90 days\n        let chart_data = [];\n        // Start from today\n        let currentDate = new Date();\n        for(let i = 0; i < 90; i++){\n            let formattedDate = currentDate.toISOString().split(\"T\")[0];\n            chart_data.push({\n                x: formattedDate,\n                y: 0\n            });\n            // Subtract a day for the next iteration\n            currentDate.setDate(currentDate.getDate() - 1);\n        }\n        const days = dayjs__WEBPACK_IMPORTED_MODULE_0___default()().subtract(90, \"day\").format(\"YYYY-MM-DD\");\n        let cursor = null;\n        let all_txs = [];\n        // Fetch transactions within the last 90 days\n        do {\n            const response = await moralis__WEBPACK_IMPORTED_MODULE_2__[\"default\"].EvmApi.transaction.getWalletTransactions({\n                address,\n                chain,\n                from_date: days,\n                cursor\n            });\n            const txs = await response.json();\n            cursor = txs.cursor;\n            if (txs.result) {\n                for (let item of txs.result){\n                    all_txs.push(item);\n                }\n            }\n        }while (cursor !== \"\" && cursor !== null);\n        // Process transaction data for chart\n        if (all_txs.length > 0) {\n            all_txs.forEach((data)=>{\n                let blockDate = data.block_timestamp.split(\"T\")[0];\n                // Find the corresponding date in the chartArray\n                let chartItem = chart_data.find((item)=>item.x === blockDate);\n                if (chartItem) {\n                    chartItem.y += 1;\n                }\n            });\n        }\n        let chartArray = _utilities__WEBPACK_IMPORTED_MODULE_1__.generateWeekArray(9);\n        _utilities__WEBPACK_IMPORTED_MODULE_1__.updateChartArrayByWeek(chartArray, all_txs);\n        chartArray = chartArray.reverse();\n        // Resolve promises for wallet stats, tokens, and net worth\n        const [statsResponse, tokensResponse] = await Promise.all([\n            statsPromise,\n            tokensPromise\n        ]);\n        const stats = await statsResponse.json();\n        const tokens = await tokensResponse.json();\n        let collector = false;\n        if (Number(stats.nfts) > 20) {\n            collector = true;\n        }\n        // Construct the response object\n        const responseObject = {\n            addressOccurrences: _utilities__WEBPACK_IMPORTED_MODULE_1__.findAddressOccurrences(all_txs, address),\n            chartArray,\n            stats,\n            tokens: tokens.result,\n            collector\n        };\n        console.log(\"wallet profile\", responseObject);\n        return responseObject;\n    } catch (e) {\n        console.error(\"Failed to fetch wallet profile\", e);\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvYWN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQSx3RUFBd0UsR0FDeEUsb0hBQW9ILEdBQ3BIO0FBQzBCO0FBQ007QUFDRjtBQUVXO0FBRXpDLE1BQU1JLE1BQU1KLDRDQUFLQTtBQUVqQixJQUFJSyxtQkFBbUI7QUFFaEIsZUFBZUM7SUFFcEIsSUFBSSxDQUFDRCxrQkFBa0I7UUFFckIsTUFBTUgsK0NBQU9BLENBQUNLLEtBQUssQ0FBQztZQUNsQkMsUUFBUUMsc1VBQXVDO1FBQ2pEO1FBQ0FKLG1CQUFtQjtJQUNyQjtBQUNGO0FBRU8sZUFBZU87SUFDcEIsSUFBSTtRQUNGLE1BQU1OO1FBRU4sTUFBTU8sV0FBVyxNQUFNWCwrQ0FBT0EsQ0FBQ1ksTUFBTSxDQUFDQyxVQUFVLENBQUNDLGlDQUFpQyxDQUFDLENBQUM7UUFDcEYsT0FBT0gsU0FBU0ksTUFBTTtJQUN4QixFQUFFLE9BQU9DLEdBQUc7UUFDVkMsUUFBUUMsS0FBSyxDQUFDLCtCQUErQkY7SUFDL0M7QUFDRjtBQUVPLGVBQWVHLFlBQVlDLGFBQWE7SUFDN0MsSUFBSTtRQUNGLE1BQU1DLFVBQVVEO1FBRWhCLE1BQU1oQjtRQUVOLE1BQU1rQixXQUFXckIsOENBQWdCLENBQUN1QixHQUFHLENBQUNDLENBQUFBLFFBQVNBLE1BQU1DLEVBQUU7UUFFdkQsTUFBTUMsc0JBQXNCLE1BQU0zQiwrQ0FBT0EsQ0FBQ1ksTUFBTSxDQUFDZ0IsT0FBTyxDQUFDQyxxQkFBcUIsQ0FBQztZQUM3RVIsU0FBU0Q7WUFDVEcsUUFBUTtnQkFBQztnQkFBTzthQUFPO1FBQ3pCO1FBQ0FOLFFBQVFhLEdBQUcsQ0FBQyx1QkFBdUJIO1FBQ25DLE1BQU1JLGlCQUFpQixNQUFNL0IsK0NBQU9BLENBQUNZLE1BQU0sQ0FBQ29CLE9BQU8sQ0FBQ0MsZ0JBQWdCLENBQUM7WUFDbkVSLE9BQU87WUFDUEosU0FBU0Q7UUFDWDtRQUVBLE1BQU0sQ0FBQ1QsVUFB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QUk7UUFFeEMsSUFBSWMsWUFBWTtRQUNoQixJQUFJaEUsT0FBTzhELE1BQU1HLElBQUksSUFBSSxJQUFJO1lBQzNCRCxZQUFZO1FBQ2Q7UUFFQSxnQ0FBZ0M7UUFDaEMsTUFBTXZDLGlCQUFpQjtZQUNyQnlDLG9CQUFvQnBILDhEQUFnQyxDQUFDK0YsU0FBUzNFO1lBQzlEc0Y7WUFDQU07WUFDQUMsUUFBUUEsT0FBT1osTUFBTTtZQUNyQmE7UUFDRjtRQUNBbEcsUUFBUWEsR0FBRyxDQUFDLGtCQUFrQjhDO1FBQzlCLE9BQU9BO0lBQ1QsRUFBRSxPQUFPNUQsR0FBRztRQUNWQyxRQUFRQyxLQUFLLENBQUMsa0NBQWtDRjtJQUNsRDtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcHAvYWN0aW9ucy5qcz81MzkwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLWF3YWl0LWluLWxvb3AgLS0gbmVlZCB0byBkbyB0aGlzIGluIGFuIGF3aGlsZSBsb29wICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAtLSBEaXNhYmxlIHRoZSBjYW1lbGNhc2UgbGludGluZyBydWxlIHRvIGFsbG93IHRoZSB1c2Ugb2Ygbm9uLWNhbWVsY2FzZSB2YXJpYWJsZSBuYW1lcy4gKi9cclxuJydcclxuaW1wb3J0IGRheWpzIGZyb20gJ2RheWpzJztcclxuaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcclxuaW1wb3J0IE1vcmFsaXMgZnJvbSAnbW9yYWxpcyc7XHJcblxyXG5pbXBvcnQgKiBhcyB1dGlsaXRpZXMgZnJvbSAnLi91dGlsaXRpZXMnO1xyXG5cclxuY29uc3Qgbm93ID0gZGF5anMoKTtcclxuXHJcbmxldCBpc01vcmFsaXNTdGFydGVkID0gZmFsc2U7XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gaW5pdGlhbGl6ZU1vcmFsaXMoKSB7XHJcbiAgXHJcbiAgaWYgKCFpc01vcmFsaXNTdGFydGVkKSB7XHJcbiAgICBcclxuICAgIGF3YWl0IE1vcmFsaXMuc3RhcnQoe1xyXG4gICAgICBhcGlLZXk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX01PUkFMSVNfQVBJX0tFWVxyXG4gICAgfSk7XHJcbiAgICBpc01vcmFsaXNTdGFydGVkID0gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaE1hcmtldERhdGEoKSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGluaXRpYWxpemVNb3JhbGlzKCk7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBNb3JhbGlzLkV2bUFwaS5tYXJrZXREYXRhLmdldFRvcENyeXB0b0N1cnJlbmNpZXNCeU1hcmtldENhcCh7fSk7XHJcbiAgICByZXR1cm4gcmVzcG9uc2UudG9KU09OKCk7XHJcbiAgfSBjYXRjaCAoZSkge1xyXG4gICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIG1hcmtldCBkYXRhJywgZSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hXYWxsZXQod2FsbGV0QWRkcmVzcykge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBhZGRyZXNzID0gd2FsbGV0QWRkcmVzcztcclxuXHJcbiAgICBhd2FpdCBpbml0aWFsaXplTW9yYWxpcygpO1xyXG4gICAgXHJcbiAgICBjb25zdCBjaGFpbklkcyA9IHV0aWxpdGllcy5jaGFpbnMubWFwKGNoYWluID0+IGNoYWluLmlkKTtcclxuXHJcbiAgICBjb25zdCB3YWxsZXRDaGFpbnNQcm9taXNlID0gYXdhaXQgTW9yYWxpcy5Fdm1BcGkud2FsbGV0cy5nZXRXYWxsZXRBY3RpdmVDaGFpbnMoe1xyXG4gICAgICBhZGRyZXNzOiB3YWxsZXRBZGRyZXNzLFxyXG4gICAgICBjaGFpbnM6IFsnMHgxJywgJzB4MzgnXSxcclxuICAgIH0pO1xyXG4gICAgY29uc29sZS5sb2coJ3dhbGxldENoYWluc1Byb21pc2UnLCB3YWxsZXRDaGFpbnNQcm9taXNlKVxyXG4gICAgY29uc3QgYmFsYW5jZVByb21pc2UgPSBhd2FpdCBNb3JhbGlzLkV2bUFwaS5iYWxhbmNlLmdldE5hdGl2ZUJhbGFuY2Uoe1xyXG4gICAgICBjaGFpbjogJzB4MScsXHJcbiAgICAgIGFkZHJlc3M6IHdhbGxldEFkZHJlc3MsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc3QgW3Jlc3BvbnNlLCBnZXRfYmFsYW5jZV0gPSBhd2FpdCBQcm9taXNlLmFsbChbd2FsbGV0Q2hhaW5zUHJvbWlzZSwgYmFsYW5jZVByb21pc2VdKTtcclxuXHJcbiAgICBpZiAoIXJlc3BvbnNlKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZmV0Y2hpbmcgY2hhaW5zOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGFjdGl2ZV9jaGFpbnMgPSByZXNwb25zZS50b0pTT04oKTtcclxuICAgIGNvbnNvbGUubG9nKCdhY3RpdmVfY2hhaW5zJywgYWN0aXZlX2NoYWlucylcclxuICAgIGNvbnN0IGJhbGFuY2UgPSBnZXRfYmFsYW5jZS50b0pTT04oKTtcclxuICAgIGNvbnNvbGUubG9nKCdiYWxhbmNlJywgYmFsYW5jZSlcclxuXHJcbiAgICAvL2NvbnN0IGNoYWluc0FycmF5ID0gYWN0aXZlX2NoYWlucy5hY3RpdmVfY2hhaW5zLm1hcCgoY2hhaW4pID0+IGNoYWluLmNoYWluX2lkKTtcclxuXHJcbiAgICBjb25zdCBmZXRjaF9uZXR3b3J0aCA9IGF3YWl0IE1vcmFsaXMuRXZtQXBpLndhbGxldHMuZ2V0V2FsbGV0TmV0V29ydGgoe1xyXG4gICAgICBleGNsdWRlU3BhbTogdHJ1ZSxcclxuICAgICAgZXhjbHVkZVVudmVyaWZpZWRDb250cmFjdHM6IHRydWUsXHJcbiAgICAgIGFkZHJlc3M6IHdhbGxldEFkZHJlc3MsXHJcbiAgICAgIGNoYWluczogWycweDEnXSxcclxuICAgIH0pO1xyXG5cclxuICAgIGxldCBuZXR3b3J0aCA9IDA7XHJcbiAgICBpZiAoIWZldGNoX25ldHdvcnRoKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBFcnJvciBmZXRjaGluZyBuZXQtd29ydGg6ICR7ZmV0Y2hfbmV0d29ydGguc3RhdHVzVGV4dH1gKTtcclxuICAgIH1cclxuXHJcbiAgICBuZXR3b3J0aCA9IGZldGNoX25ldHdvcnRoLnRvSlNPTigpO1xyXG5cclxuICAgIGxldCBuZXR3b3J0aERhdGFMYWJlbHMgPSBbXTtcclxuICAgIGxldCBuZXR3b3J0aERhdGFzZXRzID0gW107XHJcblxyXG4gICAgaWYgKG5ldHdvcnRoLmNoYWlucyAmJiBuZXR3b3J0aC5jaGFpbnMubGVuZ3RoID4gMCkge1xyXG4gICAgICBuZXR3b3J0aC5jaGFpbnMuZm9yRWFjaCgoaXRlbSkgPT4ge1xyXG4gICAgICAgIG5ldHdvcnRoRGF0YUxhYmVscy5wdXNoKGl0ZW0uY2hhaW4pO1xyXG4gICAgICAgIG5ldHdvcnRoRGF0YXNldHMucHVzaChOdW1iZXIoaXRlbS5uZXR3b3J0aF91c2QpKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IGlzV2hhbGUgPSBmYWxzZTtcclxuICAgIGxldCBlYXJseUFkb3B0ZXIgPSBmYWxzZTtcclxuICAgIGxldCBtdWx0aUNoYWluZXIgPSBmYWxzZTtcclxuICAgIGxldCBzcGVjdWxhdG9yID0gZmFsc2U7XHJcbiAgICBsZXQgaXNGcmVzaCA9IGZhbHNlO1xyXG5cclxuICAgIC8vMTAwIGV0aFxyXG4gICAgaWYgKGV0aGVycy5mb3JtYXRFdGhlcihiYWxhbmNlLmJhbGFuY2UpID4gZXRoZXJzLmZvcm1hdEV0aGVyKGAxMDAwMDAwMDAwMDAwMDAwMDAwMDBgKSkgaXNXaGFsZSA9IHRydWU7XHJcblxyXG4gICAgY29uc3Qgd2FsbGV0X2NoYWlucyA9IFtdO1xyXG4gICAgY29uc3QgZWFybHlBZG9wdGVyRGF0ZSA9IG5ldyBEYXRlKCcyMDE2LTAxLTAxJyk7XHJcblxyXG4gICAgZm9yIChjb25zdCBjaGFpbiBvZiBhY3RpdmVfY2hhaW5zLmFjdGl2ZV9jaGFpbnMpIHtcclxuICAgICAgaWYgKGNoYWluLmZpcnN0X3RyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgd2FsbGV0X2NoYWlucy5wdXNoKGNoYWluKTtcclxuXHJcbiAgICAgICAgaWYgKGNoYWluLmZpcnN0X3RyYW5zYWN0aW9uKSB7XHJcbiAgICAgICAgICBpZiAobmV3IERhdGUoY2hhaW4uZmlyc3RfdHJhbnNhY3Rpb24uYmxvY2tfdGltZXN0YW1wKSA8IGVhcmx5QWRvcHRlckRhdGUpIGVhcmx5QWRvcHRlciA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbmVfZGF5X2FnbyA9IG5vdy5zdWJ0cmFjdCgxLCAnZGF5Jyk7XHJcbiAgICBsZXQgZmlyc3RTZWVuRGF0ZSA9IHV0aWxpdGllcy5maW5kRWFybGllc3RBbmRMYXRlc3RUaW1lc3RhbXBzKGFjdGl2ZV9jaGFpbnMuYWN0aXZlX2NoYWlucykuZWFybGllc3Q7XHJcbiAgICBsZXQgbGFzdFNlZW5EYXRlID0gdXRpbGl0aWVzLmZpbmRFYXJsaWVzdEFuZExhdGVzdFRpbWVzdGFtcHMoYWN0aXZlX2NoYWlucy5hY3RpdmVfY2hhaW5zKS5sYXRlc3Q7XHJcblxyXG4gICAgd2FsbGV0X2NoYWlucy5mb3JFYWNoKChpdGVtKSA9PiB7XHJcbiAgICAgIGl0ZW0ubGFiZWwgPSB1dGlsaXRpZXMuZ2V0Q2hhaW5OYW1lKGl0ZW0uY2hhaW4pO1xyXG4gICAgICBpZiAobmV3IERhdGUoaXRlbS5maXJzdF90cmFuc2FjdGlvbi5ibG9ja190aW1lc3RhbXApIDwgbmV3IERhdGUoZmlyc3RTZWVuRGF0ZS5ibG9ja190aW1lc3RhbXApKSB7XHJcbiAgICAgICAgZmlyc3RTZWVuRGF0ZSA9IGl0ZW0uZmlyc3RfdHJhbnNhY3Rpb24uYmxvY2tfdGltZXN0YW1wO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuZXcgRGF0ZShpdGVtLmxhc3RfdHJhbnNhY3Rpb24uYmxvY2tfdGltZXN0YW1wKSA+IG5ldyBEYXRlKGxhc3RTZWVuRGF0ZS5ibG9ja190aW1lc3RhbXApKSB7XHJcbiAgICAgICAgbGFzdFNlZW5EYXRlID0gaXRlbS5sYXN0X3RyYW5zYWN0aW9uLmJsb2NrX3RpbWVzdGFtcDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgbGV0IHdhbGxldEFnZSA9IHV0aWxpdGllcy5jYWxjQWdlKGZpcnN0U2VlbkRhdGUpO1xyXG5cclxuICAgIGlmIChuZXcgRGF0ZShmaXJzdFNlZW5EYXRlKSA+IG5ldyBEYXRlKG9uZV9kYXlfYWdvKSkgaXNGcmVzaCA9IHRydWU7XHJcblxyXG4gICAgaWYgKHdhbGxldF9jaGFpbnMubGVuZ3RoID4gMSkgbXVsdGlDaGFpbmVyID0gdHJ1ZTtcclxuXHJcbiAgICBjb25zdCByZXNwb25zZU9iamVjdCA9IHtcclxuICAgICAgYWRkcmVzcyxcclxuICAgICAgbmV0d29ydGg6IG5ldHdvcnRoLnRvdGFsX25ldHdvcnRoX3VzZCxcclxuICAgICAgbmV0d29ydGhEYXRhTGFiZWxzLFxyXG4gICAgICBuZXR3b3J0aERhdGFzZXRzLFxyXG4gICAgICBhY3RpdmVfY2hhaW5zOiB3YWxsZXRfY2hhaW5zLFxyXG4gICAgICB3YWxsZXRBZ2UsXHJcbiAgICAgIGZpcnN0U2VlbkRhdGUsXHJcbiAgICAgIGxhc3RTZWVuRGF0ZSxcclxuICAgICAgaXNXaGFsZSxcclxuICAgICAgZWFybHlBZG9wdGVyLFxyXG4gICAgICBtdWx0aUNoYWluZXIsXHJcbiAgICAgIHNwZWN1bGF0b3IsXHJcbiAgICAgIGJhbGFuY2U6IGJhbGFuY2UuYmFsYW5jZSxcclxuICAgICAgZGF5anMsXHJcbiAgICAgIGlzRnJlc2gsXHJcbiAgICB9O1xyXG4gICAgY29uc29sZS5sb2coJ2ZldGNoZWQgd2FsbGV0JywgcmVzcG9uc2VPYmplY3QpO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0O1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoZSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hXYWxsZXRQcm9maWxlKGFkZHJlc3MsIGNoYWluKSB7XHJcbiAgdHJ5IHtcclxuICAgIGF3YWl0IGluaXRpYWxpemVNb3JhbGlzKCk7XHJcblxyXG4gICAgY29uc3Qgc3RhdHNQcm9taXNlID0gYXdhaXQgTW9yYWxpcy5Fdm1BcGkud2FsbGV0cy5nZXRXYWxsZXRTdGF0cyh7XHJcbiAgICAgIGFkZHJlc3MsXHJcbiAgICAgIGNoYWluLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdG9rZW5zUHJvbWlzZSA9IGF3YWl0IE1vcmFsaXMuRXZtQXBpLndhbGxldHMuZ2V0V2FsbGV0VG9rZW5CYWxhbmNlc1ByaWNlKHtcclxuICAgICAgYWRkcmVzcyxcclxuICAgICAgY2hhaW4sXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBJbml0aWFsaXplIGNoYXJ0IGRhdGEgZm9yIHRoZSBsYXN0IDkwIGRheXNcclxuICAgIGxldCBjaGFydF9kYXRhID0gW107XHJcbiAgICAvLyBTdGFydCBmcm9tIHRvZGF5XHJcbiAgICBsZXQgY3VycmVudERhdGUgPSBuZXcgRGF0ZSgpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTA7IGkrKykge1xyXG4gICAgICBsZXQgZm9ybWF0dGVkRGF0ZSA9IGN1cnJlbnREYXRlLnRvSVNPU3RyaW5nKCkuc3BsaXQoJ1QnKVswXTtcclxuICAgICAgY2hhcnRfZGF0YS5wdXNoKHsgeDogZm9ybWF0dGVkRGF0ZSwgeTogMCB9KTtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IGEgZGF5IGZvciB0aGUgbmV4dCBpdGVyYXRpb25cclxuICAgICAgY3VycmVudERhdGUuc2V0RGF0ZShjdXJyZW50RGF0ZS5nZXREYXRlKCkgLSAxKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBkYXlzID0gZGF5anMoKS5zdWJ0cmFjdCg5MCwgJ2RheScpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xyXG4gICAgbGV0IGN1cnNvciA9IG51bGw7XHJcbiAgICBsZXQgYWxsX3R4cyA9IFtdO1xyXG5cclxuICAgIC8vIEZldGNoIHRyYW5zYWN0aW9ucyB3aXRoaW4gdGhlIGxhc3QgOTAgZGF5c1xyXG4gICAgZG8ge1xyXG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IE1vcmFsaXMuRXZtQXBpLnRyYW5zYWN0aW9uLmdldFdhbGxldFRyYW5zYWN0aW9ucyh7XHJcbiAgICAgICAgYWRkcmVzcyxcclxuICAgICAgICBjaGFpbixcclxuICAgICAgICBmcm9tX2RhdGU6IGRheXMsXHJcbiAgICAgICAgY3Vyc29yLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IHR4cyA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcclxuICAgICAgY3Vyc29yID0gdHhzLmN1cnNvcjtcclxuXHJcbiAgICAgIGlmICh0eHMucmVzdWx0KSB7XHJcbiAgICAgICAgZm9yIChsZXQgaXRlbSBvZiB0eHMucmVzdWx0KSB7XHJcbiAgICAgICAgICBhbGxfdHhzLnB1c2goaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IHdoaWxlIChjdXJzb3IgIT09ICcnICYmIGN1cnNvciAhPT0gbnVsbCk7XHJcblxyXG4gICAgLy8gUHJvY2VzcyB0cmFuc2FjdGlvbiBkYXRhIGZvciBjaGFydFxyXG4gICAgaWYgKGFsbF90eHMubGVuZ3RoID4gMCkge1xyXG4gICAgICBhbGxfdHhzLmZvckVhY2goKGRhdGEpID0+IHtcclxuICAgICAgICBsZXQgYmxvY2tEYXRlID0gZGF0YS5ibG9ja190aW1lc3RhbXAuc3BsaXQoJ1QnKVswXTtcclxuICAgICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGRhdGUgaW4gdGhlIGNoYXJ0QXJyYXlcclxuICAgICAgICBsZXQgY2hhcnRJdGVtID0gY2hhcnRfZGF0YS5maW5kKChpdGVtKSA9PiBpdGVtLnggPT09IGJsb2NrRGF0ZSk7XHJcblxyXG4gICAgICAgIGlmIChjaGFydEl0ZW0pIHtcclxuICAgICAgICAgIGNoYXJ0SXRlbS55ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgY2hhcnRBcnJheSA9IHV0aWxpdGllcy5nZW5lcmF0ZVdlZWtBcnJheSg5KTtcclxuXHJcbiAgICB1dGlsaXRpZXMudXBkYXRlQ2hhcnRBcnJheUJ5V2VlayhjaGFydEFycmF5LCBhbGxfdHhzKTtcclxuICAgIGNoYXJ0QXJyYXkgPSBjaGFydEFycmF5LnJldmVyc2UoKTtcclxuXHJcbiAgICAvLyBSZXNvbHZlIHByb21pc2VzIGZvciB3YWxsZXQgc3RhdHMsIHRva2VucywgYW5kIG5ldCB3b3J0aFxyXG4gICAgY29uc3QgW3N0YXRzUmVzcG9uc2UsIHRva2Vuc1Jlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFtzdGF0c1Byb21pc2UsIHRva2Vuc1Byb21pc2VdKTtcclxuICAgIGNvbnN0IHN0YXRzID0gYXdhaXQgc3RhdHNSZXNwb25zZS5qc29uKCk7XHJcbiAgICBjb25zdCB0b2tlbnMgPSBhd2FpdCB0b2tlbnNSZXNwb25zZS5qc29uKCk7XHJcblxyXG4gICAgbGV0IGNvbGxlY3RvciA9IGZhbHNlO1xyXG4gICAgaWYgKE51bWJlcihzdGF0cy5uZnRzKSA+IDIwKSB7XHJcbiAgICAgIGNvbGxlY3RvciA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29uc3RydWN0IHRoZSByZXNwb25zZSBvYmplY3RcclxuICAgIGNvbnN0IHJlc3BvbnNlT2JqZWN0ID0ge1xyXG4gICAgICBhZGRyZXNzT2NjdXJyZW5jZXM6IHV0aWxpdGllcy5maW5kQWRkcmVzc09jY3VycmVuY2VzKGFsbF90eHMsIGFkZHJlc3MpLFxyXG4gICAgICBjaGFydEFycmF5LFxyXG4gICAgICBzdGF0cyxcclxuICAgICAgdG9rZW5zOiB0b2tlbnMucmVzdWx0LFxyXG4gICAgICBjb2xsZWN0b3IsXHJcbiAgICB9O1xyXG4gICAgY29uc29sZS5sb2coJ3dhbGxldCBwcm9maWxlJywgcmVzcG9uc2VPYmplY3QpO1xyXG4gICAgcmV0dXJuIHJlc3BvbnNlT2JqZWN0O1xyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCB3YWxsZXQgcHJvZmlsZScsIGUpO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiZGF5anMiLCJldGhlcnMiLCJNb3JhbGlzIiwidXRpbGl0aWVzIiwibm93IiwiaXNNb3JhbGlzU3RhcnRlZCIsImluaXRpYWxpemVNb3JhbGlzIiwic3RhcnQiLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfTU9SQUxJU19BUElfS0VZIiwiZmV0Y2hNYXJrZXREYXRhIiwicmVzcG9uc2UiLCJFdm1BcGkiLCJtYXJrZXREYXRhIiwiZ2V0VG9wQ3J5cHRvQ3VycmVuY2llc0J5TWFya2V0Q2FwIiwidG9KU09OIiwiZSIsImNvbnNvbGUiLCJlcnJvciIsImZldGNoV2FsbGV0Iiwid2FsbGV0QWRkcmVzcyIsImFkZHJlc3MiLCJjaGFpbklkcyIsImNoYWlucyIsIm1hcCIsImNoYWluIiwiaWQiLCJ3YWxsZXRDaGFpbnNQcm9taXNlIiwid2FsbGV0cyIsImdldFdhbGxldEFjdGl2ZUNoYWlucyIsImxvZyIsImJhbGFuY2VQcm9taXNlIiwiYmFsYW5jZSIsImdldE5hdGl2ZUJhbGFuY2UiLCJnZXRfYmFsYW5jZSIsIlByb21pc2UiLCJhbGwiLCJFcnJvciIsInN0YXR1c1RleHQiLCJhY3RpdmVfY2hhaW5zIiwiZmV0Y2hfbmV0d29ydGgiLCJnZXRXYWxsZXROZXRXb3J0aCIsImV4Y2x1ZGVTcGFtIiwiZXhjbHVkZVVudmVyaWZpZWRDb250cmFjdHMiLCJuZXR3b3J0aCIsIm5ldHdvcnRoRGF0YUxhYmVscyIsIm5ldHdvcnRoRGF0YXNldHMiLCJsZW5ndGgiLCJmb3JFYWNoIiwiaXRlbSIsInB1c2giLCJOdW1iZXIiLCJuZXR3b3J0aF91c2QiLCJpc1doYWxlIiwiZWFybHlBZG9wdGVyIiwibXVsdGlDaGFpbmVyIiwic3BlY3VsYXRvciIsImlzRnJlc2giLCJmb3JtYXRFdGhlciIsIndhbGxldF9jaGFpbnMiLCJlYXJseUFkb3B0ZXJEYXRlIiwiRGF0ZSIsImZpcnN0X3RyYW5zYWN0aW9uIiwiYmxvY2tfdGltZXN0YW1wIiwib25lX2RheV9hZ28iLCJzdWJ0cmFjdCIsImZpcnN0U2VlbkRhdGUiLCJmaW5kRWFybGllc3RBbmRMYXRlc3RUaW1lc3RhbXBzIiwiZWFybGllc3QiLCJsYXN0U2VlbkRhdGUiLCJsYXRlc3QiLCJsYWJlbCIsImdldENoYWluTmFtZSIsImxhc3RfdHJhbnNhY3Rpb24iLCJ3YWxsZXRBZ2UiLCJjYWxjQWdlIiwicmVzcG9uc2VPYmplY3QiLCJ0b3RhbF9uZXR3b3J0aF91c2QiLCJmZXRjaFdhbGxldFByb2ZpbGUiLCJzdGF0c1Byb21pc2UiLCJnZXRXYWxsZXRTdGF0cyIsInRva2Vuc1Byb21pc2UiLCJnZXRXYWxsZXRUb2tlbkJhbGFuY2VzUHJpY2UiLCJjaGFydF9kYXRhIiwiY3VycmVudERhdGUiLCJpIiwiZm9ybWF0dGVkRGF0ZSIsInRvSVNPU3RyaW5nIiwic3BsaXQiLCJ4IiwieSIsInNldERhdGUiLCJnZXREYXRlIiwiZGF5cyIsImZvcm1hdCIsImN1cnNvciIsImFsbF90eHMiLCJ0cmFuc2FjdGlvbiIsImdldFdhbGxldFRyYW5zYWN0aW9ucyIsImZyb21fZGF0ZSIsInR4cyIsImpzb24iLCJyZXN1bHQiLCJkYXRhIiwiYmxvY2tEYXRlIiwiY2hhcnRJdGVtIiwiZmluZCIsImNoYXJ0QXJyYXkiLCJnZW5lcmF0ZVdlZWtBcnJheSIsInVwZGF0ZUNoYXJ0QXJyYXlCeVdlZWsiLCJyZXZlcnNlIiwic3RhdHNSZXNwb25zZSIsInRva2Vuc1Jlc3BvbnNlIiwic3RhdHMiLCJ0b2tlbnMiLCJjb2xsZWN0b3IiLCJuZnRzIiwiYWRkcmVzc09jY3VycmVuY2VzIiwiZmluZEFkZHJlc3NPY2N1cnJlbmNlcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/actions.js\n"));

/***/ })

});